<!DOCTYPE HTML>
<html lang="zh_TW" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Redox Operating System</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        <style>
        .light .redox-logo {
            content: url("assets/redox_light_512.png");
        }
        .rust .redox-logo {
            content: url("assets/redox_light_512.png");
        }
        .coal .redox-logo {
            content: url("assets/redox_dark_512.png");
        }
        .navy .redox-logo {
            content: url("assets/redox_dark_512.png");
        }
        .ayu .redox-logo {
            content: url("assets/redox_dark_512.png");
        }
        </style>
        <script type="text/javascript" src="ltd-provenance.js"></script>
        <script type="text/javascript" src="ltd-current.js"></script>
        <script type="text/javascript" src="../../ltd-config.js"></script>
        <script type="text/javascript" src="../../ltd-flyout.js"></script>

        <meta name="description" content="This book carefully describes the design, implementation, direction, and structure of Redox, the operating system.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>â†</kbd> or <kbd>â†’</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Redox Operating System</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="ä»‹ç´¹"><a class="header" href="#ä»‹ç´¹">ä»‹ç´¹</a></h1>
<img class="redox-logo" width=511 height=180/>
<p>é€™æ˜¯ <strong>Redox OS</strong> çš„æ‰‹å†Šï¼Œå°‡æ¶µè“‹ï¼ˆå¹¾ä¹ï¼‰æ‰€æœ‰æœ‰é—œ Redox çš„å…§å®¹ï¼šè¨­è¨ˆã€ç†å¿µã€å¦‚ä½•é‹ä½œã€å¦‚ä½•è²¢ç»ã€å¦‚ä½•éƒ¨ç½² Redoxï¼Œä»¥åŠæ›´å¤šå…¶ä»–å…§å®¹ã€‚</p>
<p><strong>Please keep in mind that this book is work-in-progress and sometimes can be outdated, any help to improve it is important.</strong></p>
<p>å¦‚æœæ‚¨æƒ³ç›´æ¥è·³åˆ°å˜—è©¦ Redox çš„éšæ®µï¼Œè«‹åƒè¦‹<a href="./getting-started.html">é–‹å§‹ä½¿ç”¨</a>é é¢ã€‚</p>
<p>If you want to contribute to Redox, read the following guides: <a href="https://gitlab.redox-os.org/redox-os/redox/-/blob/master/CONTRIBUTING.md">CONTRIBUTING</a> and <a href="./developing-for-redox.html">Developing for Redox</a>.</p>
<h2 id="conventions"><a class="header" href="#conventions">Conventions</a></h2>
<h3 id="notices"><a class="header" href="#notices">Notices</a></h3>
<p>The following notices are commonly used throughout the book to convey noteworthy information:</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Notice</th><th style="text-align: left">Meaning</th></tr></thead><tbody>
<tr><td style="text-align: left">ğŸ›ˆ <strong>Info</strong></td><td style="text-align: left">Provides neutral information to deliver key facts.</td></tr>
<tr><td style="text-align: left">ğŸ“ <strong>å‚™è¨»</strong></td><td style="text-align: left">Provides information to enhance understanding.</td></tr>
<tr><td style="text-align: left">ğŸ’¡ <strong>Tip</strong></td><td style="text-align: left">Offers suggestions to optimize an experience.</td></tr>
<tr><td style="text-align: left">âš ï¸ <strong>è­¦å‘Š</strong></td><td style="text-align: left">Highlights potential risks or mistakes.</td></tr>
</tbody></table>
</div>
<h2 id="ä»€éº¼æ˜¯-redox"><a class="header" href="#ä»€éº¼æ˜¯-redox">ä»€éº¼æ˜¯ Redoxï¼Ÿ</a></h2>
<p>Redox OS æ˜¯ä¸€æ¬¾ä»¥ <a href="https://www.rust-lang.org">Rust</a> èªè¨€ç·¨å¯«çš„é€šç”¨ä½œæ¥­ç³»çµ±ã€‚æˆ‘å€‘çš„ç›®æ¨™æ˜¯æä¾›ä¸€å€‹åŠŸèƒ½å®Œå‚™ã€é¡ Unix ä¸”åŸºæ–¼å¾®å…§æ ¸çš„ä½œæ¥­ç³»çµ±ï¼Œä¸¦ç¢ºä¿å…¶å®‰å…¨æ€§ã€å¯é æ€§èˆ‡è‡ªç”±å…è²»ã€‚</p>
<p>We have modest compatibility with <a href="https://en.wikipedia.org/wiki/POSIX">POSIX</a>, allowing Redox to run many programs without porting.</p>
<p>æˆ‘å€‘å¾ <a href="http://9p.io/plan9/index.html">Plan 9</a>ã€<a href="http://www.minix3.org/">Minix</a>ã€<a href="https://sel4.systems/">seL4</a>ã€<a href="https://www.kernel.org/">Linux</a>ã€<a href="https://openbsd.org">OpenBSD</a> å’Œ <a href="https://freebsd.org">FreeBSD</a> ä¸­ç²å¾—éˆæ„Ÿã€‚Redox è‡´åŠ›æ–¼å°‡å¤šå¹´çš„ç ”ç©¶æˆæœèˆ‡å¾—ä¾†ä¸æ˜“çš„ç¶“é©—çµåˆï¼Œæ‰“é€ å‡ºä¸€å€‹æ—¢ç¾ä»£åˆè®“äººæ„Ÿåˆ°ç†Ÿæ‚‰çš„ç³»çµ±ã€‚</p>
<p>This book is written in a way that you doesn't require any prior knowledge of Rust or OS development.</p>
<h3 id="èµ·æºæ•…äº‹"><a class="header" href="#èµ·æºæ•…äº‹">èµ·æºæ•…äº‹</a></h3>
<p>Redox OS å‰µç«‹æ–¼ 2015 å¹´ï¼Œç•¶æ™‚ Rust ç·¨è­¯å™¨çš„ç¬¬ä¸€å€‹ç©©å®šç‰ˆæœ¬ (1.0) å°šæœªç™¼å¸ƒï¼Œå®ƒæ˜¯é¦–æ‰¹ä»¥ Rust ç·¨å¯«çš„ä½œæ¥­ç³»çµ±ä¹‹ä¸€ã€‚å®ƒæœ€åˆæ˜¯ä»¥ç¨æ ¸ä½œæ¥­ç³»çµ±ï¼ˆunikernelï¼Œä¸”ä¸å«è™›æ“¬æ©Ÿå™¨ç›£è¦–å™¨ï¼‰çš„å½¢å¼èµ·æ­¥ï¼Œä¸¦åŒ¯é›†äº†è¨±å¤š Rust é–‹ç™¼è€…çš„è²¢ç»ã€‚</p>
<p>éš¨è‘—å°ˆæ¡ˆçš„é€²å±•ï¼ŒJeremy Soller æ±ºå®šå°‡ä½œæ¥­ç³»çµ±çš„é‡é»æ”¾åœ¨ç©©å®šæ€§èˆ‡å®‰å…¨æ€§ä¸Šã€‚ç‚ºäº†é”æˆé€™å€‹ç›®æ¨™ï¼ŒRedox ç¶“éé‡æ–°è¨­è¨ˆï¼Œæ¡ç”¨äº†å¾®å…§æ ¸æ¶æ§‹ä»¥åŠçµ±ä¸€çš„è³‡æºç³»çµ± APIã€‚</p>
<p>Minix èˆ‡ Plan 9 æ˜¯è©²ç³»çµ±åˆæœŸè¨­è¨ˆçš„ä¸»è¦éˆæ„Ÿä¾†æºã€‚</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ä»‹ç´¹-redox-os"><a class="header" href="#ä»‹ç´¹-redox-os">ä»‹ç´¹ Redox OS</a></h1>
<p>Redox OS æ˜¯ä¸€æ¬¾åŸºæ–¼å¾®å…§æ ¸çš„ä½œæ¥­ç³»çµ±ï¼Œæ”¯æ´å¤§é‡çš„ç¨‹å¼èˆ‡çµ„ä»¶ï¼Œç‚ºäº†æ‰“é€ ä¸€å€‹åŠŸèƒ½å®Œå‚™çš„ä½¿ç”¨è€…èˆ‡æ‡‰ç”¨ç¨‹å¼ç’°å¢ƒã€‚åœ¨æœ¬ç« ä¸­ï¼Œæˆ‘å€‘å°‡è¨è«– Redox çš„ç›®æ¨™ã€ç†å¿µèˆ‡ä½œç”¨ç¯„åœã€‚</p>
<ol>
<li><a href="our-goals.html">æˆ‘å€‘çš„ç›®æ¨™</a></li>
<li><a href="philosophy.html">æˆ‘å€‘çš„ç†å¿µ</a></li>
<li><a href="why-a-new-os.html">ç‚ºä»€éº¼éœ€è¦æ–°çš„ä½œæ¥­ç³»çµ±ï¼Ÿ</a></li>
<li><a href="redox-use-cases.html">Redox Use Cases</a></li>
<li><a href="how-redox-compares.html">Redox èˆ‡å…¶ä»–ä½œæ¥­ç³»çµ±çš„æ¯”è¼ƒ</a></li>
<li><a href="why-rust.html">Why Rust?</a></li>
<li><a href="side-projects.html">Side Projects</a></li>
<li><a href="influences.html">Influences</a></li>
<li><a href="hardware-support.html">ç¡¬é«”æ”¯æ´</a></li>
<li><a href="important-programs.html">é‡è¦ç¨‹å¼</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="æˆ‘å€‘çš„ç›®æ¨™"><a class="header" href="#æˆ‘å€‘çš„ç›®æ¨™">æˆ‘å€‘çš„ç›®æ¨™</a></h1>
<p>Redox è‡´åŠ›æ–¼æ‰“é€ ä¸€å€‹å®Œæ•´ã€åŠŸèƒ½é½Šå…¨ä¸”é€šç”¨çš„ä½œæ¥­ç³»çµ±ï¼Œä¸¦å°ˆæ³¨æ–¼å®‰å…¨æ€§ã€è‡ªç”±åº¦ã€ç©©å®šæ€§ã€æ­£ç¢ºæ€§èˆ‡å¯¦ç”¨æ€§ã€‚</p>
<p>æˆ‘å€‘å¸Œæœ›èƒ½åœ¨é›»è…¦ä¸Šç„¡éšœç¤™åœ°ä½¿ç”¨å®ƒï¼Œå°‡å…¶ä½œç‚º Linux/BSD çš„å®Œæ•´æ›¿ä»£æ–¹æ¡ˆã€‚å®ƒæ‡‰è©²èƒ½å¤ åœ¨åƒ…éœ€æ¥µå°‘ä¿®æ”¹çš„æƒ…æ³ä¸‹ï¼ŒåŸ·è¡Œå¤§å¤šæ•¸çš„ Linux/BSD ç¨‹å¼ã€‚</p>
<p>We're aiming towards a complete, stable, and safe Rust ecosystem. This is a design choice, which hopefully improves correctness and security (see the <a href="./why-rust.html">Why Rust</a> page).</p>
<p>We want to improve the security design when compared to other Unix-like operating systems by using safe defaults and limiting insecure configurations where possible.</p>
<h3 id="linuxbsd-çš„å®Œæ•´æ›¿ä»£æ–¹æ¡ˆ"><a class="header" href="#linuxbsd-çš„å®Œæ•´æ›¿ä»£æ–¹æ¡ˆ">Linux/BSD çš„å®Œæ•´æ›¿ä»£æ–¹æ¡ˆ</a></h3>
<p>Redox has its own kernel, drivers and filesystem written in Rust. The driver implementations are complete for QEMU, and <a href="./hardware-support.html">some hardware</a> are known to work well. In terms of CPU architectures, Redox aims to have an equal support for three major architectures: x86 (32 and 64 bits), ARM (64 bits) and RISC-V (64 bits).</p>
<p>Redox can run C, C++ and Rust programs with the aid of <a href="https://gitlab.redox-os.org/redox-os/relibc">relibc</a>, an almost <a href="https://en.wikipedia.org/wiki/C_POSIX_library">POSIX-compliant C Standard Library</a> written in Rust. Relibc has the goal to support most C, C++ and Rust based software. Many programs and libraries can be built and executed without any patches, some maybe need patches to workaround some functions, especially if it relies on non-POSIX functions.</p>
<p>Redox can also run GUI programs running on top of <a href="https://gitlab.redox-os.org/redox-os/orbital">Orbital</a>. C, C++ and Rust programs can draw windows with the help of <a href="https://gitlab.redox-os.org/redox-os/orbclient/"><code>orbclient</code></a> and <a href="https://gitlab.redox-os.org/redox-os/liborbital/"><code>liborbital</code></a> (our official Orbital client libraries).</p>
<p>Both system services and drivers are working well to run <a href="./important-programs.html">important programs</a>. We aim to have more POSIX and Linux compatibility to port more programs and attract more users.</p>
<h3 id="rust-ç”Ÿæ…‹ç³»çµ±"><a class="header" href="#rust-ç”Ÿæ…‹ç³»çµ±">Rust ç”Ÿæ…‹ç³»çµ±</a></h3>
<p>Rust officially supports Redox as both Tier II and Tier III <a href="https://doc.rust-lang.org/nightly/rustc/platform-support/redox.html">platforms</a>. The Rust community has accepted Redox-specific code for years. Some well-known Rust libraries (crates) that supports Redox are <a href="https://github.com/rust-windowing/winit/"><code>winit</code></a>, <a href="https://github.com/nix-rust/nix"><code>nix</code></a>, <a href="https://github.com/bytecodealliance/rustix"><code>rustix</code></a>, and much more. These crates are backed by either <a href="https://github.com/rust-lang/libc">Rust's C Standard Library Bindings</a> or a specific implementation of the <a href="https://doc.rust-lang.org/std/">Rust's Standard Library</a>. We upstream changes into these libraries as the system get new features.</p>
<p>Libraries using Rust libc are statically linked into relibc at compile-time. By this design choice, compiling any Rust program to Redox requires relibc available at linking time. While it seems like a inconvenience, it allows us to do quick development without having to push changes each time relibc is improved. To alleviate this "inconvenience", we have <a href="https://crates.io/crates/redoxer"><code>redoxer</code></a> to allow developers to compile and test Rust programs into Redox without using our complete build system.</p>
<h3 id="å®‰å…¨æ€§è¨­è¨ˆ"><a class="header" href="#å®‰å…¨æ€§è¨­è¨ˆ">å®‰å…¨æ€§è¨­è¨ˆ</a></h3>
<p>The Redox kernel is a microkernel influenced by <a href="./influences.html">some operating systems</a>, thus many system services have been moved from the kernel to userspace daemons or drivers. Both drivers and system services are normal programs in userspace with higher permissions in a special namespace which allows them to access hardware interrupts managed by the kernel.</p>
<p>All programs including the kernel, drivers and system services are talking to each other using an IPC system called "Scheme". Schemes live inside the <code>/scheme</code> filesystem directory and any program can access or create it using the standard file API. For more advanced usage software can use <code>libredox</code> and many other <code>redox-*</code> crates, detailed in <a href="./libraries-apis.html#crates">another page</a>.</p>
<p>Schemes are secured mainly by namespaces. One namespace is invisible to another one. In case of programs talking to each other in the same namespace, the kernel and drivers use caller user ID or group ID, similar to Linux having <code>sudo</code>, but we're about to change it into <a href="https://en.wikipedia.org/wiki/Capability-based_security">Capability-based security</a> in near future.</p>
<h2 id="the-non-goals-of-redox"><a class="header" href="#the-non-goals-of-redox">The non-goals of Redox</a></h2>
<p>We are not a Linux/BSD replacement, clone, or fully POSIX-compliant, nor crazy scientists who wish to redesign everything. Generally we stick to well-tested and proven correct designs: If it's not broken, don't fix it.</p>
<p>It means that a large number of programs and libraries will be compatible with Redox. Some things that do not align with our design decisions will have to be ported.</p>
<p>The key here is the trade off between correctness and compatibility. Ideally, you should be able to achieve both, but unfortunately, you can't always do so.</p>
<h3 id="software-ports-that-are-non-goals"><a class="header" href="#software-ports-that-are-non-goals">Software Ports That Are Non-Goals</a></h3>
<p>Redox aims to support most software, especially those that are important. Software that are not ported are either:</p>
<ol>
<li>Not open source or libre, or known to have legal problems</li>
<li>No longer maintained (depending on importance we can fork and maintain it) or there's better alternative</li>
<li>Only using non-portable APIs like the Linux kernel or Windows</li>
<li>Lack of users and maintainers</li>
<li>The program language compiler lack Redox support</li>
</ol>
<p>A well known example of software being too complicated to port is Chromium as it's heavily tuned to use OS-specific function calls and don't accept OS support beyond Linux in upstream, FreeBSD has to maintain <a href="https://github.com/freebsd/freebsd-ports/tree/main/www/chromium/files">hundreds of patches</a> to make sure it's working. It's easier for us to port less complicated alternatives like Firefox, WebKit and Servo given that our limited resources are better spent on improving Redox itself.</p>
<p>This doesn't stop us from porting more programs even if they are non-POSIX. For example, Wayland is challenging to port as it depends on many Linux features. But given enough time, it will became available in Redox, just like how X11 is working on Redox.</p>
<h3 id="system-designs-that-are-non-goals"><a class="header" href="#system-designs-that-are-non-goals">System Designs That Are Non-Goals</a></h3>
<p>Redox aims to have the answer to every system design challenge if possible. However, correctness and security is our top priority next to other aspect like "performance", "usability" or "stability". That may change as Redox get close to releasing the 1.0 stable version.</p>
<p>Redox have gotten though many major system design changes since its inception. Historically Redox was not designed to be a microkernel nor POSIX-compliant, then both have changed in early times. We also recently switched our system service interface (scheme) design and about to change the security design to a capability-based system.</p>
<p>Nowadays all recent and future major changes into Redox is happening via <a href="https://gitlab.redox-os.org/redox-os/rfcs">RFCs</a> and reviewed by Redox OS Board Members. Any Request For Changes that reduces correctness or security are likely not going to be accepted, but this terms are flexible and not enforced until the 1.0 stable version.</p>
<p>One example major design that trade security over "usability" is userspace exec which has been fully implemented. A userspace exec means <code>exec</code> are fully managed in userspace, it means that the kernel have no way to know how any software has been executed (e.g.their arguments and environment variables), as the kernel also have been restricted to not read any userspace memory.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="æˆ‘å€‘çš„ç†å¿µ"><a class="header" href="#æˆ‘å€‘çš„ç†å¿µ">æˆ‘å€‘çš„ç†å¿µ</a></h1>
<p>Redox OS ä¸»è¦æ¡ç”¨ MIT X11 é¢¨æ ¼çš„æˆæ¬Šæ¢æ¬¾ï¼ŒåŒ…å«æ‰€æœ‰è»Ÿé«”ã€æ–‡ä»¶èˆ‡å­—å‹ã€‚åƒ…æœ‰å°‘æ•¸ä¾‹å¤–ï¼Œè€Œé€™äº›ä¾‹å¤–çš†æ¡ç”¨å…¶ä»–ç›¸å®¹çš„é–‹æºæˆæ¬Šæ¢æ¬¾ã€‚</p>
<p>The MIT X11-style license has the following properties:</p>
<ul>
<li>It gives you, the user of the software, complete and unrestrained access to the software, such that you may <em>inspect</em>, <em>modify</em>, and <em>redistribute</em> your changes
<ul>
<li><em>Inspection</em> Anyone may inspect the software for security vulnerabilities</li>
<li><em>Modification</em> Anyone may modify the software to fix security vulnerabilities</li>
<li><em>Redistribution</em> Anyone may redistribute the software to patch the security vulnerabilities</li>
</ul>
</li>
<li>It is compatible with GPL licenses - Projects licensed as GPL can be distributed with Redox OS</li>
<li>It allows for the incorporation of GPL-incompatible free software, such as OpenZFS, which is CDDL licensed</li>
</ul>
<p>The license does not restrict the software that may run on Redox, however -- and thanks to the microkernel architecture, even traditionally tightly-coupled components such as drivers can be distributed separately, so maintainers are free to choose whatever license they like for their projects.</p>
<p>é¸æ“‡è©²æˆæ¬Šæ¢æ¬¾æ˜¯ç‚ºäº†è®“ Redox èƒ½åœ¨é™åˆ¶æœ€å°‘çš„æƒ…æ³ä¸‹è¢«å»£æ³›ä½¿ç”¨ã€‚</p>
<p>Redox intends to be free forever, because we aim to be a foundational piece in creating secure and resilient systems.</p>
<p>Programs running on top of Redox don't have to be MIT X11-style licensed, just like how other OSes do (e.g. proprietary programs and drivers on top of Linux). But all of officially ported programs so far is only OSI and GNU licensing compliant software.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ç‚ºä»€éº¼éœ€è¦æ–°çš„ä½œæ¥­ç³»çµ±"><a class="header" href="#ç‚ºä»€éº¼éœ€è¦æ–°çš„ä½œæ¥­ç³»çµ±">ç‚ºä»€éº¼éœ€è¦æ–°çš„ä½œæ¥­ç³»çµ±ï¼Ÿ</a></h1>
<p>The essential goal of the Redox project is to build a robust, reliable and safe general-purpose operating system. To that end, the following key design choices have been made.</p>
<h2 id="written-in-rust"><a class="header" href="#written-in-rust">Written in Rust</a></h2>
<p>Wherever possible, Redox code is written in <a href="https://www.rust-lang.org/">Rust</a>. Rust enforces a set of rules and checks on the use, sharing and deallocation of memory references. This almost entirely eliminates the potential for memory leaks, buffer overruns, use after free, and other <a href="https://en.wikipedia.org/wiki/Memory_safety#Types_of_memory_errors">memory errors</a> that arise during development. The vast majority of security vulnerabilities in operating systems originate from memory errors. The Rust compiler prevents this type of error before the developer attempts to add it to the code base.</p>
<p>It allows us to unlock the full Rust potential by dropping legacy C and C++ code.</p>
<h3 id="benefits"><a class="header" href="#benefits">Benefits</a></h3>
<p>ä»¥ä¸‹é …ç›®ç¸½çµäº† Rust çš„å„ªé»ï¼š</p>
<ul>
<li>
<p>è¨˜æ†¶é«”å®‰å…¨</p>
<p>All memory allocations are verified by the compiler to prevent bugs.</p>
</li>
<li>
<p>Thread-Safety</p>
<p>Concurrent code in programs is immune to data races.</p>
</li>
<li>
<p>NULL å®‰å…¨æ€§</p>
<p>NULL ä¸æœƒå°è‡´æœªå®šç¾©è¡Œç‚ºã€‚</p>
</li>
</ul>
<h2 id="å¾®å…§æ ¸æ¶æ§‹"><a class="header" href="#å¾®å…§æ ¸æ¶æ§‹">å¾®å…§æ ¸æ¶æ§‹</a></h2>
<p>The <a href="https://en.wikipedia.org/wiki/Microkernel">Microkernel Architecture</a> moves as much system components as possible out of the operating system kernel. Drivers, subsystems and other operating system functionality are excuted as independent processes on user-space (daemons). The kernel's main responsibility is the coordination of these processes, and the management of system resources to the processes.</p>
<p>Most kernels, other than some real-time operating systems, use an event-handler design. Hardware interrupts and application system calls, each one trigger an event invoking the appropriate handler. The kernel runs in supervisor-mode, with access to all system's resources. In <a href="https://en.wikipedia.org/wiki/Monolithic_kernel">Monolithic Kernels</a>, the operating system's entire response to an event must be completed in supervisor mode. A bug in the kernel, drivers or hardware, can cause the system to enter a state where it can't to respond to <em>any</em> event. And because of the large amount of code in the kernel, the potential for vulnerabilities while in supervisor mode is vastly greater than for a microkernel design.</p>
<p>Beyond monolithic kernels being much more vulnerable to bugs there's also the much higher complexity of post-Internet modern hardware and drivers that didn't existed when monolithic kernels were adopted, but since the adoption of Internet and the implementation of the <a href="https://en.wikipedia.org/wiki/Internet_protocol_suite">TCP/IP</a> network stack in <a href="https://en.wikipedia.org/wiki/Berkeley_Software_Distribution">BSD Unix</a> the complexity grew fast. This growth has caused a epidemic of bugs that are hard or invisible to debug due to all monolithic kernel components sharing the same memory address space.</p>
<p>In Redox, drivers and many system services can run in user-mode, similar to user programs, and the system can restrict them so they can only access the resources that they require for their designated purpose. If a driver fails or panics, it could be ignored or restarted with no impact on the rest of the system. A misbehaving piece of hardware might impact system performance or cause the loss of a service with a small chance of data corruption, but the kernel and maybe the essential system components will continue to function and to provide whatever services remain available.</p>
<p>Thus Redox is an unique opportunity to show the microkernel potential for the mainstream operating systems universe with the features and comodity that you would expect from them.</p>
<h3 id="benefits-1"><a class="header" href="#benefits-1">Benefits</a></h3>
<p>The following items summarize the microkernel benefits:</p>
<ul>
<li>
<p>More stable and secure</p>
<p>The very small size of the kernel allow the system to be more stable and secure because most system components are isolated in user-space, reducing the chance of a <a href="https://en.wikipedia.org/wiki/Kernel_panic">kernel panic</a> and the severity of security bugs.</p>
</li>
<li>
<p>Bug isolation</p>
<p>Most system components run in user-space on a microkernel system. Because of this some types of bugs in most system components and drivers can't spread to other system components or drivers.</p>
</li>
<li>
<p>More stable long execution</p>
<p>When an operating system is left running for a long time (days, months or even years) it will activate many bugs and it's hard to know when they were activated, at some point these bugs can cause security issues, data corruption or crash the system.</p>
<p>In a microkernel most system components are isolated and some bug types can't spread to other system components, thus the long execution tend to enable less bugs reducing the security issues, data corruption and downtime on servers.</p>
<p>Also some system components can be restarted on-the-fly (without a full system restart) to disable the bugs of a long execution.</p>
</li>
<li>
<p>Restartless design</p>
<p>A mature microkernel changes very little (except for bug fixes), so you won't need to restart your system very often to update it.</p>
<p>Since most system components are in userspace they can be restarted/updated on-the-fly, reducing the downtime of servers a lot.</p>
</li>
<li>
<p>Easy to develop and debug</p>
<p>Most system components run in userspace, simplifying the testing and debugging.</p>
</li>
<li>
<p>Easy and quick to expand</p>
<p>New system components and drivers are easily and quickly added as userspace daemons.</p>
</li>
<li>
<p>True modularity</p>
<p>You can enable/disable/update most system components without a system restart, similar to but safer than some modules on monolithic kernels and <a href="https://en.wikipedia.org/wiki/Kpatch">livepatching</a>.</p>
</li>
</ul>
<p>You can read more about the above benefits on the <a href="./microkernels.html">Microkernels</a> page.</p>
<h2 id="é€²éšæª”æ¡ˆç³»çµ±"><a class="header" href="#é€²éšæª”æ¡ˆç³»çµ±">é€²éšæª”æ¡ˆç³»çµ±</a></h2>
<p>Redox provides an advanced filesystem, <a href="https://gitlab.redox-os.org/redox-os/redoxfs">RedoxFS</a>. It includes many of the features in <a href="https://en.wikipedia.org/wiki/OpenZFS">ZFS</a>, but in a more modular design.</p>
<p>More details on RedoxFS can be found on the <a href="./redoxfs.html">RedoxFS</a> page.</p>
<h2 id="é¡-unix-å·¥å…·èˆ‡-api"><a class="header" href="#é¡-unix-å·¥å…·èˆ‡-api">é¡ Unix å·¥å…·èˆ‡ API</a></h2>
<p>Redox provides a Unix-like command interface, with many everyday tools written in Rust but with familiar names and options. As well, Redox system services include a programming interface that is a subset of the <a href="https://en.wikipedia.org/wiki/POSIX">POSIX</a> API, via <a href="https://gitlab.redox-os.org/redox-os/relibc">relibc</a>. This means that many Linux/POSIX programs can run on Redox with only recompilation. While the Redox team has a strong preference for having essential programs written in Rust, we are agnostic about the programming language for programs of the user's choice. This means an easy migration path for systems and programs previously developed for a Unix-like platform.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ç‚ºä»€éº¼ä½¿ç”¨-rust"><a class="header" href="#ç‚ºä»€éº¼ä½¿ç”¨-rust">ç‚ºä»€éº¼ä½¿ç”¨ Rustï¼Ÿ</a></h1>
<p>Why we wrote an operating system in Rust? Why even write in Rust?</p>
<p>Rust has enormous advantages, because for operating systems, security and stability matters a lot.</p>
<p>Since operating systems are such an integrated part of computing, they are the most important piece of software.</p>
<p>There have been numerous bugs and vulnerabilities in Linux, BSD, glibc, Bash, X11, etc. throughout time, simply due to the lack of memory allocation and type safety. Rust does this right, by enforcing memory safety statically.</p>
<p>Design does matter, but so does implementation. Rust attempts to avoid these unexpected memory unsafe conditions (which are a major source of security critical bugs). Design is a very transparent source of issues. You know what is going on, you know what was intended and what was not.</p>
<p>The basic design of the kernel/user-space separation is fairly similar to Unix-like systems, at this point. The idea is roughly the same: you separate kernel and user-space, through strict enforcement by the kernel, which manages system resources.</p>
<p>However, we have an advantage: enforced memory and type safety. This is Rust's strong side, a large number of "unexpected bugs" (for example, undefined behavior) are eliminated at compile-time.</p>
<p>The design of Linux and BSD is secure. The implementation is not. Many bugs in Linux originate in unsafe conditions (which Rust effectively eliminates) like buffer overflows, not the overall design.</p>
<p>We hope that using Rust we will produce a more secure and stable operating system in the end.</p>
<h2 id="unsafes"><a class="header" href="#unsafes">Unsafes</a></h2>
<p><code>unsafe</code> is a way to tell Rust that "I know what I'm doing!", which is often necessary when writing low-level code, providing safe abstractions. You cannot write a kernel without <code>unsafe</code>.</p>
<p>In that light, a kernel cannot be 100% verified by the Rust compiler, however the unsafe parts have to be marked with an <code>unsafe</code>, which keeps the unsafe parts segregated from the safe code. We seek to eliminate the <code>unsafe</code>s where we can, and when we use <code>unsafe</code>s, we are extremely careful.</p>
<p>This contrasts with kernels written in C, which cannot make guarantees about security without costly formal analysis.</p>
<p>You can find out more about how <code>unsafe</code> works in the <a href="https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html">relevant section</a> of the Rust book.</p>
<h2 id="benefits-2"><a class="header" href="#benefits-2">Benefits</a></h2>
<p>The following sections explain the Rust benefits.</p>
<h3 id="less-likely-to-have-bugs"><a class="header" href="#less-likely-to-have-bugs">Less likely to have bugs</a></h3>
<p>The restrictive syntax and compiler requirements to build the code reduce the probability of bugs a lot.</p>
<h3 id="less-vulnerable-to-data-corruption"><a class="header" href="#less-vulnerable-to-data-corruption">Less vulnerable to data corruption</a></h3>
<p>The Rust compiler helps the programmer to avoid memory errors and race conditions, which reduces the probability of data corruption bugs.</p>
<h3 id="no-need-for-cc-exploit-mitigations"><a class="header" href="#no-need-for-cc-exploit-mitigations">No need for C/C++ exploit mitigations</a></h3>
<p>The microkernel design written in Rust protects against memory defects that one might see in software written in C/C++.</p>
<p>By isolating the system components from the kernel, the <a href="https://en.wikipedia.org/wiki/Attack_surface">attack surface</a> is very limited.</p>
<h3 id="improved-security-and-reliability-without-significant-performance-impact"><a class="header" href="#improved-security-and-reliability-without-significant-performance-impact">Improved security and reliability without significant performance impact</a></h3>
<p>As the kernel is small, it uses less memory to do its work. The limited kernel code size helps us work towards a bug-free status (<a href="https://en.wikipedia.org/wiki/KISS_principle">KISS</a>).</p>
<p>Rust's safe and fast language design, combined with the small kernel code size, helps ensure a reliable, performant and easy to maintain core.</p>
<h3 id="thread-safety"><a class="header" href="#thread-safety">Thread-safety</a></h3>
<p>The C/C++ support for thread-safety is quite fragile. As such, it is very easy to write a program that looks safe to run across multiple threads, but which introduces subtle bugs or security holes. If one thread accesses a piece of state at the same time that another thread is changing it, the whole program can exhibit some truly confusing and bizarre bugs.</p>
<p>You can see <a href="https://en.wikipedia.org/wiki/Time_of_check_to_time_of_use">this example</a> of a serious class of security bugs that thread-safety fixes.</p>
<p>In Rust, this kind of bug is easy to avoid: the same type system that keeps us from writing memory unsafety prevents us from writing dangerous concurrent access patterns</p>
<h3 id="rust-written-drivers"><a class="header" href="#rust-written-drivers">Rust-written Drivers</a></h3>
<p>Drivers written in Rust are likely to have fewer bugs and are therefore more stable and secure.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="redox-ä½¿ç”¨æ¡ˆä¾‹"><a class="header" href="#redox-ä½¿ç”¨æ¡ˆä¾‹">Redox ä½¿ç”¨æ¡ˆä¾‹</a></h1>
<p>Redox is a general-purpose operating system that can be used in many situations. Some of the key use cases for Redox are as follows.</p>
<h2 id="server"><a class="header" href="#server">Server</a></h2>
<p>Redox æœ‰æ½›åŠ›æˆç‚ºé›²ç«¯æœå‹™èˆ‡ç¶²é è¨—ç®¡çš„å®‰å…¨ä¼ºæœå™¨å¹³å°ã€‚éš¨è‘— Redox é€æ¼¸æˆç†Ÿï¼Œå…¶æ‰€èƒ½æä¾›çš„å®‰å…¨æ€§èˆ‡å¯é æ€§æå‡ï¼Œä½¿å…¶éå¸¸é©åˆä¼ºæœå™¨é ˜åŸŸã€‚ç›®å‰ä»éœ€åœ¨æ”¯æ´é‡è¦ä¼ºæœå™¨æŠ€è¡“ï¼ˆä¾‹å¦‚ï¼šè³‡æ–™åº«èˆ‡ç¶²é ä¼ºæœå™¨ï¼‰ä»¥åŠé«˜éšä¼ºæœå™¨ç¡¬é«”ç›¸å®¹æ€§æ–¹é¢æŒçºŒåŠªåŠ›ã€‚</p>
<p>Redox has plans underway for <a href="https://en.wikipedia.org/wiki/OS-level_virtualization">virtualization</a> support. Although running an instance of Linux in a container on Redox will lose some of the benefits of Redox, it can limit the scope of vulnerabilities. Redox-on-Redox and Linux-on-Redox virtualization have the potential to be much more secure than Linux-on-Linux. These capabilities are still a ways off, but are among the goals of the Redox team.</p>
<h2 id="desktop"><a class="header" href="#desktop">Desktop</a></h2>
<p>The development of Redox for the desktop is well underway. Although support for accelerated graphics is limited at this time, Redox does include a graphical user interface, and support on Rust-written GUI libraries like <a href="https://github.com/rust-windowing/winit">winit</a>, <a href="https://iced.rs/">Iced</a> and <a href="https://slint-ui.com/">Slint</a>.</p>
<p>A demo version of Redox is available with several games and programs to try. However, the most important objective for desktop is to host the development of Redox. We are working through issues with some of our build tools, and other developer tools such as editors have not been tested under daily use, but we continue to make this a priority.</p>
<p>Due to a fairly limited list of currently supported hardware, once self-hosted development is available the development can be done inside of Redox with more quick testing. We are adding more hardware compatibility as quickly as we can, and we hope to be able to support the development on a wide array of desktops and notebooks in the near future.</p>
<h2 id="åŸºç¤è¨­æ–½"><a class="header" href="#åŸºç¤è¨­æ–½">åŸºç¤è¨­æ–½</a></h2>
<p>Redox's modular architecture make it ideal for many telecom infrastructure applications, such as routers, telecom components, edge servers, etc., especially as more functionality is added to these devices. There are no specific plans for remote management yet, but Redox's potential for security and reliability make it ideal for this type of application.</p>
<h2 id="åµŒå…¥å¼èˆ‡ç‰©é€£ç¶²"><a class="header" href="#åµŒå…¥å¼èˆ‡ç‰©é€£ç¶²">åµŒå…¥å¼èˆ‡ç‰©é€£ç¶²</a></h2>
<p>For embedded systems with complex user interfaces and broad feature sets, Redox has the potential to be an ideal fit. As everyday appliances become Internet-connected devices with sensors, microphones and cameras, they have the potential for attacks that violate the privacy of consumers in the sanctity of their homes. Redox can provide a full-featured, reliable operating system while limiting the likelihood of attacks. At this time, Redox does not yet have touchscreen support, video capture, or support for sensors and buttons, but these are well-understood technologies and can be added as it becomes a priority.</p>
<h2 id="é—œéµä»»å‹™æ‡‰ç”¨"><a class="header" href="#é—œéµä»»å‹™æ‡‰ç”¨">é—œéµä»»å‹™æ‡‰ç”¨</a></h2>
<p>é›–ç„¶ç›®å‰å°šç„¡è¨ˆåŠƒå°‡ Redox ç”¨æ–¼è¡›æ˜Ÿæˆ–èˆªç©ºå®‰å…¨ç³»çµ±ç­‰é—œéµä»»å‹™æ‡‰ç”¨ï¼Œä½†é€™ä¸¦éä¸å¯èƒ½ã€‚éš¨è‘— Rust è»Ÿé«”æ­£ç¢ºæ€§è­‰æ˜å·¥å…·çš„é€²æ­¥ï¼Œæœªä¾†æˆ–è¨±èƒ½åœ¨æŸäº›å¯¦éš›é™åˆ¶å…§ï¼Œé–‹ç™¼å‡ºç¶“è­‰æ˜ç‚ºæ­£ç¢ºçš„ Redox ç‰ˆæœ¬ã€‚</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="redox-èˆ‡å…¶ä»–ä½œæ¥­ç³»çµ±çš„æ¯”è¼ƒ"><a class="header" href="#redox-èˆ‡å…¶ä»–ä½œæ¥­ç³»çµ±çš„æ¯”è¼ƒ">Redox èˆ‡å…¶ä»–ä½œæ¥­ç³»çµ±çš„æ¯”è¼ƒ</a></h1>
<p>æˆ‘å€‘èˆ‡å…¶ä»–ä½œæ¥­ç³»çµ±æœ‰è¨±å¤šå…±åŒä¹‹è™•ã€‚</p>
<h2 id="ç³»çµ±å‘¼å«"><a class="header" href="#ç³»çµ±å‘¼å«">ç³»çµ±å‘¼å«</a></h2>
<p>The Redox userspace API is Unix-like. For example, we have the <code>open</code>, <code>pipe</code>, <code>pipe2</code>, <code>lseek</code>, <code>read</code>, <code>write</code>, <code>brk</code>, <code>execv</code> POSIX functions, and so on. Currently, we implement userspace analogues of most Unix-like system calls (on monolithic kernels). The kernel syscall interface itself is unstable and may not be similar at all, but is closely related to the higher-level POSIX APIs built on top of them, at the moment.</p>
<p>However, Redox does not necessarily implement them as system calls directly. Much of the machinery for these functions (typically the <a href="https://en.wikipedia.org/wiki/Man_page#Manual_sections">man(2)</a> functions) is provided in userspace through an interface library, <code>relibc</code>.</p>
<p>ä¾‹å¦‚ï¼Œ<code>open</code> é€™å€‹ POSIX å‡½å¼åœ¨ relibc ä¸­è¢«ç¨±ç‚º <code>SYS_OPEN</code>ã€‚</p>
<h2 id="ä¸€åˆ‡çš†æª”æ¡ˆ"><a class="header" href="#ä¸€åˆ‡çš†æª”æ¡ˆ">ã€Œä¸€åˆ‡çš†æª”æ¡ˆã€</a></h2>
<p>In a model largely inspired by Plan 9, in Redox, <a href="./resources.html">resources</a> can be socket-like or file-like, providing a more unified system API. Resources are named using paths, similar to what you would find in Linux or another Unix system. But when referring to a resource that is being managed by a particular resource manager, you can address it using a scheme-rooted path. We will explain this later, in the <a href="./schemes-resources.html">Schemes and Resources</a> page.</p>
<h2 id="å…§æ ¸"><a class="header" href="#å…§æ ¸">å…§æ ¸</a></h2>
<p>Redox çš„å…§æ ¸æ˜¯ä¸€å€‹å¾®å…§æ ¸ã€‚å…¶æ¶æ§‹ä¸»è¦å— MINIX èˆ‡ seL4 çš„å•Ÿç™¼ã€‚</p>
<p>In contrast to Linux or BSD, Redox has around 50,000 lines of kernel code, a number that is often decreasing. Most system services are provided in userspace, either in an interface library, or as daemons.</p>
<p>Having vastly smaller amount of code in the kernel makes it easier to find and fix bugs/security issues in an efficient way. Andrew Tanenbaum (author of MINIX) stated that for every 1,000 lines of properly written C code, there is a bug. This means that for a monolithic kernel with nearly 25,000,000 lines of C code, there could be nearly 25,000 bugs. A microkernel with only 50,000 lines of C code would mean that around 50 bugs exist (Tanenbaum Law).</p>
<p>It should be noted that in a microkernel the high amount of code (present in a monolithic kernel) is not removed, it's just moved to user-space daemons to make it less dangerous.</p>
<p>The main idea is to have system components and drivers that would be inside a monolithic kernel exist in user-space and follow the Principle of Least Authority (POLA). This is where every individual component is:</p>
<ul>
<li>Completely isolated in memory as separated user processes (daemons)
<ul>
<li>The failure of one component does not crash other components</li>
<li>Foreign and untrusted code does not expose the entire system</li>
<li>Bugs and malware cannot spread to other components</li>
</ul>
</li>
<li>Has restricted communication with other components</li>
<li>Doesn't have Admin/Super-User privileges
<ul>
<li>Bugs are moved to user-space which reduces their power</li>
</ul>
</li>
</ul>
<p>All of this increases the reliability of the system significantly. This is important for users that want minimal issues with their computers or mission-critical applications.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="å½±éŸ¿"><a class="header" href="#å½±éŸ¿">å½±éŸ¿</a></h1>
<p>This page explains how Redox was influenced by other operating systems.</p>
<p>(The list is ordered by influence level)</p>
<h2 id="minix"><a class="header" href="#minix"><a href="https://minix3.org/">Minix</a></a></h2>
<p>The most influential Unix-like system with a microkernel. It has advanced features such as system modularity, <a href="https://en.wikipedia.org/wiki/Kernel_panic">kernel panic</a> resistence, driver reincarnation, protection against bad drivers and secure interfaces for <a href="https://en.wikipedia.org/wiki/Inter-process_communication">process comunication</a>.</p>
<p>Redox is largely influenced by Minix - it has a similar architecture but with a feature set written in Rust.</p>
<ul>
<li><a href="./microkernels.html">How Minix influenced the Redox design</a></li>
</ul>
<h2 id="sel4"><a class="header" href="#sel4"><a href="https://sel4.systems/">seL4</a></a></h2>
<p>The most performant and simplest microkernel of the world.</p>
<p>Redox follow the same principle, trying to make the kernel-space small as possible (moving components to user-space and reducing the number of system calls, passing the complexity to user-space) and keeping the overall performance good (reducing the context switch cost).</p>
<h2 id="plan-9"><a class="header" href="#plan-9"><a href="http://9p.io/plan9/index.html">Plan 9</a></a></h2>
<p>This Bell Labs OS brings the concept of "Everything is a File" to the highest level, doing all the system communication from the filesystem.</p>
<ul>
<li><a href="https://drewdevault.com/2022/11/12/In-praise-of-Plan-9.html">Drew DeVault explains the Plan 9</a></li>
<li><a href="./schemes-resources.html">Plan 9's influence on Redox</a></li>
</ul>
<h2 id="linux"><a class="header" href="#linux"><a href="https://www.kernel.org/">Linux</a></a></h2>
<p>The most advanced monolithic kernel and biggest open-source project of the world. It brought several improvements and optimizations to the Unix-like world.</p>
<p>Redox tries to implement the Linux performance improvements in a microkernel design.</p>
<h2 id="bsd"><a class="header" href="#bsd"><a href="https://en.wikipedia.org/wiki/Berkeley_Software_Distribution">BSD</a></a></h2>
<p>This Unix <a href="https://en.wikipedia.org/wiki/Research_Unix">family</a> included several improvements on Unix systems and the open-source variants of BSD added many improvements to the original system (like Linux did).</p>
<ul>
<li>
<p><a href="https://www.freebsd.org/">FreeBSD</a> - The <a href="https://man.freebsd.org/cgi/man.cgi?capsicum(4)">Capsicum</a> (a capability-based system) and <a href="https://en.wikipedia.org/wiki/Freebsd_jail">jails</a> (a sandbox technology) influenced the Redox namespaces implementation.</p>
</li>
<li>
<p><a href="https://www.openbsd.org/">OpenBSD</a> - The <a href="https://man.openbsd.org/pledge.2">system call</a>, <a href="https://man.openbsd.org/unveil.2">filesystem</a>, <a href="https://www.xenocara.org/">display server</a> and <a href="https://man.openbsd.org/sndiod.8">audio server</a> sandbox and <a href="https://www.openbsd.org/innovations.html">others</a> influenced the Redox security.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ç¡¬é«”æ”¯æ´"><a class="header" href="#ç¡¬é«”æ”¯æ´">ç¡¬é«”æ”¯æ´</a></h1>
<p>There are billions of devices with hundreds of models and architectures in the world. We try to write drivers for the most used devices to support more people. Support depends on the specific hardware, since some drivers are device-specific and others are architecture-specific.</p>
<p>Have a look at the <a href="https://gitlab.redox-os.org/redox-os/redox/-/blob/master/HARDWARE.md">HARDWARE.md</a> document to see all tested computers.</p>
<h2 id="cpu-requirements"><a class="header" href="#cpu-requirements">CPU Requirements</a></h2>
<p>The following requirements are mandatory to make Redox work, non-x86 CPUs have equivalents for them.</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Memory_management_unit">MMU</a> : Introduced by the Intel 8086 CPU line in 1978 and present in all CPUs since then</li>
<li><a href="https://en.wikipedia.org/wiki/Floating-point_unit">FPU</a> : Introduced by the Intel 8087 coprocessor in 1980 for the Intel 8086 CPU line and present in almost all CPUs since then</li>
<li>FXSAVE extension or non-x86 CPU equivalent</li>
<li><a href="https://en.wikipedia.org/wiki/Page_Size_Extension">Page Size Extension</a> or non-x86 CPU equivalent</li>
<li>Paging global extension or non-x86 CPU equivalent</li>
</ul>
<h2 id="i-have-a-low-end-computer-would-redox-work-on-it"><a class="header" href="#i-have-a-low-end-computer-would-redox-work-on-it">I have a low-end computer, would Redox work on it?</a></h2>
<p>A CPU is the most complex machine of the world: even the oldest processors are powerful for some tasks but not for others.</p>
<p>The main problem with old computers is the amount of DRAM memory available (they were sold in a era where RAM chips were expensive) and the lack of SSE/AVX extensions (programs use them to speed up the algorithms). Because of this some modern programs may not work or require a lot of RAM to perform complex tasks.</p>
<p>Redox itself will work normally if the CPU architecture is supported by the system, but the performance and stability may vary per program.</p>
<h2 id="why-choosing-i586-as-the-minimal-supported-x86-cpu"><a class="header" href="#why-choosing-i586-as-the-minimal-supported-x86-cpu">Why choosing i586 as the minimal supported x86 CPU?</a></h2>
<ul>
<li>i686 (<a href="https://en.wikipedia.org/wiki/Pentium_Pro">Pentium Pro</a>) introduced MMX, SSE, and SSE2 <a href="https://en.wikipedia.org/wiki/P6_(microarchitecture)">extensions</a>. Fortunately the kernel and other critical system components don't use them.</li>
<li>i586 (<a href="https://en.wikipedia.org/wiki/Pentium_(original)">Original Pentium</a>) introduced a more efficient FPU and MMX extension which are critical for programs, also the most minimal CPU architecture supported by <a href="https://doc.rust-lang.org/beta/rustc/platform-support.html">Rust</a> and perhaps most Rust packages.</li>
<li><a href="https://en.wikipedia.org/wiki/I486">i486</a> introduced FPU and atomic operations, which are used by the kernel and other critical system components. It would be possible to go all the way back to i486, but Redox will run with much less programs.</li>
<li><a href="https://en.wikipedia.org/wiki/I386">i386</a> has no atomics and floating instructions (at all), which makes it not a target for both the kernel and other critical system components.</li>
</ul>
<h2 id="compatibility-table"><a class="header" href="#compatibility-table">Compatibility Table</a></h2>
<div class="table-wrapper"><table><thead><tr><th><strong>Category</strong></th><th><strong>Items</strong></th></tr></thead><tbody>
<tr><td>CPU</td><td>- Intel 64-bit (x86_64) <br>- Intel 32-bit (i586) from Pentium II and after with limitations <br>- AMD 32/64-bit <br>- ARM 64-bit (aarch64) with limitations <br>- RISC-V 64-bit (riscv64gc) with limitations</td></tr>
<tr><td>Hardware Interfaces</td><td>- ACPI, PCI, USB</td></tr>
<tr><td>Storage</td><td>- IDE (PATA), SATA (AHCI), NVMe</td></tr>
<tr><td>Video</td><td>- BIOS VESA, UEFI GOP, Intel GPU</td></tr>
<tr><td>Sound</td><td>- Intel, Realtek chipsets</td></tr>
<tr><td>Input</td><td>- PS/2 keyboards, mouse, and touchpad <br> - USB keyboards, mouse and touchpad</td></tr>
<tr><td>Ethernet</td><td>- Intel Gigabit and 10 Gigabit ethernet <br>- Realtek ethernet</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="é‡è¦ç¨‹å¼"><a class="header" href="#é‡è¦ç¨‹å¼">é‡è¦ç¨‹å¼</a></h1>
<p>This page covers important programs and libraries supported by Redox as of October 2025. <!-- don't forget to update this date --></p>
<p>Redox is designed to be source-compatible with POSIX and Linux applications, only requiring compilation or small patches.</p>
<p>This page contain programs that are known to work well on Redox or how well it was tested. All programs are compiled through our package cross-compilation system called Cookbook, which includes the configuration of all kinds of patches and forks that are required to make them run on Redox.</p>
<p>Everything on the following lists are tested on the x86_64 (Intel/AMD) CPU architecture, other CPU architectures may not have been tested yet.</p>
<h2 id="ç·¨è­¯å™¨"><a class="header" href="#ç·¨è­¯å™¨">ç·¨è­¯å™¨</a></h2>
<p>The following compilers have been tested to build on Redox, but the runtime status varies:</p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Can cross-compile from Linux?</th><th>Can compile programs on Redox?</th><th>Compiled programs can run on Redox?</th></tr></thead><tbody>
<tr><td>GCC 13</td><td>Yes</td><td>Yes</td><td>Working Well</td></tr>
<tr><td>Rust 1.90</td><td>Yes</td><td>Always Crashing</td><td>Working Well</td></tr>
<tr><td>Go 1.25</td><td>Yes</td><td>Always Crashing</td><td>Always Crashing</td></tr>
<tr><td>Zig 0.15</td><td>Not Known</td><td>Not Known</td><td>Not Known</td></tr>
</tbody></table>
</div>
<h2 id="interpreters"><a class="header" href="#interpreters">Interpreters</a></h2>
<p>The following interpreters have been tested to build on Redox, but the runtime status varies:</p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Can be compiled?</th><th>Works on Redox?</th></tr></thead><tbody>
<tr><td>RustPython</td><td>Yes</td><td>Working Well</td></tr>
<tr><td>CPython 3.12</td><td>Yes</td><td>Working Well</td></tr>
<tr><td>Lua 5.4</td><td>Yes</td><td>Not Known</td></tr>
<tr><td>LuaJit 2.1</td><td>Yes</td><td>Often Crashing</td></tr>
<tr><td>Node.js 24</td><td>Yes</td><td>Always Crashing</td></tr>
<tr><td>PHP 8.4</td><td>Yes</td><td>Mostly Well</td></tr>
</tbody></table>
</div>
<h2 id="gui-ç¨‹å¼åº«"><a class="header" href="#gui-ç¨‹å¼åº«">GUI ç¨‹å¼åº«</a></h2>
<p>Most GUI applications are running through Orbital (Redox display server and window manager), it supports the following GUI libraries:</p>
<ul>
<li>Mesa3D (OpenGL and EGL, via liborbital)</li>
<li>SDL1 and SDL2 (via Mesa3D)</li>
<li>winit (via orbclient)</li>
<li>X11 (via TWM, which is via liborbital)</li>
</ul>
<h2 id="applications"><a class="header" href="#applications">Applications</a></h2>
<p>The following programs are well known to be working:</p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>GUI å¾Œç«¯</th><th>Working?</th></tr></thead><tbody>
<tr><td>COSMIC ç·¨è¼¯å™¨</td><td>winit</td><td>Working Well</td></tr>
<tr><td>COSMIC æª”æ¡ˆ</td><td>winit</td><td>Working Well</td></tr>
<tr><td>COSMIC Reader</td><td>winit</td><td>Working Well</td></tr>
<tr><td>COSMIC Store</td><td>winit</td><td>Not Tested</td></tr>
<tr><td>COSMIC çµ‚ç«¯æ©Ÿ</td><td>winit</td><td>Working Well</td></tr>
<tr><td>Netsurf</td><td>SDL1</td><td>Working Well</td></tr>
<tr><td>FFplay</td><td>SDL2</td><td>Working Well</td></tr>
<tr><td>Servo</td><td>Mesa3D</td><td>Often Crashes</td></tr>
<tr><td>xterm</td><td>X11</td><td>Working Well</td></tr>
<tr><td>xeyes</td><td>X11</td><td>Working Well</td></tr>
</tbody></table>
</div>
<h3 id="emulators"><a class="header" href="#emulators">Emulators</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>GUI å¾Œç«¯</th><th>Working?</th></tr></thead><tbody>
<tr><td>DOSBox</td><td>SDL1</td><td>Working Well</td></tr>
<tr><td>Mednafen</td><td>SDL2</td><td>Working Well</td></tr>
<tr><td>MGBA</td><td>SDL1</td><td>Working Well</td></tr>
<tr><td>RVVM</td><td>SDL1</td><td>Working Well</td></tr>
</tbody></table>
</div>
<h3 id="games"><a class="header" href="#games">Games</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>GUI å¾Œç«¯</th><th>Working?</th></tr></thead><tbody>
<tr><td>Freeciv</td><td>SDL2</td><td>Working Well</td></tr>
<tr><td>Gigalomania</td><td>SDL1</td><td>Working Well</td></tr>
<tr><td>Neverball</td><td>SDL2</td><td>Working Well</td></tr>
<tr><td>OpenTTD</td><td>SDL1</td><td>Working Well</td></tr>
<tr><td>OpenTyrian</td><td>SDL2</td><td>Working Well</td></tr>
<tr><td>Prboom</td><td>SDL2</td><td>Working Well</td></tr>
<tr><td>Quakespam</td><td>SDL2</td><td>Working Well</td></tr>
<tr><td>SpaceCadet Pinball</td><td>SDL2</td><td>Working Well</td></tr>
</tbody></table>
</div>
<h2 id="servers"><a class="header" href="#servers">Servers</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Working?</th></tr></thead><tbody>
<tr><td>OpenSSH Daemon</td><td>Working Well</td></tr>
<tr><td>Nginx</td><td>Working Well</td></tr>
<tr><td>Simple HTTP Server</td><td>Working Well</td></tr>
<tr><td>Python Static Server</td><td>Not Tested</td></tr>
<tr><td>PHP-FPM</td><td>Not Tested</td></tr>
</tbody></table>
</div>
<h2 id="cli-tools"><a class="header" href="#cli-tools">CLI Tools</a></h2>
<p>The following CLI tools are known to be working. Programs listed below may not include <a href="./side-projects.html">core utilites</a>:</p>
<h3 id="terminal-shells"><a class="header" href="#terminal-shells">Terminal Shells</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Working?</th></tr></thead><tbody>
<tr><td>GNU Bash</td><td>Working Well</td></tr>
<tr><td>Ion</td><td>Working Well</td></tr>
<tr><td>Nushell</td><td>Not Tested</td></tr>
<tr><td>Fish</td><td>Hangs</td></tr>
<tr><td>Zsh</td><td>Hangs</td></tr>
</tbody></table>
</div>
<h3 id="æ–‡å­—ç·¨è¼¯å™¨"><a class="header" href="#æ–‡å­—ç·¨è¼¯å™¨">æ–‡å­—ç·¨è¼¯å™¨</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Working?</th></tr></thead><tbody>
<tr><td>Kibi</td><td>Working Well</td></tr>
<tr><td>GNU Nano</td><td>Working Well</td></tr>
<tr><td>Vim</td><td>Working Well</td></tr>
<tr><td>Sodium</td><td>Working Well</td></tr>
<tr><td>Neovim</td><td>Crashes</td></tr>
</tbody></table>
</div>
<h3 id="system-monitors"><a class="header" href="#system-monitors">System Monitors</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Working?</th></tr></thead><tbody>
<tr><td>Bottom</td><td>Working Well</td></tr>
<tr><td>Htop</td><td>Working Well</td></tr>
</tbody></table>
</div>
<h3 id="é–‹ç™¼å·¥å…·"><a class="header" href="#é–‹ç™¼å·¥å…·">é–‹ç™¼å·¥å…·</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Working?</th></tr></thead><tbody>
<tr><td>Git</td><td>Working Well</td></tr>
<tr><td>GNU Autotools</td><td>Not Tested</td></tr>
<tr><td>GNU Binutils</td><td>Working Well</td></tr>
<tr><td>GNU Grep</td><td>Working Well</td></tr>
<tr><td>GNU Make</td><td>Working Well</td></tr>
<tr><td>GNU Sed</td><td>Working Well</td></tr>
</tbody></table>
</div>
<h3 id="media-tools"><a class="header" href="#media-tools">Media Tools</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Working?</th></tr></thead><tbody>
<tr><td>FFMPEG</td><td>Working Well</td></tr>
</tbody></table>
</div>
<h3 id="archive-tools"><a class="header" href="#archive-tools">Archive Tools</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Working?</th></tr></thead><tbody>
<tr><td>Bzip2</td><td>Working Well</td></tr>
<tr><td>Xz</td><td>Working Well</td></tr>
<tr><td>Xxhash</td><td>Working Well</td></tr>
<tr><td>Zstd</td><td>Working Well</td></tr>
</tbody></table>
</div>
<h3 id="storage-tools"><a class="header" href="#storage-tools">Storage Tools</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Working?</th></tr></thead><tbody>
<tr><td>Ncdu</td><td>Not Tested</td></tr>
</tbody></table>
</div>
<h3 id="ç¶²è·¯å·¥å…·"><a class="header" href="#ç¶²è·¯å·¥å…·">ç¶²è·¯å·¥å…·</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Working Status</th></tr></thead><tbody>
<tr><td>OpenSSH Client</td><td>Not Tested</td></tr>
<tr><td>Curl</td><td>Working Well</td></tr>
<tr><td>GoAccess</td><td>Working Well</td></tr>
<tr><td>Rsync</td><td>Working Well</td></tr>
<tr><td>SQLite</td><td>Not Tested</td></tr>
<tr><td>Wget</td><td>Working Well</td></tr>
</tbody></table>
</div>
<h2 id="å…¶ä»–ç¨‹å¼"><a class="header" href="#å…¶ä»–ç¨‹å¼">å…¶ä»–ç¨‹å¼</a></h2>
<p>You can see all Redox components and ported programs on the <a href="https://static.redox-os.org/pkg/x86_64-unknown-redox/">build server list</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="side-projects"><a class="header" href="#side-projects">Side Projects</a></h1>
<p>Redox is a complete Rust operating system. In addition to the Redox kernel, our team is developing several side projects, including:</p>
<ul>
<li><a href="https://gitlab.redox-os.org/redox-os/redoxfs">RedoxFS</a> - å— ZFS å•Ÿç™¼çš„ Redox æª”æ¡ˆç³»çµ±ã€‚</li>
<li><a href="https://gitlab.redox-os.org/redox-os/ion">Ion</a> - Redox å¤–æ®¼ã€‚</li>
<li><a href="https://gitlab.redox-os.org/redox-os/orbital">Orbital</a> - Redox çš„æ¡Œé¢ç’°å¢ƒèˆ‡é¡¯ç¤ºä¼ºæœå™¨ã€‚</li>
<li><a href="https://gitlab.redox-os.org/redox-os/orbclient">Orbclient</a> - ä¾› Rust ç¨‹å¼ä½¿ç”¨çš„ Orbital å®¢æˆ¶ç«¯ç¨‹å¼åº«ã€‚</li>
<li><a href="https://gitlab.redox-os.org/redox-os/pkgutils">pkgutils</a> - Redox çš„è»Ÿé«”åŒ…ç®¡ç†å™¨ï¼ŒåŒ…å«å‘½ä»¤è¡Œä»‹é¢èˆ‡ç¨‹å¼åº«ã€‚</li>
<li><a href="https://gitlab.redox-os.org/redox-os/relibc">relibc</a> - Redox çš„ C èªè¨€æ¨™æº–åº«ã€‚</li>
<li><a href="https://gitlab.redox-os.org/redox-os/audiod">audiod</a> - Redox audio server.</li>
<li><a href="https://gitlab.redox-os.org/redox-os/bootloader">bootloader</a> - Redox boot loader.</li>
<li><a href="https://gitlab.redox-os.org/redox-os/base">base</a> - Redox essential system services and drivers.</li>
<li><a href="https://gitlab.redox-os.org/redox-os/installer">installer</a> - Redox buildsystem builder.</li>
<li><a href="https://gitlab.redox-os.org/redox-os/redoxer">redoxer</a> - A tool to run/test Rust programs inside of a Redox VM.</li>
<li><a href="https://gitlab.redox-os.org/redox-os/games">games</a> - A collection of mini-games for Redox (alike BSD-games).</li>
<li>and a few other exciting projects you can explore on the <a href="https://gitlab.redox-os.org/redox-os">redox-os group</a>.</li>
</ul>
<p>We also have some in-house tools, which are collections of small, useful command-line programs:</p>
<ul>
<li><a href="https://gitlab.redox-os.org/redox-os/coreutils">coreutils</a> -  Redox-specific core utilities such as <code>free</code>, <code>ps</code>, <code>shutdown</code>, and so on.</li>
<li><a href="https://gitlab.redox-os.org/redox-os/extrautils">extrautils</a> -  Redox-specific extra utilities such as <code>dmesg</code>, <code>less</code>, <code>which</code>, and so on.</li>
<li><a href="https://gitlab.redox-os.org/redox-os/binutils">binutils</a> - Utilities for working with binary files.</li>
</ul>
<p>We also actively contribute to third-party projects that are heavily used in Redox.</p>
<ul>
<li><a href="https://github.com/uutils/coreutils">uutils/coreutils</a> - Cross-platform Rust rewrite of the GNU Coreutils.</li>
<li><a href="https://github.com/m-labs/smoltcp">smoltcp</a> - The TCP/IP stack used by Redox.</li>
<li><a href="https://github.com/rust-windowing/winit">winit</a> - The window handling library for Rust programs.</li>
</ul>
<h2 id="å“ªäº›å·¥å…·é©åˆç”¨æ–¼-redox-æ•£ä½ˆç‰ˆ"><a class="header" href="#å“ªäº›å·¥å…·é©åˆç”¨æ–¼-redox-æ•£ä½ˆç‰ˆ">å“ªäº›å·¥å…·é©åˆç”¨æ–¼ Redox æ•£ä½ˆç‰ˆï¼Ÿ</a></h2>
<p>The necessary tools for a usable system, we offer variants with fewer programs.</p>
<p>The listed tools fall into three categories:</p>
<ol>
<li><strong>Critical</strong>, which are needed for a full functioning and usable system.</li>
<li><strong>Ecosystem-friendly</strong>, which are there for establishing consistency within the ecosystem.</li>
<li><strong>Fun</strong>, which are "nice" to have and are inherently simple.</li>
</ol>
<p>The first category should be obvious: an OS without certain core tools is a useless OS. The second category contains the tools which are likely to be non-default in the future, but nonetheless are in the official distribution right now, for the charm. The third category is there for convenience: namely for making sure that the Redox infrastructure is consistent and integrated.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ç³»çµ±è¨­è¨ˆ"><a class="header" href="#ç³»çµ±è¨­è¨ˆ">ç³»çµ±è¨­è¨ˆ</a></h1>
<p>This chapter will discuss the design of Redox.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="å¾®å…§æ ¸"><a class="header" href="#å¾®å…§æ ¸">å¾®å…§æ ¸</a></h1>
<p>The Redox kernel is a microkernel. Microkernels stand out in their design by providing minimal abstractions in kernel-space. Microkernels focus on user-space, unlike Monolithic kernels which focus on kernel-space.</p>
<p>The basic philosophy of microkernels is that any component which <em>can</em> run in user-space <em>should</em> run in user-space. Kernel-space should only be utilized for the most essential components (e.g., system calls, process separation, resource management, IPC, thread management, etc).</p>
<p>The kernel's main task is to act as a medium for communication and segregation of processes. The kernel should provide minimal abstraction over the hardware (that is, drivers, which can and should run in user-space).</p>
<p>Microkernels are more secure and less prone to crashes and driver bugs than monolithic kernels. This is because most kernel components are moved to user-space and use different memory address spaces, and thus can't do damage to the system. Furthermore, microkernels are extremely maintainable, due to their small code size the number of bugs in the kernel is reduced a lot.</p>
<p>As anything else, microkernels do also have disadvantages.</p>
<h2 id="advantages-of-microkernels"><a class="header" href="#advantages-of-microkernels">Advantages of microkernels</a></h2>
<p>There are quite a lot of advantages (and some disadvantages) with microkernels, a few of which will be covered here.</p>
<h3 id="better-stability"><a class="header" href="#better-stability">Better Stability</a></h3>
<p>When compared to microkernels, Monolithic kernels tend to be prone to crashes and driver bugs. A buggy driver in a Monolithic kernel can crash the whole system because the driver code is running on the same memory address space of the kernel, thus the kernel process can't continue to run (to avoid memory corruption) and crash (kernel panic). Or the bugs in a driver can spread to other drivers without causing crashes, which is hard to ensure stability and a headache to investigate the root of the problems.</p>
<p>While in a microkernel the drivers run in different memory address spaces (separation of concerns) which allows the system to handle any crash safely and isolate driver bugs.</p>
<p>In Linux we often see errors with drivers dereferencing bad pointers which ultimately results in kernel panics.</p>
<p>There is very good documentation in the <a href="http://wiki.minix3.org/doku.php?id=www:documentation:reliability">MINIX documentation</a> about how this can be addressed by a microkernel.</p>
<h3 id="better-security"><a class="header" href="#better-security">Better Security</a></h3>
<p>Microkernels are undoubtedly more secure than monolithic kernels. The minimality principle of microkernels is a direct consequence of the Principle Of Least Privilege, according to which all components should have only the privileges absolutely needed to provide the needed functionality.</p>
<p>Many security-critical bugs in monolithic kernels come from services and drivers running unrestricted in kernel mode, without any form of protection.</p>
<p>In other words: <strong>in monolithic kernels, drivers can do whatever they want, without restrictions, when running in kernel mode</strong>.</p>
<h3 id="better-modularity-and-configuration"><a class="header" href="#better-modularity-and-configuration">Better Modularity and Configuration</a></h3>
<p>Monolithic kernels are, well, monolithic. They do not allow fine-grained control like microkernels. This is due to many essential components being "hard-coded" into the kernel, and thus requiring modifications to the kernel itself (e.g., device drivers).</p>
<p>å¾®å…§æ ¸åœ¨æœ¬è³ªä¸Šå…·æœ‰æ¥µé«˜çš„æ¨¡çµ„åŒ–ç‰¹æ€§ã€‚æ‚¨å¯ä»¥åœ¨ç³»çµ±åŸ·è¡Œæ™‚ï¼Œåœ¨å®Œå…¨ä¸æ›´å‹•å…§æ ¸çš„æƒ…æ³ä¸‹ï¼Œå¢æ·»ã€å–ä»£ã€é‡æ–°è¼‰å…¥ã€ä¿®æ”¹ã€è®Šæ›´æˆ–ç§»é™¤ç³»çµ±çµ„ä»¶èˆ‡é©…å‹•ç¨‹å¼ã€‚</p>
<p>Modern monolithic kernels try to solve this issue using kernel modules but still often require the system to reboot.</p>
<h3 id="better-expansion"><a class="header" href="#better-expansion">Better Expansion</a></h3>
<p>In microkernels new system components and drivers can be easily added using daemons, while in monolithic kernels the entire kernel needs to be updated to add them which can introduce bugs to other system components or drivers.</p>
<h3 id="sane-debugging"><a class="header" href="#sane-debugging">Sane Debugging</a></h3>
<p>In microkernels most kernel components (drivers, filesystems, etc) are moved to user-space, thus bugs on them can't crash the kernel (kernel panic).</p>
<p>The "component panics" (where "component" is the name of the system component) are more common in microkernels than kernel panics because the kernel code size is very small, the log of a component panic can be saved which ease debugging a lot.</p>
<p>This is very important to debug in real hardware, because if a kernel panic happens the log can't be saved to find the cause of the bug.</p>
<p>While in monolithic kernels a bug in a system component or driver can cause a kernel panic and freeze the system (if it happens in real hardware, you can't debug without serial output support)</p>
<p>(Buggy drivers are the main cause of kernel panics)</p>
<h2 id="disadvantages-of-microkernels"><a class="header" href="#disadvantages-of-microkernels">Disadvantages of microkernels</a></h2>
<h3 id="small-performance-overhead"><a class="header" href="#small-performance-overhead">Small Performance Overhead</a></h3>
<p>Any modern operating system needs basic security mechanisms such as memory isolation and virtualization. Furthermore any process (including the kernel) has its own stack and variables stored in registers. On <a href="https://en.wikipedia.org/wiki/Context_switch">context switch</a>, that is each time a system call is invoked or any other inter-process communication (IPC) is done, some tasks have to be done, including:</p>
<ul>
<li>Saving caller registers, especially the program counter (caller: process invoking syscall or IPC)</li>
<li>Reprogramming the <a href="https://en.wikipedia.org/wiki/Memory_management_unit">MMU</a>'s page table (aka <a href="https://en.wikipedia.org/wiki/Translation_lookaside_buffer">TLB</a>)</li>
<li>Putting CPU in another mode (kernel mode and user mode, also known as ring 0 and ring 3)</li>
<li>Restoring callee registers (callee: process invoked by syscall or IPC)</li>
</ul>
<p>These are not inherently slower on microkernels, but microkernels need to perform these operations more frequently. Many of the system functionality is performed by user-space processes, requiring additional context switches.</p>
<p>The performance difference between monolithic and microkernels has been marginalized over time, making their performance comparable. This is partly due to a smaller surface area which can be easier to optimize.</p>
<ul>
<li><a href="https://wiki.osdev.org/Context_Switching">Context Switch Documentation</a></li>
<li><a href="https://os.inf.tu-dresden.de/pubs/sosp97/">Microkernels Performance Paper</a></li>
</ul>
<p>We are working on exciting performance optimizations to minimize the overhead of extra context switches.</p>
<h2 id="versus-monolithic-kernels"><a class="header" href="#versus-monolithic-kernels">Versus monolithic kernels</a></h2>
<p>Monolithic kernels provide a lot more abstractions than microkernels.</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/6/67/OS-structure.svg" alt="An illustration" /></p>
<p>The above illustration from <a href="https://commons.wikimedia.org/wiki/File:OS-structure.svg">Wikimedia</a>, by Wooptoo, License: Public domain) shows how they differ.</p>
<h2 id="documentation-about-the-kerneluser-space-separation"><a class="header" href="#documentation-about-the-kerneluser-space-separation">Documentation about the kernel/user-space separation</a></h2>
<ul>
<li><a href="https://www.geeksforgeeks.org/dual-mode-operations-os/">Dual Mode Operations in OS</a></li>
<li><a href="https://www.geeksforgeeks.org/user-mode-and-kernel-mode-switching/">User Mode and Kernel Mode Switching</a></li>
</ul>
<h2 id="documentation-about-microkernels"><a class="header" href="#documentation-about-microkernels">Documentation about microkernels</a></h2>
<ul>
<li><a href="https://wiki.osdev.org/Microkernel">OSDev Technical Wiki</a></li>
<li><a href="https://wiki.osdev.org/Message_Passing">Message Passing Documentation</a></li>
<li><a href="https://wiki.minix3.org/doku.php?id=www:documentation:start">Minix Documentation</a></li>
<li><a href="https://wiki.minix3.org/doku.php?id=www:documentation:features">Minix Features</a></li>
<li><a href="https://wiki.minix3.org/doku.php?id=www:documentation:reliability">Minix Reliability</a></li>
<li><a href="https://www.gnu.org/software/hurd/hurd/documentation.html">GNU Hurd Documentation</a></li>
<li><a href="https://fuchsia.dev/fuchsia-src/get-started/learn/intro">Fuchsia Documentation</a></li>
<li><a href="http://www.helenos.org/wiki/FAQ">HelenOS FAQ</a></li>
<li><a href="http://www.minix3.org/docs/jorrit-herder/osr-jul06.pdf">Minix Paper</a></li>
<li><a href="https://sel4.systems/About/seL4-whitepaper.pdf">seL4 Whitepaper</a></li>
<li><a href="https://en.wikipedia.org/wiki/Tanenbaum%E2%80%93Torvalds_debate">Tanenbaum-Torvalds Debate</a></li>
</ul>
<h2 id="a-note-on-the-current-state"><a class="header" href="#a-note-on-the-current-state">A Note On The Current State</a></h2>
<p>Redox has less than 40,000 Rust lines of kernel code. For comparison Minix has around 6,000 C lines of kernel code.</p>
<p>(The above comparison can't be used to argue that Minix is more stable or safe than Redox due to a less amount of source code lines, because Redox is more advanced than Minix in features, thus more lines of code are expected and a 1:1 comparison can't be made)</p>
<p>We would like to move more parts of Redox to user-space to get an even more stable and secure kernel.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="boot-process"><a class="header" href="#boot-process">Boot Process</a></h1>
<h2 id="boot-loader"><a class="header" href="#boot-loader">Boot Loader</a></h2>
<p>The boot loader source can be found in <code>cookbook/recipes/bootloader/source</code> after a successful build or in the <a href="https://gitlab.redox-os.org/redox-os/bootloader">Boot Loader</a> repository.</p>
<h3 id="bios-boot"><a class="header" href="#bios-boot">BIOS Boot</a></h3>
<p>BIOS Boot is a boot process that dates back to the <a href="https://dosdays.co.uk/topics/pc_bios.php">IBM PC</a>. Because of its lengthy history, BIOS starts up in 16-bit mode (Real Mode), and the boot loader needs to load in multiple stages to move into higher bit environments. The firmware will execute the boot sector located in the first sector of the main storage device, which is known as the stage 1 bootloader (<a href="https://wiki.osdev.org/Boot_Sequence#Master_Boot_Record">OSDev Wiki</a>).</p>
<p>The stage 1 bootloader is written in Assembly and can be found in <code>asm/x86-unknown-none/stage1.asm</code>. The stage 1 main task is to allow reading of the whole disk to load stage 2 in another sector of the storage device. The stage 2 bootloader is also written in Assembly. The main task is transferring <a href="https://wiki.osdev.org/BIOS#BIOS_functions">BIOS functions</a> from real mode to protected mode (32-bit), then switches to protected mode or long mode (64-bit) and finally loads the Rust-written boot loader, called stage 3.</p>
<p>These three boot loader stages are combined in one executable written to the first megabyte of the storage device. The first code that is executed in Rust-written code is <code>pub extern "C" fn start()</code> in <code>src/os/bios/mod.rs</code>. At this point, the bootloader follows the same common boot process on all boot methods, which can be seen in a later section.</p>
<h3 id="uefi-boot"><a class="header" href="#uefi-boot">UEFI Boot</a></h3>
<p>Redox supports UEFI booting on x86-64, ARM64, and RISC-V 64-bit machines. UEFI starts up in 64-bit mode; thus, the boot process doesn't need multiple stages. The firmware will find the EFI System Partition (ESP) on the storage device, then load and execute PE32+ UEFI programs typically located at <code>/EFI/BOOT/BOOTX64.efi</code> (<a href="https://wiki.osdev.org/UEFI#Bootable_UEFI_applications">OSDev Wiki</a>).</p>
<p>In the case of our bootloader, the first code that is executed is <code>pub extern "C" fn main()</code> in <code>src/os/uefi/mod.rs</code>. At this point, the bootloader follows the same common boot process on all boot methods, which can be seen in a later section.</p>
<h3 id="common-boot-process"><a class="header" href="#common-boot-process">Common boot process</a></h3>
<p>The bootloader initializes the memory map and the display mode, both of which rely on firmware mechanisms that are not accessible after control is switched to the kernel. The bootloader then finds the RedoxFS boot partition on the disk and loads <code>/boot/kernel</code> and <code>/boot/initfs</code> files into memory.</p>
<p>For a live disk, it does load the whole partition into memory. It then loads <code>/boot/kernel</code> and <code>/boot/initfs</code> also at a different location in memory.</p>
<p>After the kernel and initfs have been loaded, it sets up a virtual paging for kernel and environment variables, including the location of the RedoxFS boot partition to be passed into it. Then, it maps the kernel to its expected virtual address and jumps to its entry function.</p>
<h2 id="kernel"><a class="header" href="#kernel">Kernel</a></h2>
<p>The Redox kernel is a single ELF program in <code>/boot/kernel</code>. This kernel performs (fairly significant) architecture-specific initialization in the <code>kstart</code> function before jumping to the <code>kmain</code> function. At this point, the user-space bootstrap, a specially prepared executable that limits the required kernel parsing, sets up the <code>/scheme/initfs</code> scheme, and loads and executes the <code>init</code> program.</p>
<p>The kernel creates three different namespaces during the bootstrap process. Each namespace has its schemes that can be accessed by userspace programs, depending on where it is loaded:</p>
<ol>
<li>
<p>the <code>null</code> (0) namespace, a namespace that drivers are running on:</p>
<ul>
<li><code>/scheme/memory</code></li>
<li><code>/scheme/pipe</code></li>
</ul>
</li>
<li>
<p>the <code>root</code> (1) namespace, the initial namespace set up during boot:</p>
<ul>
<li><code>/scheme/kernel.acpi</code></li>
<li><code>/scheme/kernel.dtb</code></li>
<li><code>/scheme/kernel.proc</code></li>
<li><code>/scheme/debug</code></li>
<li><code>/scheme/irq</code></li>
<li><code>/scheme/serio</code></li>
</ul>
</li>
<li>
<p>Additional namespaces requested by user, also loaded for <code>root</code> namespace:</p>
<ul>
<li><code>/scheme/event</code></li>
<li><code>/scheme/memory</code></li>
<li><code>/scheme/pipe</code></li>
<li><code>/scheme/sys</code></li>
<li><code>/scheme/time</code></li>
</ul>
</li>
</ol>
<h2 id="init"><a class="header" href="#init">Init</a></h2>
<p>Redox has a multi-staged init process, designed to allow for the loading of storage drivers in a modular and configurable fashion. This is commonly referred to as an init RAMdisk (initfs). The RAMdisk is contained in <code>/boot/initfs</code>, which is a special file format containing the bootstrap code in ELF format and packed files which was loaded into <code>/scheme/initfs</code> by the kernel program.</p>
<h3 id="ramdisk-init"><a class="header" href="#ramdisk-init">RAMdisk Init</a></h3>
<p>The ramdisk init has the job of loading the drivers and daemons required to access the root filesystem and then transferring control to the filesystem init. The load order is defined in <code>/etc/init.rc</code> in initfs:</p>
<ol>
<li>Daemons required for <code>relibc</code>
<ul>
<li><code>rtcd</code> loads machine-specific RTC into <code>/scheme/time</code></li>
<li><code>nulld</code> null handler, creates <code>/scheme/null</code></li>
<li><code>zero</code> zero handler, creates <code>/scheme/zero</code></li>
<li><code>randd</code> rand handler, creates <code>/scheme/rand</code></li>
</ul>
</li>
<li>Logging
<ul>
<li><code>logd</code> system log handler, creates <code>/scheme/log</code></li>
<li><code>ramfs</code> loads in-memory FS handling into <code>/scheme/memory</code></li>
</ul>
</li>
<li>Graphics buffers
<ul>
<li><code>inputd</code> virtual terminal (VT) handler, creates <code>/scheme/input</code></li>
<li><code>vesad</code> VESA interface handler, creates <code>/scheme/display.vesa</code></li>
<li><code>fbbootlogd</code> forwards log from logd to VT</li>
<li><code>fbcond</code> handles keyboard interaction to VT</li>
</ul>
</li>
<li>Live daemon
<ul>
<li><code>lived</code> livedisk handler, creates <code>/scheme/disk.live</code></li>
</ul>
</li>
<li>Drivers in <code>/etc/init_drivers.rc</code>
<ul>
<li><code>ps2d</code> loads PS/2 handling into <code>/scheme/serio</code></li>
<li><code>acpid</code> loads ACPI handling into <code>/scheme/kernel.acpi</code></li>
<li><code>pcid</code> PCI handler, creates <code>/scheme/pci</code></li>
<li><code>pcid-spawner</code> spawns drivers depending on available hardware
<ul>
<li><code>ahcid</code> AHCI storage driver</li>
<li><code>ided</code> IDE storage driver</li>
<li><code>nvmed</code> NVME storage driver</li>
<li><code>virtio-blkd</code> VirtIO BLK storage driver</li>
<li><code>virtio-gpud</code> VirtIO GPU driver</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>After loading all drivers and daemons above, the <code>redoxfs</code> driver is executed with <code>--uuid $REDOXFS_UUID</code> where <code>$REDOXFS_UUID</code> is the partition chosen by the bootloader and creates <code>/scheme/file</code>. The command <code>set-default-scheme file</code> is then executed, so that the default path handler is set to <code>/scheme/file</code>.</p>
<h3 id="filesystem-init"><a class="header" href="#filesystem-init">Filesystem Init</a></h3>
<p>The filesystem init continues the loading of drivers for all other functionality. This includes audio, networking, and anything not required for storage device access. The drivers' init configuration is mainly found in <code>/usr/lib/init.d</code> and <code>/etc/pcid.d</code>. In the redox builder repository, it's configurable in the <a href="https://gitlab.redox-os.org/redox-os/redox/-/tree/master/config/base.toml">config directory</a>. After this, the login prompt is shown.</p>
<p>If Orbital is enabled, the display server is launched.</p>
<h2 id="login"><a class="header" href="#login">Login</a></h2>
<p>After the init processes have set up drivers and daemons, the user can log in to the system. The login program accepts a username, with a default user called <code>user</code>, prints the <code>/etc/motd</code> file, and then executes the user's login shell, usually <code>ion</code>. At this point, the user will now be able to access the <a href="./shell.html">shell</a></p>
<h2 id="graphical-overview"><a class="header" href="#graphical-overview">Graphical overview</a></h2>
<p>Here is an overview of the initialization process with scheme creation and usage. For simplicity's sake, we do not depict all scheme interaction but at least the major ones. <strong>this is currently out of date, but still informative</strong></p>
<p><img src="./assets/init.svg" alt="Redox initialization graph" title="Redox initialization graph" /></p>
<h2 id="boot-process-documentation"><a class="header" href="#boot-process-documentation">Boot process documentation</a></h2>
<ul>
<li><a href="https://wiki.osdev.org/Boot_Sequence">Boot process documentation</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="redox-å…§æ ¸"><a class="header" href="#redox-å…§æ ¸">Redox å…§æ ¸</a></h1>
<p>System calls are generally simple, and have a similar ABI compared to regular function calls. On x86-64, it simply uses the <code>syscall</code> instruction, causing a mode switch from user-mode (ring 3) to kernel-mode (ring 0), and when the system call handler is finished, its mode switches back, as if the <code>syscall</code> instruction was a regular <code>call</code> instruction, using <code>sysretq</code>.</p>
<ul>
<li><a href="https://docs.rs/redox_syscall/latest/syscall/">System calls documentation</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ä½¿ç”¨è€…ç©ºé–“çš„ç³»çµ±æœå‹™"><a class="header" href="#ä½¿ç”¨è€…ç©ºé–“çš„ç³»çµ±æœå‹™">ä½¿ç”¨è€…ç©ºé–“çš„ç³»çµ±æœå‹™</a></h1>
<p>å¦‚åŒä»»ä½•åŸºæ–¼å¾®å…§æ ¸çš„ä½œæ¥­ç³»çµ±ï¼Œå¤§å¤šæ•¸çš„å…§æ ¸çµ„ä»¶éƒ½å·²ç§»è‡³ä½¿ç”¨è€…ç©ºé–“ï¼Œä¸¦ç¶“éèª¿æ•´ä»¥åœ¨å…¶ä¸­é‹ä½œã€‚</p>
<p>ä¸€èˆ¬è€Œè¨€ï¼Œæ•´é«”å…§æ ¸ï¼ˆMonolithic kernelï¼‰ç”±æ–¼å…§æ ¸çµ„ä»¶æ•¸é‡é¾å¤§ï¼Œæ“æœ‰æ•¸ç™¾å€‹ç³»çµ±å‘¼å«ï¼ˆsystem callsï¼Œå³é€™äº›çµ„ä»¶çš„ä»‹é¢ï¼‰ï¼Œæ›´ä¸ç”¨èªªé€é ioctl ä»¥åŠä¾‹å¦‚ procfs/sysfs æ‰€æä¾›çš„å­ç³»çµ±å‘¼å«æ•¸é‡ã€‚ç›¸è¼ƒä¹‹ä¸‹ï¼Œå¾®å…§æ ¸å‰‡åƒ…æœ‰æ•¸åå€‹ç³»çµ±å‘¼å«ã€‚</p>
<p>é€™æ˜¯å› ç‚ºéæ ¸å¿ƒçš„å…§æ ¸çµ„ä»¶è¢«ç§»è‡³ä½¿ç”¨è€…ç©ºé–“ï¼Œé€²è€Œæ”¹ç‚ºä¾è³´ IPCï¼Œæˆ‘å€‘ç¨å¾Œæœƒå°æ­¤é€²è¡Œè§£é‡‹ã€‚</p>
<p>User-space <code>bootstrap</code> is the first program launched by the kernel, and has a simple design. The kernel loads the <code>initfs</code> blob, containing both the bootstrap executable itself and the <code>initfs</code> image, that was passed from the boot loader. It creates an address space containing it, and jumps to a bootloader-provided offset. Bootstrap allocates a stack (in an Assembly stub), <code>mprotect</code>s itself, and does the remaining steps to exec the <code>init</code> daemon. It also sets up the <code>initfs</code> scheme daemon.</p>
<p>The system calls used for IPC, are almost exclusively file-based. The kernel therefore has to know what schemes to forward certain system calls to. All file syscalls are marked with either <code>SYS_CLASS_PATH</code> or <code>SYS_CLASS_FILE</code>. The kernel associates paths with schemes by checking their scheme prefix against the scheme's name, in the former case, and in the latter case, the kernel simply remembers which scheme opened file descriptors originated from. Most IPC in general is done using schemes, with the exception of regular pipes like Linux has, which uses <code>pipe2</code>, <code>read</code>, <code>write</code>, <code>close</code>. Any scheme can also of course setup its own custom pipe-like IPC that also uses the aforementioned syscalls, like <code>shm</code> and <code>chan</code> from <code>ipcd</code>.</p>
<p>Schemes are implemented as a regular Rust trait in the kernel. Some builtin kernel schemes exist, which just implement that trait. Userspace schemes are provided via the <code>UserScheme</code> trait implementor, which relies on messages being sent between the kernel and the scheme daemon. This channel is created by scheme daemons when opening <code>:SCHEME_NAME</code>, which is parsed to the root scheme <code>""</code> with path <code>"SCHEME_NAME"</code>. Messages are sent by reading from and writing to that root scheme file descriptor.</p>
<p>So all file-based syscalls on files owned by user-space, will send a message to that scheme daemon, and when the result is sent back, the kernel will return that result back to the process doing the syscall.</p>
<p>Communication between user-space and the kernel, is generally fast, even though the current syscall handler implementation is somewhat unoptimized. Systems with Meltdown mitigations would be an exception, although such mitigations are not yet implemented.</p>
<ul>
<li><a href="https://gitlab.redox-os.org/redox-os/redox/-/issues/1412">å†…æ ¸èˆ‡ä½¿ç”¨è€…ç©ºé–“åˆ†é›¢æ–¹é‡</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="communication"><a class="header" href="#communication">Communication</a></h1>
<p>This page explains how a program communicates with the system components.</p>
<h2 id="context"><a class="header" href="#context">Context</a></h2>
<ul>
<li>A scheme is a system service</li>
<li>SQE means "Submission Queue Entry"</li>
<li>CQE means "Completion Queue Entry"</li>
<li>POSIX and Linux functions are implemented by relibc using Redox services provided by schemes, they work with the appropriate schemes to implement the function. It might involve opening a scheme, maybe writing to a scheme, or maybe calling <code>mmap</code> on the scheme after opening (this is pretty common).</li>
<li>relibc and redox-rt talk to the scheme via a system call - open, read, write, mmap, etc.</li>
<li>A system component (userspace daemon) uses the Scheme API (from the <code>redox-scheme</code> library) to implement the system service. The Scheme API also is doing system calls like <code>open</code>, <code>read</code> and <code>write</code>, but the message format for reading and writing is a special format. The latest version of the Scheme API reads SQE messages and writes CQE messages. SQE is basically the parameters to the system call that the caller originally did, packaged into a message. CQE is the response that the daemon sends back.</li>
<li>The kernel is responsible for creating the SQE messages, and for unpacking the CQE messages.</li>
</ul>
<h2 id="ç¯„ä¾‹"><a class="header" href="#ç¯„ä¾‹">ç¯„ä¾‹</a></h2>
<ul>
<li>The program calls some POSIX or Linux function from relibc</li>
<li>relibc/redox-rt convert it to system calls</li>
<li>The kernel converts the system calls to SQE</li>
<li>The userspace daemon calls read on a "scheme socket" and gets an SQE message</li>
<li>The userspace daemon calls write on the scheme socket and sends a CQE message</li>
<li>The kernel converts the CQE message to the result of the system call</li>
<li>relibc/redox-rt gets the result from the system call and uses that to calculate the result of the POSIX or Linux function call</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="è¨˜æ†¶é«”ç®¡ç†"><a class="header" href="#è¨˜æ†¶é«”ç®¡ç†">è¨˜æ†¶é«”ç®¡ç†</a></h1>
<p>TODO.</p>
<ul>
<li><a href="https://wiki.osdev.org/Memory_management">Memory management documentation</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scheduling-on-redox"><a class="header" href="#scheduling-on-redox">Scheduling on Redox</a></h1>
<p>The Redox kernel uses a scheduling algorithm called <a href="https://wiki.osdev.org/Scheduling_Algorithms#Round_Robin">Round Robin</a>.</p>
<p>The kernel registers a function called an <a href="https://wiki.osdev.org/Interrupts">interrupt handler</a> that the CPU calls periodically. This function keeps track of how many times it is called, and will schedule the next process ready for scheduling every 10 "ticks".</p>
<ul>
<li><a href="https://wiki.osdev.org/Scheduling_Algorithms">Scheduling documentation</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="drivers"><a class="header" href="#drivers">Drivers</a></h1>
<p>On Redox the device drivers are user-space daemons, being a common Unix process they have their own namespace with restricted schemes.</p>
<p>In other words, a driver on Redox can't damage other system interfaces, while on Monolithic kernels a driver could wipe your data because the driver run on the same memory address space of the filesystem (thus same privilege level).</p>
<p>You can find the driver documentation on the repository README and drivers code.</p>
<ul>
<li><a href="https://gitlab.redox-os.org/redox-os/base/-/tree/main/drivers">Drivers repository</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="redoxfs"><a class="header" href="#redoxfs">RedoxFS</a></h1>
<p>é€™æ˜¯ Redox OS çš„é è¨­æª”æ¡ˆç³»çµ±ï¼Œéˆæ„Ÿæºè‡ª ZFSï¼Œä¸¦é‡å°å¾®å…§æ ¸æ¶æ§‹é€²è¡Œäº†èª¿æ•´ã€‚</p>
<p>Redox had a read-only ZFS driver but it was abandoned because of the monolithic nature of ZFS that created problems with the Redox microkernel design.</p>
<p>(It's a replacement for <a href="https://gitlab.redox-os.org/redox-os/tfs">TFS</a>)</p>
<p>Current features:</p>
<ul>
<li>Compatible with Redox and Linux (FUSE)</li>
<li>å¯«å…¥æ™‚è¤‡è£½</li>
<li>Data/metadata checksums</li>
<li>Transparent encryption</li>
<li>Standard Unix file attributes</li>
<li>File/directory size limit up to 193TiB (212TB)</li>
<li>File/directory quantity limit up to 4 billion per 193TiB (2^32 - 1 = 4294967295)</li>
<li>Disk encryption fully supported by the Redox bootloader, letting it load the kernel off an encrypted partition.</li>
<li>MIT licensed</li>
</ul>
<p>Being MIT licensed, RedoxFS can be bundled on GPL-licensed operating systems (Linux, for example).</p>
<h2 id="å·¥å…·"><a class="header" href="#å·¥å…·">å·¥å…·</a></h2>
<p>RedoxFS tooling can be used to create, mount and edit contents of an <code>.img</code> file containing RedoxFS. It can be installed with:</p>
<pre><code class="language-sh">cargo install redoxfs
</code></pre>
<p>If you found errors while installing it make sure to install the <code>libfuse</code> 3.x package for your Unix-like distribution.</p>
<h3 id="å»ºç«‹ç£ç¢Ÿ"><a class="header" href="#å»ºç«‹ç£ç¢Ÿ">å»ºç«‹ç£ç¢Ÿ</a></h3>
<p>You can create an empty, non-bootable RedoxFS by allocating an empty file with <code>fallocate</code> then run <code>redoxfs-mkfs</code> to initialize the whole image as <code>RedoxFS</code>.</p>
<pre><code class="language-sh">fallocate -l 1G redox.img
</code></pre>
<pre><code class="language-sh">redoxfs-mkfs redox.img
</code></pre>
<p>To create an encrypted disk use the <code>--encrypt</code> option, it will ask the password through a masked prompt:</p>
<pre><code class="language-sh">redoxfs-mkfs --encrypt redox.img
</code></pre>
<p>To create a disk with contents from an existing directory use <code>redoxfs-ar</code> (currently the <code>redoxfs-ar</code> tool overwrites existing content and have no  <code>--encrypt</code> option).</p>
<pre><code class="language-sh">redoxfs-ar redox.img ./sysroot
</code></pre>
<h3 id="create-a-bootable-disk"><a class="header" href="#create-a-bootable-disk">Create a bootable disk</a></h3>
<p>The second option of <code>redoxfs-mkfs</code> and third option of <code>redoxfs-ar</code> tools accepts a file that contains a raw image to be written as reserved disk space. This is meant to be a bootloader. Redox is booted using <a href="https://gitlab.redox-os.org/redox-os/bootloader">the official bootloader</a>.</p>
<p>First you need to download the bootloader repository and build it, the following commands will build a BIOS bootloader:</p>
<pre><code class="language-sh">git clone https://gitlab.redox-os.org/redox-os/bootloader
</code></pre>
<pre><code class="language-sh">make -C bootloader TARGET=x86-unknown-none BUILD=build all
</code></pre>
<p>Once the bootloader is available at <code>bootloader/build/bootloader.bin</code> after compilation, you can create a new bootable disk using either <code>redoxfs-mkfs</code> or <code>redoxfs-ar</code>:</p>
<pre><code class="language-sh">redoxfs-mkfs redox.img bootloader/build/bootloader.bin
</code></pre>
<pre><code class="language-sh">redoxfs-ar redox.img ./sysroot bootloader/build/bootloader.bin
</code></pre>
<p>You can also convert a non-bootable disk into bootable using <code>redoxfs-clone</code>:</p>
<pre><code class="language-sh">redoxfs-clone redox.img redox-bootable.img bootloader/build/bootloader.bin
</code></pre>
<p>It's not possible to create a bootable UEFI using this option because it creates a GPT-partitioned disk, which currently is only implemented in <a href="https://gitlab.redox-os.org/redox-os/installer/">redox-installer</a>. A dual boot option in the same disk is also impossible if booting from a BIOS firmware.</p>
<p>Note that you need to have <code>boot/kernel</code> and <code>boot/initfs</code> in the image to make it actually bootable. You can build those from the <a href="./podman-build.html">main build system</a> or the <a href="https://gitlab.redox-os.org/redox-os/kernel">kernel</a> and <a href="https://gitlab.redox-os.org/redox-os/base">base</a> repositories.</p>
<h3 id="æ›è¼‰ç£ç¢Ÿ"><a class="header" href="#æ›è¼‰ç£ç¢Ÿ">æ›è¼‰ç£ç¢Ÿ</a></h3>
<p>To mount the disk run the <code>redoxfs [image] [directory]</code> command, for example:</p>
<pre><code class="language-sh">mkdir ./redox-img
</code></pre>
<pre><code class="language-sh">redoxfs redox.img ./redox-img
</code></pre>
<p>It will mount the disk using FUSE underneath.</p>
<p>The difference is that <code>redoxfs-ar</code> overwrites existing disk content. Mounting a disk through FUSE is the only way to update existing content in the RedoxFS-formatted image.</p>
<h3 id="è§£é™¤æ›è¼‰ç£ç¢Ÿ"><a class="header" href="#è§£é™¤æ›è¼‰ç£ç¢Ÿ">è§£é™¤æ›è¼‰ç£ç¢Ÿ</a></h3>
<p>Unmount the disk using FUSE unmounting tool:</p>
<pre><code class="language-sh">fusermount3 ./redox-img
</code></pre>
<h3 id="æ“´å……ç£ç¢Ÿ"><a class="header" href="#æ“´å……ç£ç¢Ÿ">æ“´å……ç£ç¢Ÿ</a></h3>
<blockquote>
<p>âš ï¸ <strong>Warning:</strong> Experimental, please backup before</p>
</blockquote>
<p>To extend an existing disk, you need to extend the file before:</p>
<pre><code class="language-sh">truncate -s 2GB redox.img
</code></pre>
<p>Then you can run the <code>redoxfs-resize [disk] [size]</code> command. The <code>[size]</code> option can be <code>max</code> (the default), <code>min</code>, or a fixed size defined in the <a href="https://crates.io/crates/parse-size">parse-size</a> library.</p>
<pre><code class="language-sh">redoxfs-resize ./redox.img
</code></pre>
<pre><code>minimum size: 438.75 MB (418.42 MiB)
maximum size: 2.00 GB (1.86 GiB)
new size: 2.00 GB (1.86 GiB)
growing by 1559135232
redoxfs-resize: resized filesystem on redox.img
	uuid: febb081e-06ff-4786-a878-f1bb031cdf97
	size: 2.00 GB (1.86 GiB)
	used: 438.65 MB (418.33 MiB)
	free: 1.56 GB (1.45 GiB)
</code></pre>
<h3 id="shrink-the-disk"><a class="header" href="#shrink-the-disk">Shrink the disk</a></h3>
<blockquote>
<p>âš ï¸ <strong>Warning:</strong> Experimental, please backup before</p>
</blockquote>
<p>To shrink an existing disk you can use the <code>redoxfs-resize</code> tool:</p>
<pre><code class="language-sh">redoxfs-resize ./redox.img min
</code></pre>
<pre><code>minimum size: 438.77 MB (418.44 MiB)
maximum size: 2.00 GB (1.86 GiB)
new size: 438.77 MB (418.44 MiB)
shrinking by 1559135232
redoxfs-resize: resized filesystem on redox.img
	uuid: febb081e-06ff-4786-a878-f1bb031cdf97
	size: 438.77 MB (418.44 MiB)
	used: 438.64 MB (418.32 MiB)
	free: 122.88 kB (120 KiB)
</code></pre>
<p>You can use the value from "shrinking by ..." to accurately tell how much bytes can be shrinked:</p>
<pre><code class="language-sh">truncate -s -1559135232 redox.img
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="graphics-and-windowing"><a class="header" href="#graphics-and-windowing">Graphics and Windowing</a></h1>
<h2 id="drivers-1"><a class="header" href="#drivers-1">Drivers</a></h2>
<h3 id="vesa-vesad"><a class="header" href="#vesa-vesad">VESA (vesad)</a></h3>
<p>vesad is not really a driver, it writes to a framebuffer given by firmware (via UEFI or BIOS software interrupts).</p>
<p>Because we don't have GPU drivers yet, we rely on what firmware gives to us.</p>
<h3 id="gpus"><a class="header" href="#gpus">GPUs</a></h3>
<p>On Linux/BSDs, the GPU communication with the kernel is done by the DRM system (Direct Rendering Manager, <code>libdrm</code> library), that Mesa3D drivers use to work (Mesa3D implement OpenGL/Vulkan drivers, DRM expose the hardware interfaces).</p>
<p>Said this, in Redox a "DRM driver" needs to be an user-space driver which use the system calls/schemes to communicate with the hardware.</p>
<p>The last step is to implement the Redox backend in our Mesa3D <a href="https://gitlab.redox-os.org/redox-os/mesa">fork</a>/<a href="https://gitlab.redox-os.org/redox-os/cookbook/-/blob/master/recipes/mesa/recipe.toml">recipe</a> to use these user-space drivers.</p>
<h2 id="è»Ÿé«”ç®—ç¹ª"><a class="header" href="#è»Ÿé«”ç®—ç¹ª">è»Ÿé«”ç®—ç¹ª</a></h2>
<p>We don't have GPU drivers yet but <a href="https://docs.mesa3d.org/drivers/llvmpipe.html">LLVMpipe</a> (OpenGL CPU emulation) is working.</p>
<h2 id="orbital"><a class="header" href="#orbital">Orbital</a></h2>
<p>The Orbital desktop environment provides a display server, window manager and compositor.</p>
<h3 id="èˆ‡-x11wayland-çš„æ¯”è¼ƒ"><a class="header" href="#èˆ‡-x11wayland-çš„æ¯”è¼ƒ">èˆ‡ X11/Wayland çš„æ¯”è¼ƒ</a></h3>
<p>This display server is more simple than X11 and Wayland making the porting task more quick and easy, it's not advanced like X11 and Wayland yet but enough to port most Linux/BSD programs.</p>
<p>Compared to Wayland, Orbital has one server implementation, while Wayland provide protocols for compositors.</p>
<h3 id="features"><a class="header" href="#features">Features</a></h3>
<ul>
<li>Custom Resolutions</li>
<li>App Launcher (bottom bar)</li>
<li>æª”æ¡ˆç¸½ç®¡</li>
<li>æ–‡å­—ç·¨è¼¯å™¨</li>
<li>Calculator</li>
<li>Terminal Emulator</li>
</ul>
<p>If you hold the <strong>Super</strong> key (generally the key with a Windows logo) it will show all keyboard shortcuts in a pop-up.</p>
<h3 id="ç¨‹å¼åº«"><a class="header" href="#ç¨‹å¼åº«">ç¨‹å¼åº«</a></h3>
<p>The programs using these libraries can work on Orbital.</p>
<ul>
<li>winit</li>
<li>softbuffer</li>
<li>Slintï¼ˆé€é winit èˆ‡ softbufferï¼‰</li>
<li>Icedï¼ˆé€é winit èˆ‡ softbufferï¼‰</li>
<li>egui (winit or SDL2 can be used)</li>
<li>SDL1.2</li>
<li>SDL2</li>
<li>Mesa3D's OSMesa</li>
</ul>
<h3 id="security"><a class="header" href="#security">Security</a></h3>
<p>In Orbital a GUI program cannot read input events or the content (framebuffer) from windows of other GUI programs, like Wayland.</p>
<h3 id="clients"><a class="header" href="#clients">Clients</a></h3>
<p>Apps (or 'clients') create a window and draw to it by using the <a href="https://gitlab.redox-os.org/redox-os/orbclient">orbclient</a> client.</p>
<h4 id="client-examples"><a class="header" href="#client-examples">Client Examples</a></h4>
<p>If you wish to see examples of client apps that use <a href="https://gitlab.redox-os.org/redox-os/orbclient">orbclient</a> to "talk" to Orbital and create windows and draw to them, then you can find some in <a href="https://gitlab.redox-os.org/redox-os/orbclient/-/tree/master/examples">orbclient/examples</a> folder.</p>
<h3 id="porting"><a class="header" href="#porting">Porting</a></h3>
<p>If you want to port a program to Orbital, see below:</p>
<ul>
<li>
<p>If the program is written in Rust probably it works on Orbital because the <code>winit</code> crate is used in most places, but there are programs that access X11 or Wayland directly. You need to port these programs to <code>winit</code> and merge on upstream.</p>
</li>
<li>
<p>If the program is written in C or C++ and access X11 or Wayland directly, it must be ported to the <a href="https://gitlab.redox-os.org/redox-os/liborbital">Orbital library</a>.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="security-1"><a class="header" href="#security-1">Security</a></h1>
<p>This page covers the current Redox security design.</p>
<ul>
<li>The namespaces and <a href="https://en.wikipedia.org/wiki/Capability-based_security">capability-based</a> system are implemented by the kernel but some parts can be moved to user-space.</li>
<li>A namespace is a list of schemes, if you run <code>ls :</code>, it will show the schemes on the current namespace.</li>
<li>Each process has a namespace.</li>
<li><a href="https://en.wikipedia.org/wiki/File_descriptor#File_descriptors_as_capabilities">Capabilities</a> are customized file descriptors that carry specific actions.</li>
</ul>
<h2 id="sandbox"><a class="header" href="#sandbox">Sandbox</a></h2>
<p>The sandbox system duplicates the system resources for each program, it allows them to be completely isolated from the main system. Flatpak and Snap use a sandbox security system on Linux, Redox will do the same.</p>
<p>Redox allows sandbox by limiting a program's capabilities:</p>
<ul>
<li>Only a certain number of schemes in the program's namespace is allowed, or no scheme at all. That way new file descriptors can't be opened.</li>
<li>All functionality is forced to occur via file descriptors (WIP).</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="features-1"><a class="header" href="#features-1">Features</a></h1>
<ul>
<li><a href="features.html#desktop">æ¡Œé¢è£ç½®</a></li>
<li><a href="features.html#mobile">ç§»å‹•è£ç½®</a></li>
<li><a href="features.html#external-references">å¤–éƒ¨åƒè€ƒ</a></li>
</ul>
<p>This page contains an operating system comparison table for common/important features.</p>
<h2 id="desktop-1"><a class="header" href="#desktop-1">Desktop</a></h2>
<div class="table-wrapper"><table><thead><tr><th><strong>Feature</strong></th><th><strong>Redox</strong></th><th><strong>Linux (GNU/Linux)</strong></th><th><strong>FreeBSD</strong></th><th><strong>Plan 9</strong></th></tr></thead><tbody>
<tr><td><a href="https://en.wikipedia.org/wiki/Symmetric_multiprocessing">SMP</a></td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td></tr>
<tr><td><a href="https://en.wikipedia.org/wiki/Non-uniform_memory_access">NUMA</a></td><td>No (planned)</td><td>Yes</td><td>Yes</td><td>No</td></tr>
<tr><td>å…¨ç£ç¢ŸåŠ å¯†</td><td>Yes</td><td>Yes</td><td>Yes</td><td>No</td></tr>
<tr><td>Exploit Mitigations</td><td>No (planned)</td><td>Yes</td><td>Yes</td><td>No</td></tr>
<tr><td>OpenGL/Vulkan</td><td>Only OpenGL with CPU emulation</td><td>Yes</td><td>Yes</td><td>No</td></tr>
<tr><td><a href="https://en.wikipedia.org/wiki/UEFI">UEFI</a> Boot Loader</td><td>Yes</td><td>Yes</td><td>Yes</td><td>No</td></tr>
<tr><td><a href="https://en.wikipedia.org/wiki/Parallel_ATA">IDE</a></td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td></tr>
<tr><td><a href="https://en.wikipedia.org/wiki/SATA">SATA</a></td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td></tr>
<tr><td><a href="https://en.wikipedia.org/wiki/NVM_Express">NVMe</a></td><td>Yes</td><td>Yes</td><td>Yes</td><td>No</td></tr>
<tr><td><a href="https://en.wikipedia.org/wiki/Peripheral_Component_Interconnect">PCI</a></td><td>Yes</td><td>Yes</td><td>Yes</td><td>No</td></tr>
<tr><td><a href="https://en.wikipedia.org/wiki/PCI_Express">PCIe</a></td><td>Yes</td><td>Yes</td><td>Yes</td><td>No</td></tr>
<tr><td><a href="https://en.wikipedia.org/wiki/USB">USB</a></td><td>Yes (incomplete)</td><td>Yes</td><td>Yes</td><td>Yes</td></tr>
<tr><td><a href="https://en.wikipedia.org/wiki/Ethernet">Ethernet</a></td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td></tr>
<tr><td><a href="https://en.wikipedia.org/wiki/Wi-Fi">Wi-Fi</a></td><td>No (planned)</td><td>Yes</td><td>Yes</td><td>No</td></tr>
<tr><td><a href="https://en.wikipedia.org/wiki/Bluetooth">Bluetooth</a></td><td>No (planned)</td><td>Yes</td><td>Yes</td><td>No</td></tr>
</tbody></table>
</div>
<h2 id="mobile"><a class="header" href="#mobile">Mobile</a></h2>
<div class="table-wrapper"><table><thead><tr><th><strong>Feature</strong></th><th><strong>Redox</strong></th><th><strong>Android</strong></th><th><strong>iOS</strong></th></tr></thead><tbody>
<tr><td><a href="https://source.android.com/docs/security/features/encryption/file-based">File-based Encryption</a></td><td>No</td><td>Yes</td><td>Not documented</td></tr>
<tr><td><a href="https://en.wikipedia.org/wiki/Sandbox_(computer_security)">Sandboxing</a></td><td>Yes</td><td>Yes</td><td>Yes</td></tr>
<tr><td><a href="https://en.wikipedia.org/wiki/Tethering">USB Tethering</a></td><td>No (planned)</td><td>Yes</td><td>Yes</td></tr>
<tr><td><a href="https://en.wikipedia.org/wiki/Near-field_communication">NFC</a></td><td>No (planned)</td><td>Yes</td><td>Yes</td></tr>
<tr><td><a href="https://en.wikipedia.org/wiki/Global_Positioning_System">GPS</a></td><td>No (planned)</td><td>Yes</td><td>Yes</td></tr>
<tr><td>Sensors</td><td>No (planned)</td><td>Yes</td><td>Yes</td></tr>
<tr><td>Factory Reset</td><td>No (planned)</td><td>Yes</td><td>Yes</td></tr>
</tbody></table>
</div>
<h2 id="å¤–éƒ¨åƒè€ƒ"><a class="header" href="#å¤–éƒ¨åƒè€ƒ">å¤–éƒ¨åƒè€ƒ</a></h2>
<ul>
<li><a href="https://github.com/flosse/rust-os-comparison">Rust OS Comparison</a> - A table comparing some Rust-written operating systems.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="è»Ÿé«”åŒ…ç®¡ç†"><a class="header" href="#è»Ÿé«”åŒ…ç®¡ç†">è»Ÿé«”åŒ…ç®¡ç†</a></h1>
<p>Redox package management is similar to that of the major Linux distributions, except that many of Redox's (Rust-written) packages use static linking by default, rather than dynamic linking.</p>
<p>Static linking provides a few advantages over dynamic linking:</p>
<ul>
<li>
<p><strong>Better Security</strong></p>
<p>Static linking can improve system security by running each program's library code in isolated memory locations. This is true even when identical versions of a vulnerable library are being used by multiple programs at once.</p>
<p>To steal sensitive data from statically linked programs, an attacker would need to inject code directly into each program's memory address space, rather than the address space of a shared library. This increases the cost of the attack.</p>
</li>
<li>
<p><strong>Better Performance</strong></p>
<p>When a program is built with static linking, its library references are resolved before execution. Thus, there's no need for processing on the dynamic linker.</p>
<p>This means a statically linked program will open faster than its dynamically linked equivalent, provided both are loaded entirely from disk.</p>
</li>
<li>
<p><strong>Simpler Dependency Management</strong></p>
<p>When a dynamically linked program depends on multiple versions of the same library, naming conflicts can arise from the identical object or symbol names within those versions. This issue can necessitate isolating the library files, often by giving them unique names or placing them in separate <code>/lib</code> directories, to ensure the proper version is used in each case.</p>
<p>With <em>static linking</em>, however, there's no need for run-time dependency management, as library dependencies are included within the executable binaries.</p>
<p>Rust programs aren't affected by this problem because of Cargo.</p>
</li>
</ul>
<blockquote>
<p>ğŸ“ <strong>Note:</strong> Rust programs are statically linked by default.</p>
</blockquote>
<h2 id="format"><a class="header" href="#format">Format</a></h2>
<h3 id="what-is-pkgar-"><a class="header" href="#what-is-pkgar-">What is "pkgar" ?</a></h3>
<p>Short for "package archive", <code>pkgar</code> is a file format, library, and command-line executable for creating and extracting cryptographically secure collections of files, primarily for use in package management on Redox OS.</p>
<p>The technical details are still in development, so we think it is good to instead review the goals of <code>pkgar</code> and some examples that demonstrate its design principles.</p>
<p><code>pkgar</code> has the following goals:</p>
<ul>
<li>Atomic - Updates are done atomically if possible</li>
<li>Economical - Transfer of data must only occur when hashes change, allowing for network and data usage to be minimized</li>
<li>Fast - Encryption and hashing algorithms are chosen for performance, and packages can potentially be extracted in parallel</li>
<li>Minimal - Unlike other formats such as <code>tar</code>, the metadata included in a <code>pkgar</code> file is only what is required to extract the package</li>
<li>Relocatable - Packages can be installed to any directory, by any user, provided the user can verify the package signature and has access to that directory.</li>
<li>Secure - Packages are always cryptographically secure, and verification of all contents must occur before installation of a package completes.</li>
</ul>
<p>To demonstrate how the format's design achieves these goals, let's look at some examples.</p>
<h3 id="example-1-newly-installed-package"><a class="header" href="#example-1-newly-installed-package">Example 1: Newly installed package</a></h3>
<p>In this example, a package is installed that has never been installed on the system, from a remote repository. We assume that the repository's public key is already installed on disk, and that the URL to the package's <code>pkgar</code> is known.</p>
<p>First, a small, fixed-size header portion of the <code>pkgar</code> is downloaded. This is currently 136 bytes in size. It contains a NaCL signature, NaCL public key, BLAKE3 hash of the entry metadata, and 64-bit count of entry metadata structs.</p>
<p>Before this header can be used, it is verified. The public key must match the one installed on disk. The signature of the struct must verify against the public key. If this is true, the hash and entry count are considered valid.</p>
<p>The entry metadata can now be downloaded to a temporary file. During the download, the BLAKE3 hash is calculated. If this hash matches the hash in the header, the metadata is considered valid and is moved atomically to the correct location for future use. Both the header and metadata are stored in this file.</p>
<p>Each entry metadata struct contains a BLAKE3 hash of the entry data, a 64-bit offset of the file data in the data portion of the <code>pkgar</code>, a 64-bit size of the file data, a 32-bit mode identifying Unix permissions, and up to a 256-byte relative path for the file.</p>
<p>For each entry, before downloading the file data, the path can be validated for install permissions. The file data is downloaded to a temporary file, with no read, write, or execute permissions. While the download is happening, the BLAKE3 hash is calculated. If this hash matches, the file data is considered valid.</p>
<p>After downloading all entries, the temporary files have their permissions set as indicated by the mode in the metadata. They are then moved atomically to the correct location. At this point, the package is successfully installed.</p>
<h3 id="example-2-updated-package"><a class="header" href="#example-2-updated-package">Example 2: Updated package</a></h3>
<p>In this example, a package is updated, and only one file changes. This is to demonstrate the capabilities of <code>pkgar</code> to minimize disk writes and network traffic.</p>
<p>First, the header is downloaded. The header is verified as before. Since a file has changed, the metadata hash will have changed. The metadata will be downloaded and verified. Both header and metadata will be atomically updated on disk.</p>
<p>The entry metadata will be compared to the previous entry metadata. The hash for one specific file will have changed. Only the contents for that file will be downloaded to a temporary file, and verified. Once that is complete, it will be atomically updated on disk. The package update is successfully completed, and only the header, entry metadata, and the files that have changed were downloaded and written.</p>
<h3 id="example-3-package-verification"><a class="header" href="#example-3-package-verification">Example 3: Package verification</a></h3>
<p>In this example, a package is verified against the metadata saved on disk. It is possible to reconstruct a package from an installed system, for example, in order to install that package from a live disk.</p>
<p>First, the header is verified as before. The entry metadata is then verified. If there is a mismatch, an error is thrown and the package could be reinstalled.</p>
<p>The entry metadata will be compared to the files on disk. The mode of each file will be compared to the metadata mode. Then the hash of the file data will be compared to the hash in the metadata. If there is a mismatch, again, an error is thrown and the package could be reinstalled.</p>
<p>It would be possible to perform this process while copying the package to a new target. This allows the installation of a package from a live disk to a new install without having to store the entire package contents.</p>
<h3 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h3>
<p>As the examples show, the design of <code>pkgar</code> is meant to provide the best possible package management experience on Redox OS. At no point should invalid data be installed on disk in accessible files, and installation should be incredibly fast and efficient.</p>
<p>Work still continues on determining the repository format.</p>
<p>The source for <code>pkgar</code> is fairly lightweight, we highly recommend reading it and contributing to the <a href="https://gitlab.redox-os.org/redox-os/pkgar">pkgar</a> repository.</p>
<p>If you have questions, feel free to ask us on the <a href="./chat.html">Chat</a> page.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="schemes-and-resources"><a class="header" href="#schemes-and-resources">Schemes and Resources</a></h1>
<p>An essential design choice made for Redox is to refer to resources using scheme-rooted paths. This gives Redox the ability to:</p>
<ul>
<li>Treat resources (files, devices, etc.) in a consistent manner</li>
<li>Provide resource-specific behaviors with a common interface</li>
<li>Allow management of names and namespaces to provide sandboxing and other security features</li>
<li>Enable device drivers and other system resource management to communicate with each other using the same mechanisms available to user programs</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scheme-rooted-paths"><a class="header" href="#scheme-rooted-paths">Scheme-rooted Paths</a></h1>
<p>Scheme-rooted paths are the way that resources are identified on Redox.</p>
<h2 id="what-is-a-resource"><a class="header" href="#what-is-a-resource">What is a Resource</a></h2>
<p>A <a href="./resources.html">resource</a> is anything that a program might wish to access, usually referenced by some name.</p>
<h2 id="what-is-a-scheme"><a class="header" href="#what-is-a-scheme">What is a Scheme</a></h2>
<p>A <a href="./schemes.html">scheme</a> identifies the starting point for finding a resource.</p>
<h2 id="what-is-a-scheme-rooted-path"><a class="header" href="#what-is-a-scheme-rooted-path">What is a Scheme-rooted Path</a></h2>
<p>A scheme-rooted path takes the following form, with text in <strong>bold</strong> being literal.</p>
<p><strong>/scheme/</strong><em>scheme-name</em><strong>/</strong><em>resource-name</em></p>
<p><em>scheme-name</em> is the name of the kind of resource, and it also identifies the name used by the manager <strong>daemon</strong> for that kind.</p>
<p><em>resource-name</em> is the specific resource of that kind. Typically in Redox, the <em>resource-name</em> is a path with elements separated by slashes, but the resource manager is free to interpret the <em>resource-name</em> how it chooses, allowing other formats to be used if required.</p>
<h2 id="differences-from-unix"><a class="header" href="#differences-from-unix">Differences from Unix</a></h2>
<p>Unix systems have some special file types, such as "block special file" or "character special file". These special files use <a href="https://en.wikipedia.org/wiki/Device_file#Unix_and_Unix-like_systems">major/minor</a> numbers to identify the driver and the specific resource within the driver. There are also pseudo-filesystems, for example <a href="https://en.wikipedia.org/wiki/Procfs">procfs</a> that provide access to resources using paths.</p>
<p>Redox's scheme-rooted paths provide a consistent approach to resource naming, compared with Unix.</p>
<h2 id="regular-files"><a class="header" href="#regular-files">Regular Files</a></h2>
<p>For Redox, a path that does not begin with <code>/scheme/</code> is a reference to the the root filesystem, which is managed by the <code>file</code> scheme. Thus <code>/home/user/.bashrc</code> is interpreted as <code>/scheme/file/home/user/.bashrc</code>.</p>
<p>In this case, the scheme is <code>file</code> and the resource is <code>home/user/.bashrc</code> within that scheme.</p>
<p>This makes paths for regular files feel as natural as Unix file paths.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="è³‡æº"><a class="header" href="#è³‡æº">è³‡æº</a></h1>
<p>A resource is any "thing" that can be referred to using a path. It can be a physical device, a logical pseudodevice, a file on a file system, a service that has a name, or an element of a dataset.</p>
<p>The client program accesses a resource by opening it, using the resource name in scheme-rooted path format. The first part of the path is the name of the scheme, and the rest of the path is interpreted by the scheme provider, assigning whatever meaning is appropriate for the resources included under that scheme.</p>
<p>Some schemes, such as <code>/scheme/pty/</code> simply allocate sequentially numbered resources and do not need the complexity of a slash-separated path.</p>
<h2 id="è³‡æºç¯„ä¾‹"><a class="header" href="#è³‡æºç¯„ä¾‹">è³‡æºç¯„ä¾‹</a></h2>
<p>Some examples of resources are:</p>
<ul>
<li>Files within a filesystem - <code>/path/to/file</code> is interpreted as <code>/scheme/file/path/to/file</code>. Other filesystems can be referenced as <code>/scheme/otherfs/path/to/file</code>.</li>
<li>Pseudo-terminals - <code>/scheme/pty/n</code> where <code>n</code> is a number, refers to a particular <a href="https://en.wikipedia.org/wiki/Pseudoterminal">pseudo-terminal</a>.</li>
<li>Display - <code>/scheme/display.vesa/n</code> where <code>n</code> is a number, refers to the VESA virtual display - Virtual display 1  is the system log, display 2 is the text UI, and display 3 is the graphical display used by Orbital.</li>
<li>Networking - <code>/scheme/udp/a.b.c.d/p</code> is the UDP socket with IPv4 address <code>a.b.c.d</code>, port number <code>p</code>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="schemes"><a class="header" href="#schemes">Schemes</a></h1>
<p>**æ–¹æ¡ˆï¼ˆSchemeï¼‰**çš„åç¨±æºè‡ª <a href="https://en.wikipedia.org/wiki/List_of_URI_schemes">URI æ–¹æ¡ˆ</a>ï¼Œç”¨æ–¼è­˜åˆ¥è³‡æºçš„é¡å‹ï¼Œä¸¦è­˜åˆ¥è² è²¬è©²è³‡æºçš„ç®¡ç†å®ˆè­·é€²ç¨‹ï¼ˆdaemonï¼‰ã€‚</p>
<p>Within Redox, a scheme may be thought of in a few ways. It is all of these things:</p>
<ul>
<li>The <strong>type</strong> of a resource, such as "file", "NVMe drive", "TCP connection", etc. (Note that these are not valid scheme names, they are just given by way of example.)</li>
<li>The starting point for locating the resource, i.e. it is the root of the path to the resource, which the system can then use in establishing a connection to the resource.</li>
<li>A <strong>uniquely named service</strong> that is provided by some driver or daemon program, with the full path identifying a specific resource accessed via that service.</li>
</ul>
<h2 id="scheme-daemons"><a class="header" href="#scheme-daemons">Scheme Daemons</a></h2>
<p>A scheme is typically provided by a <strong>daemon</strong>. A daemon is a program that runs as a process in userspace; it is typically started by the system during boot. When the process starts, it registers with kernel using the name of the scheme that it manages.</p>
<h2 id="å…§æ ¸èˆ‡ä½¿ç”¨è€…ç©ºé–“æ–¹æ¡ˆ"><a class="header" href="#å…§æ ¸èˆ‡ä½¿ç”¨è€…ç©ºé–“æ–¹æ¡ˆ">å…§æ ¸èˆ‡ä½¿ç”¨è€…ç©ºé–“æ–¹æ¡ˆ</a></h2>
<p>A <a href="schemes.html#userspace-schemes">userspace scheme</a> is implemented by a scheme daemon, described above. A <a href="schemes.html#kernel-schemes">kernel scheme</a> is implemented within the kernel, and manages critical resources not easily managed with a userspace daemon. When possible, schemes should be implemented in userspace.</p>
<h2 id="accessing-resources"><a class="header" href="#accessing-resources">Accessing Resources</a></h2>
<p>In order to provide "virtual file" behavior, schemes generally implement file-like operations. However, it is up to the scheme provider to determine what each file-like operation means. For example, <code>seek</code> to an SSD driver scheme might simply add to a file offset, but to a floppy disk controller scheme, it might cause the physical movement of disk read-write heads.</p>
<p>Typical scheme operations include:</p>
<ul>
<li><code>open</code> - Create a <strong>handle</strong> (file descriptor) to a resource provided by the scheme. e.g. <code>File::create("/scheme/tcp/127.0.0.1/3000")</code> in a regular program would be converted by the kernel into <code>open("127.0.0.1/3000")</code> and sent to the "tcp" scheme provider. The "tcp" scheme provider would parse the name, establish a connection to Internet address "127.0.0.1", port "3000", and return a handle that represents that connection.</li>
<li><code>read</code> - get some data from the thing represented by the handle, normally consuming that data so the next <code>read</code> will return new data.</li>
<li><code>write</code> - send some data to the thing represented by the handle to be saved, sent or written.</li>
<li><code>seek</code> - change the logical location where the next <code>read</code> or <code>write</code> will occur. This may or may not cause some action by the scheme provider.</li>
</ul>
<p>Schemes may choose to provide other standard operations, such as <code>mkdir</code>, but the meaning of the operation is up to the scheme. <code>mkdir</code> might create a directory entry, or it might create some type of substructure or container relevant to that particular scheme.</p>
<p>Some schemes implement <code>fmap</code>, which creates a memory-mapped area that is shared between the scheme resource and the scheme user. It allows direct memory operations on the resource, rather than reading and writing to a file descriptor. The most common use case for <code>fmap</code> is for a device driver to access the physical addresses of a memory-mapped device, using the <code>memory:</code> kernel scheme. It is also used for frame buffers in the graphics subsystem.</p>
<blockquote>
<p>TODO: add F-operations.</p>
</blockquote>
<blockquote>
<p>TODO: explain file-like vs. socket-like schemes.</p>
</blockquote>
<h2 id="ä½¿ç”¨è€…ç©ºé–“æ–¹æ¡ˆ"><a class="header" href="#ä½¿ç”¨è€…ç©ºé–“æ–¹æ¡ˆ">ä½¿ç”¨è€…ç©ºé–“æ–¹æ¡ˆ</a></h2>
<p>Redox creates user-space schemes during initialization, starting various daemon-style programs, each of which can provide one or more schemes.</p>
<div class="table-wrapper"><table><thead><tr><th><strong>Scheme</strong></th><th><strong>Daemon</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>disk.*</td><td>ided, ahcid, nvmed</td><td>Storage drivers</td></tr>
<tr><td>disk.live</td><td>lived</td><td>RAM-disk driver that loads the bootable USB data into RAM</td></tr>
<tr><td>disk.usb-{id}+{port}-scsi</td><td>usbscsid</td><td>USB SCSI driver</td></tr>
<tr><td>logging</td><td><a href="https://gitlab.redox-os.org/redox-os/base/-/tree/main/ramfs?ref_type=heads">ramfs</a></td><td>Error logging scheme, using an in-memory temporary filesystem</td></tr>
<tr><td>initfs</td><td><a href="https://gitlab.redox-os.org/redox-os/base/-/tree/main/bootstrap?ref_type=heads">bootstrap</a></td><td>Startup filesystem</td></tr>
<tr><td>file</td><td><a href="https://gitlab.redox-os.org/redox-os/redoxfs">redoxfs</a></td><td>Main filesystem</td></tr>
<tr><td>network</td><td>e1000d, rtl8168d</td><td>Link-level network send/receive</td></tr>
<tr><td>ip</td><td><a href="https://gitlab.redox-os.org/redox-os/base/-/blob/master/netstack/src/smolnetd/scheme/ip.rs?ref_type=heads">smolnetd</a></td><td>Raw IP packet send/receive</td></tr>
<tr><td>tcp</td><td><a href="https://gitlab.redox-os.org/redox-os/base/-/blob/master/netstack/src/smolnetd/scheme/tcp.rs?ref_type=heads">smolnetd</a></td><td>TCP sockets</td></tr>
<tr><td>udp</td><td><a href="https://gitlab.redox-os.org/redox-os/base/-/blob/master/netstack/src/smolnetd/scheme/udp.rs?ref_type=heads">smolnetd</a></td><td>UDP sockets</td></tr>
<tr><td>icmp</td><td><a href="https://gitlab.redox-os.org/redox-os/base/-/blob/master/netstack/src/smolnetd/scheme/icmp.rs?ref_type=heads">smolnetd</a></td><td>ICMP protocol</td></tr>
<tr><td>netcfg</td><td><a href="https://gitlab.redox-os.org/redox-os/base/-/tree/master/netstack/src/smolnetd/scheme/netcfg?ref_type=heads">smolnetd</a></td><td>ç¶²è·¯çµ„æ…‹</td></tr>
<tr><td>display.vesa</td><td>vesad</td><td>VESA driver</td></tr>
<tr><td>display.virtio-gpu</td><td>virtio-gpud</td><td>VirtIO GPU driver</td></tr>
<tr><td>orbital</td><td><a href="https://gitlab.redox-os.org/redox-os/orbital">orbital</a></td><td>Windowing system (window manager and virtual driver)</td></tr>
<tr><td>pty</td><td><a href="https://gitlab.redox-os.org/redox-os/base/-/tree/main/ptyd?ref_type=heads">ptyd</a></td><td>Pseudoterminals, used by terminal emulators</td></tr>
<tr><td>audiorw</td><td>sb16d, ac97d, ihdad</td><td>Sound drivers</td></tr>
<tr><td>audio</td><td><a href="https://gitlab.redox-os.org/redox-os/base/-/tree/main/audiod?ref_type=heads">audiod</a></td><td>Audio manager and virtual device</td></tr>
<tr><td>usb.*</td><td>usb*d</td><td>USB drivers</td></tr>
<tr><td>acpi</td><td>acpid</td><td>ACPI driver</td></tr>
<tr><td>input</td><td>inputd</td><td>Virtual device</td></tr>
<tr><td>sudo</td><td>sudo</td><td>Privilege manager</td></tr>
<tr><td>chan</td><td><a href="https://gitlab.redox-os.org/redox-os/base/-/tree/main/ipcd?ref_type=heads">ipcd</a></td><td>Inter-process communication</td></tr>
<tr><td>shm</td><td><a href="https://gitlab.redox-os.org/redox-os/base/-/tree/main/ipcd?ref_type=heads">ipcd</a></td><td>Shared memory manager</td></tr>
<tr><td>log</td><td><a href="https://gitlab.redox-os.org/redox-os/base/-/tree/main/logd?ref_type=heads">logd</a></td><td>Logging</td></tr>
<tr><td>rand</td><td><a href="https://gitlab.redox-os.org/redox-os/base/-/tree/main/randd?ref_type=heads">randd</a></td><td>Pseudo-random number generator</td></tr>
<tr><td>zero</td><td><a href="https://gitlab.redox-os.org/redox-os/base/-/tree/main/zerod?ref_type=heads">zerod</a></td><td>Discard all writes, and always fill read buffers with zeroes</td></tr>
<tr><td>null</td><td><a href="https://gitlab.redox-os.org/redox-os/base/-/tree/main/nulld?ref_type=heads">nulld</a></td><td>Discard all writes, and read no bytes</td></tr>
</tbody></table>
</div>
<h2 id="kernel-schemes"><a class="header" href="#kernel-schemes">Kernel Schemes</a></h2>
<p>The kernel provides a small number of schemes in order to support userspace.</p>
<div class="table-wrapper"><table><thead><tr><th><strong>Name</strong></th><th><strong>Documentation</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>namespace</td><td><a href="https://gitlab.redox-os.org/redox-os/kernel/-/blob/master/src/scheme/root.rs">root.rs</a></td><td>Namespace manager</td></tr>
<tr><td>user</td><td><a href="https://gitlab.redox-os.org/redox-os/kernel/-/blob/master/src/scheme/user.rs">user.rs</a></td><td>Dispatch for user-space schemes</td></tr>
<tr><td>debug</td><td><a href="https://gitlab.redox-os.org/redox-os/kernel/-/blob/master/src/scheme/debug.rs">debug.rs</a></td><td>Debug messages that can't use the <code>log:</code> scheme</td></tr>
<tr><td>event</td><td><a href="https://gitlab.redox-os.org/redox-os/kernel/-/blob/master/src/scheme/event.rs">event.rs</a></td><td>epoll-like file descriptor read/write "ready" events</td></tr>
<tr><td>irq</td><td><a href="https://gitlab.redox-os.org/redox-os/kernel/-/blob/master/src/scheme/irq.rs">irq.rs</a></td><td>Interrupt manager (converts interrupts to messages)</td></tr>
<tr><td>pipe</td><td><a href="https://gitlab.redox-os.org/redox-os/kernel/-/blob/master/src/scheme/pipe.rs">pipe.rs</a></td><td>Kernel manager for pipes</td></tr>
<tr><td>proc</td><td><a href="https://gitlab.redox-os.org/redox-os/kernel/-/blob/master/src/scheme/proc.rs">proc.rs</a></td><td>Process context manager</td></tr>
<tr><td>thisproc</td><td><a href="https://gitlab.redox-os.org/redox-os/kernel/-/blob/master/src/scheme/proc.rs">proc.rs</a></td><td>Process context manager</td></tr>
<tr><td>sys</td><td><a href="https://gitlab.redox-os.org/redox-os/kernel/-/blob/master/src/scheme/sys/mod.rs">mod.rs</a></td><td>System hardware resources information</td></tr>
<tr><td>kernel.acpi</td><td><a href="https://gitlab.redox-os.org/redox-os/kernel/-/blob/master/src/scheme/acpi.rs">acpi.rs</a></td><td>Read the CPU configuration (number of cores, etc)</td></tr>
<tr><td>memory</td><td><a href="https://gitlab.redox-os.org/redox-os/kernel/-/blob/master/src/scheme/memory.rs">memory.rs</a></td><td>Physical memory mapping manager</td></tr>
<tr><td>time</td><td><a href="https://gitlab.redox-os.org/redox-os/kernel/-/blob/master/src/scheme/time.rs">time.rs</a></td><td>Real-time clock timer</td></tr>
<tr><td>itimer</td><td><a href="https://gitlab.redox-os.org/redox-os/kernel/-/blob/master/src/scheme/itimer.rs">time.rs</a></td><td>Interval timer</td></tr>
<tr><td>serio</td><td><a href="https://gitlab.redox-os.org/redox-os/kernel/-/blob/master/src/scheme/serio.rs">serio.rs</a></td><td>Serial I/O (PS/2) driver (must stay in the kernel due to PS/2 protocol issues)</td></tr>
</tbody></table>
</div>
<h2 id="scheme-list"><a class="header" href="#scheme-list">Scheme List</a></h2>
<p>This section has all Redox schemes in a list format to improve organization, coordination and focus.</p>
<h3 id="ä½¿ç”¨è€…ç©ºé–“"><a class="header" href="#ä½¿ç”¨è€…ç©ºé–“">ä½¿ç”¨è€…ç©ºé–“</a></h3>
<ul>
<li>disk.*</li>
<li>disk.live</li>
<li>disk.usb-{id}+{port}-scsi</li>
<li>logging</li>
<li>initfs</li>
<li>file</li>
<li>network</li>
<li>ip</li>
<li>tcp</li>
<li>udp</li>
<li>icmp</li>
<li>netcfg</li>
<li>display.vesa</li>
<li>display.virtio-gpu</li>
<li>orbital</li>
<li>pty</li>
<li>audiorw</li>
<li>audio</li>
<li>usb.*</li>
<li>sudo</li>
<li>acpi</li>
<li>input</li>
<li>chan</li>
<li>shm</li>
<li>log</li>
<li>rand</li>
<li>zero</li>
<li>null</li>
</ul>
<h3 id="kernel-1"><a class="header" href="#kernel-1">Kernel</a></h3>
<ul>
<li>namespace</li>
<li>user</li>
<li>debug</li>
<li>event</li>
<li>irq</li>
<li>pipe</li>
<li>proc</li>
<li>thisproc</li>
<li>sys</li>
<li>kernel.acpi</li>
<li>memory</li>
<li>time</li>
<li>itimer</li>
<li>serio</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ä¸€åˆ‡çš†æª”æ¡ˆ-1"><a class="header" href="#ä¸€åˆ‡çš†æª”æ¡ˆ-1">ã€Œä¸€åˆ‡çš†æª”æ¡ˆã€</a></h1>
<p>Unix has a concept of using file paths to represent "special files" that have some meaning beyond a regular file. For example, a <a href="https://en.wikipedia.org/wiki/Device_file">device file</a> is a reference to a device resource that looks like a file path.</p>
<p>With the "Everything is a file" concept provided by Unix-like systems, all sorts of devices, processes, and kernel parameters can be accessed as files in a regular filesystem. If you are on a Linux computer, you should try to <code>cd</code> to <code>/proc</code>, and see what's going on there.</p>
<p>Redox extends this concept to a much more powerful one. Since each "scheme provider" is free to interpret the path in its own way, new schemes can be created as needed for each type of resource. This way USB devices don't end up in a "filesystem", but a protocol-based scheme like <code>EHCI</code>. It is not necessary for the file system software to understand the meaning of a particular path, or to give a special file some special properties that then become a fixed file system convention.</p>
<p>Redox schemes are flexible enough to be used in many circumstances, with each scheme provider having full flexibility to define its own path conventions and meanings, and only the programs that wish to take advantage of those meanings need to understand them.</p>
<p>Redox does not go as far as <a href="http://doc.cat-v.org/plan_9/4th_edition/papers/net/">Plan 9</a>, in that there are not separate paths for data and control of resources. In this case, Redox is more like Unix, where resources can potentially have a control interface.</p>
<h2 id="documentation-about-this-design"><a class="header" href="#documentation-about-this-design">Documentation about this design</a></h2>
<ul>
<li><a href="https://drewdevault.com/2022/11/12/In-praise-of-Plan-9.html">Drew DeVault - In praise of Plan 9</a></li>
<li><a href="https://plan9.io/sys/doc/">Plan 9 documentation</a></li>
<li><a href="https://plan9.io/wiki/plan9/plan_9_wiki/">Plan 9 wiki</a></li>
<li><a href="http://9p.cat-v.org/documentation/">9P documentation</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stiching-it-all-together"><a class="header" href="#stiching-it-all-together">Stiching It All Together</a></h1>
<p>The "path, scheme, resource" model is simply a unified interface for efficient inter-process communication. Paths are simply resource descriptors. Schemes are simply resource types, provided by scheme managers.</p>
<p>A diagram would look like this:</p>
<p><img src="./assets/scheme_resolution_diagram.png" alt="Diagram illustrating scheme resolution" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scheme-operation"><a class="header" href="#scheme-operation">Scheme Operation</a></h1>
<p>A <a href="./schemes.html#kernel-vs-userspace-schemes">kernel scheme</a> is implemented directly in the kernel. A <a href="./schemes.html#kernel-vs-userspace-schemes">userspace scheme</a> is typically implemented by a daemon.</p>
<p>A scheme is created in the <a href="scheme-operation.html#root-scheme">root scheme</a> and listens for requests using the <a href="scheme-operation.html#event-scheme">event scheme</a>.</p>
<h2 id="root-scheme"><a class="header" href="#root-scheme">Root Scheme</a></h2>
<p>The <code>root</code> scheme is a special scheme provided by the kernel. It acts as the container for all other scheme names. The root scheme is currently referenced as ":", so when creating a new scheme, the scheme provider calls <code>File::create(":myscheme")</code>. The file descriptor that is returned by this operation is a message passing channel between the scheme provider and the kernel. File operations performed by a regular program are translated by the kernel into message <strong>packets</strong> that the scheme provider reads and responds to, using this file descriptor.</p>
<h2 id="event-æ–¹æ¡ˆ"><a class="header" href="#event-æ–¹æ¡ˆ">Event æ–¹æ¡ˆ</a></h2>
<p>The <code>event</code> scheme is a special scheme provided by the kernel that allows a scheme provider or other program to listen for events occurring on a file descriptor. A more detailed explanation of the <code>event</code> scheme can be found on the <a href="./event-scheme.html">Event Scheme</a> page.</p>
<p>Note that very simple scheme providers do not use the <code>event</code> scheme. However, if a scheme can receive requests or events from more than one source, the <code>event</code> scheme makes it easy for the daemon (scheme provider) to block until something (an event) happens, do some work, then block again until the next event.</p>
<h2 id="daemons-and-userspace-scheme-providers"><a class="header" href="#daemons-and-userspace-scheme-providers">Daemons and Userspace Scheme Providers</a></h2>
<p>A daemon is a program, normally started during system initialization. It runs with root permissions. It is intended to run continuously, handling requests and other relevant events. On some operating systems, daemons are automatically restarted if they exit unexpectedly. Redox does not currently do this but is likely to do so in the future.</p>
<p>On Redox, a userspace scheme provider is a typically a daemon, although it doesn't have to be. The scheme provider informs the kernel that it will provide the scheme by creating it, e.g. <code>File::create(":myscheme")</code> will create the scheme <code>myscheme</code>. Notice that the name used to create the scheme starts with ":", indicating that it is a new entry in the root scheme. Since it is created in the root scheme, the kernel knows that it is a new scheme, as named schemes are the only thing that can exist in the root scheme. In future, the scheme will register in a namespace using a different path format.</p>
<h2 id="namespaces"><a class="header" href="#namespaces">Namespaces</a></h2>
<p>At the time a regular program is started, it becomes a <strong>process</strong>, and it exists in a <strong>namespace</strong>. The namespace is a container for all the schemes, files and directories that a process can access. When a process starts another program, the <code>namespace</code> is inherited, so a new process can only access the schemes, files and directories that its parent process had available. If a parent process wants to limit (<strong>sandbox</strong>) a child process, it would do so as part of creating the child process.</p>
<p>Currently, Redox starts all processes in the "root" namespace. This will be changed in the future, sandboxing all user programs so most schemes and system resources are hidden.</p>
<p>Redox also provides a <code>null</code> namespace. A process that exists in the <code>null</code> namespace cannot open files or schemes by name, and can only use file descriptors that are already open. This is a security mechanism, mostly used to by daemons running with <code>root</code> permission to prevent themselves from being hijacked into opening things they should not be accessing. A daemon will typically open its scheme and any resources it needs during its initialization, then it will ask the kernel to place it in the <code>null</code> namespace so no further resources can be opened.</p>
<h2 id="providing-a-scheme"><a class="header" href="#providing-a-scheme">Providing a Scheme</a></h2>
<p>To provide a scheme, a program performs the following steps:</p>
<ol>
<li>Create the scheme, obtaining a file descriptor - <code>File::create(":myscheme")</code></li>
<li>Open a file descriptor for each resource that is required to provide the scheme's services, e.g. <code>File::open("/scheme/irq/{irq-name}")</code></li>
<li>Open a file descriptor for a timer if needed - <code>File::open("/scheme/time/{timer_type}")</code></li>
<li>Open a file descriptor for the event scheme (if needed) - <code>File::open("/scheme/event")</code></li>
<li>Move to the null namespace to prevent any additional resources from being accessed - <code>setrens(0,0)</code></li>
<li>Write to the <code>event</code> file descriptor to register each of the file descriptors the provider will listen to, including the scheme file descriptor - <code>event_fd.write(&amp;Event{fd, ...})</code></li>
</ol>
<p>Then, in a loop:</p>
<ol>
<li>
<p>Block, waiting for an event to read. For simple schemes, the scheme provider would not use this mechanism, it would simply do a blocking read of its scheme file descriptor.</p>
</li>
<li>
<p>Read the event to determine (based on the file descriptor included in the event) if it is a timer, a resource event, or a scheme request.</p>
</li>
<li>
<p>If it's a resource event, e.g. indicating a device interrupt, perform the necessary actions such as reading from the device and queuing the data for the scheme.</p>
</li>
<li>
<p>If it's a scheme event, read a request packet from the scheme file descriptor and call the "handler". The request packet will indicate if it's an <code>open</code>, <code>read</code>, <code>write</code>, etc. on the scheme:</p>
<ul>
<li>
<p>An <code>open</code> will include the name of the item to be opened. This can be parsed by the scheme provider to determine the exact resource the requestor wants to access. The scheme will allocate a handle for the resource, with a numbered descriptor. Descriptor numbers are in the range 0 to usize::MAX - 4096, leaving the upper 4096 values as internal error codes. These descriptors are used by the scheme provider to look up the <code>handle</code> data structure it uses internally for the resource. The descriptors are typically allocated sequentially, but a scheme provider could return a pointer to the handle data structure if it so chooses.</p>
<blockquote>
<p>ğŸ“ <strong>Note:</strong> the descriptor returned from an <code>open</code> request is not the same as the file descriptor returned to the client program. The kernel maps between the client's (process id, <code>fd</code> number) and the scheme provider's (process id, <code>handle</code> number).</p>
</blockquote>
</li>
<li>
<p>A <code>read</code> or <code>write</code>, etc., will be handled by the scheme, using the <code>handle</code> number to look up the information associated with the resource. The operation will be performed, or queued to be performed. If the request can be handled immediately, a response is sent back on the scheme file descriptor, matched to the original request.</p>
</li>
</ul>
</li>
<li>
<p>After all requests have been handled, loop through every <code>handle</code> to determine if any queued requests are now complete. A response is sent back on the scheme file descriptor for each completed request, matched to that request.</p>
</li>
<li>
<p>Set a timer if appropriate, to enable handling of device timeouts, etc. This is performed as a <code>write</code> operation on the timer file descriptor.</p>
</li>
</ol>
<h2 id="kernel-actions"><a class="header" href="#kernel-actions">Kernel Actions</a></h2>
<p>The kernel performs the following actions in support of the scheme:</p>
<ul>
<li>Any special resources required by a scheme provider are accessed as file operations on some other scheme. The kernel handles access to resources as it would for any other scheme.</li>
<li>Regular file operations from user programs are converted by the kernel to request messages to the schemes. The kernel maps the user program's file descriptor to a scheme and a handle id provided by the scheme during the open operation, and places them in a packet.</li>
<li>If the user program is performing a blocking read or write, the user program is suspended.</li>
<li>The kernel sends event packets on the scheme provider's <code>event</code> file descriptor, waking the blocked scheme provider. Each event packet indicates whether it is the scheme or some other resource, using the file descriptor obtained by the scheme provider during its initialization.</li>
<li>When the scheme provider reads from its scheme file descriptor, it receives the packets the kernel created describing the client request and handles them as described above.</li>
<li>When the scheme provider sends a response packet, the kernel maps the response to a return value from the user program's file operation.</li>
<li>When a blocking read or write is completed, the user program is marked ready to run, and the kernel will place it in the run queue.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="event-æ–¹æ¡ˆ-1"><a class="header" href="#event-æ–¹æ¡ˆ-1">Event æ–¹æ¡ˆ</a></h1>
<p>The <code>event</code> scheme is a special scheme that is central to the operation of device drivers, schemes and other programs that receive events from multiple sources. It's like a "clearing house" for activity on multiple file descriptors. The daemon or client program performs a <code>read</code> operation on the <code>event</code> scheme, blocking until an event happens. It then examines the event to determine what file descriptor is active, and performs a non-blocking read of the active file descriptor. In this way, a program can have many sources to read from, and rather than blocking on one of those sources while another might be active, the program blocks only on the <code>event</code> scheme, and is unblocked if any one of the other sources become active.</p>
<p>The <code>event</code> scheme is conceptually similar to Linux's <a href="https://manpages.ubuntu.com/manpages/focal/en/man7/epoll.7.html"><code>epoll</code></a> mechanism.</p>
<h2 id="what-is-a-blocking-read"><a class="header" href="#what-is-a-blocking-read">What is a Blocking Read</a></h2>
<p>For a regular program doing a regular read of a regular file, the program calls <code>read</code>, providing an input buffer, and when the <code>read</code> call returns, the data has been placed into the input buffer. Behind the scenes, the system receives the <code>read</code> request and suspends the program, meaning that the program is put aside while it waits for something to happen. This is very convenient if the program has nothing to do while it waits for the <code>read</code> to complete. However, if the thing the program is reading from might take a long time, such as a slow device, a network connection or input from the user, and there are other things for the program to do, such as updating the screen, performing a blocking read can prevent handling these other activities in a timely manner.</p>
<h2 id="non-blocking-read"><a class="header" href="#non-blocking-read">Non-blocking Read</a></h2>
<p>To allow reading from multiple sources without getting stuck waiting for any particular one, a program can open a path using the <code>O_NONBLOCK</code> flag. If data is ready to be read, the system immediately copies the data to the input buffer and returns normally. However, if data is not ready to be read, the <code>read</code> operation returns an error of type <code>EAGAIN</code>, which indicates that the program should try again later.</p>
<p>Now your program can scan many file descriptors, checking if any of them have data available to read. However, if none have any data, you want your program to block until there is something to do. This is where the <code>event</code> scheme comes in.</p>
<h2 id="using-the-event-scheme"><a class="header" href="#using-the-event-scheme">Using the Event Scheme</a></h2>
<p>The purpose of the <code>event</code> scheme is to allow the daemon or client program to receive a message on the <code>event_file</code>, to inform it that some other file descriptor is ready to be read. The daemon reads from the <code>event_file</code> to determine which other file descriptor is ready. If no other descriptor is ready, the <code>read</code> of the <code>event_file</code> will block, causing the daemon to be suspended until the event scheme indicates some other file descriptor is ready.</p>
<p>Before setting up the event scheme, you should <code>open</code> all the other resources you will be working with, but set them to be non-blocking. E.g. if you are a scheme provider, open your scheme in non-blocking mode,</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut scheme_file = OpenOptions::new()
            .create(true)
            .read(true)
            .write(true)
            .custom_flags(syscall::O_NONBLOCK as i32)
            .open(":myscheme")
            .expect("mydaemon: failed to create myscheme: scheme");
<span class="boring">}</span></code></pre></pre>
<p>The first step in using the event scheme is to open a connection to it. Each program will have a connection to the event scheme that is unique, so no path name is required, only the name of the scheme itself.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let event_file = File::open("/scheme/event");
// you actually need to open it read/write
<span class="boring">}</span></code></pre></pre>
<p>Next, write messages to the event scheme, one message per file descriptor that the <code>event</code> scheme should monitor. A message is in the form of a <code>syscall::data::Event</code> struct.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use syscall::data::Event;
let _ = event_file.write(&amp;Event{ id: scheme_file.as_raw_fd(), ... });
// write one message per file descriptor
<span class="boring">}</span></code></pre></pre>
<p>Note that timers in Redox are also handled via a scheme, so if you will be using a timer, you will need to open the <code>timer</code> scheme, and include that file descriptor among the ones your <code>event_file</code> should listen to.</p>
<p>Once your setup of the <code>event</code> scheme is complete, you begin your main loop:</p>
<ol>
<li>Perform a blocking read on the <code>event</code> file descriptor. <code>event_file.read(&amp;mut event_buf);</code></li>
<li>When an event, such as data becoming available on a file descriptor, occurs, the <code>read</code> operation on the <code>event_file</code> will complete.</li>
<li>Look at the <code>event_buf</code> to see which file descriptor is active.</li>
<li>Perform a non-blocking read on that file descriptor.</li>
<li>Perform the appropriate processing.</li>
<li>If you are using a timer, write to the timer file descriptor to tell it when you want an event.</li>
<li>Repeat.</li>
</ol>
<h2 id="non-blocking-write"><a class="header" href="#non-blocking-write">Non-blocking Write</a></h2>
<p>Sometimes write operations can take time, such as sending a message synchronously or writing to a device with a limited buffer. The <code>event</code> scheme allows you to listen for write file descriptors to become unblocked. If a single file descriptor is opened in read-write mode, your program will need to register with the <code>event</code> scheme twice, once for reading and once for writing.</p>
<h2 id="implementing-non-blocking-reads-in-a-scheme"><a class="header" href="#implementing-non-blocking-reads-in-a-scheme">Implementing Non-blocking Reads in a Scheme</a></h2>
<p>If your scheme supports non-blocking reads by clients, you will need to include some machinery to work with the <code>event</code> scheme on your client's behalf:</p>
<ol>
<li>
<p>Wait for an event that indicates activity on your scheme. <code>event_file.read(&amp;mut event_buf);</code></p>
</li>
<li>
<p>Read a packet from your scheme file descriptor containing the request from the client program. <code>scheme_file.read(&amp;mut packet)</code> The packet contains the details of which file descriptor is being read, and where the data should be copied to.</p>
</li>
<li>
<p>If the client is performing a <code>read</code> that would block, then queue the client request and return the <code>EAGAIN</code> error, writing the error response to your scheme file descriptor.</p>
</li>
<li>
<p>When data is available to read, send an event by writing a special packet to your scheme, indicating the handle id that is active:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>scheme_file.write(&amp;Packet { a: syscall::number::SYS_FEVENT, b: handle_id, ... });
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>When routing this response back to the client, the kernel will recognize it as an event message, and post the event on the client's <code>event_fd</code>, if one exists.</p>
</li>
<li>
<p>The scheme provider does not know whether the client has actually set up an <code>event_fd</code>. The scheme provider must send the event "just in case".</p>
</li>
<li>
<p>If an event has already been sent, but the client has not yet performed a <code>read</code>, the scheme should not send additional events. In correctly coded clients, extra events should not cause problems, but an effort should be made to not send unnecessary events. Be wary, however, as race conditions can occur where you think an extra event is not required but it actually is.</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="an-example"><a class="header" href="#an-example">An Example</a></h1>
<p>Enough theory! Time for an example.</p>
<p>We will implement a scheme which holds a vector. The scheme will push elements to the vector when it receives writes, and pop them when it is read. Let's call it <code>vec</code>.</p>
<p>The complete source for this example can be found at <a href="https://gitlab.redox-os.org/redox-os/vec_scheme_example">redox-os/vec_scheme_example</a>.</p>
<blockquote>
<p>TODO: the example has not been saved to the repo.</p>
</blockquote>
<h2 id="setup"><a class="header" href="#setup">Setup</a></h2>
<p>In order to build and run this example in a Redox environment, you'll need to be set up to compile the OS from source. The process for getting a program included in a local Redox build is laid out in the <a href="./including-programs.html">Including Programs in Redox</a> page. Pause here and follow the <code>helloworld</code> example in that guide if you want to get this example running.</p>
<p>This example assumes that <code>vec</code> was used as the name of the crate instead of <code>helloworld</code>. The crate should therefore be located at <code>cookbook/recipes/vec/source</code></p>
<p>Modify the <code>Cargo.toml</code> for the <code>vec</code> crate so that it looks something like this:</p>
<pre><code class="language-toml">[package]
name = "vec"
version = "0.1.0"
edition = "2018"

[[bin]]
name = "vec_scheme"
path = "src/scheme.rs"

[[bin]]
name = "vec"
path = "src/client.rs"

[dependencies]
redox_syscall = "^0.2.6"
</code></pre>
<p>Notice that there are two binaries here. We'll need another program to interact with our scheme, since CLI tools like <code>cat</code> use more operations than we strictly need to implement for our scheme. The client uses only the standard library.</p>
<h2 id="the-scheme-daemon"><a class="header" href="#the-scheme-daemon">The Scheme Daemon</a></h2>
<p>Create <code>src/scheme.rs</code> in the crate. Start by <code>use</code>ing a couple of symbols.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::cmp::min;
use std::fs::File;
use std::io::{Read, Write};

use syscall::Packet;
use syscall::scheme::SchemeMut;
use syscall::error::Result;
<span class="boring">}</span></code></pre></pre>
<p>We start by defining our mutable scheme struct, which will implement the <code>SchemeMut</code> trait and hold the state of the scheme.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct VecScheme {
    vec: Vec&lt;u8&gt;,
}

impl VecScheme {
    fn new() -&gt; VecScheme {
        VecScheme {
            vec: Vec::new(),
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Before implementing the scheme operations on our scheme struct, let's breifly discuss the way that this struct will be used. Our program (<code>vec_scheme</code>) will create the <code>vec</code> scheme by opening the corresponding scheme handler in the root scheme (<code>:vec</code>).  Let's implement a <code>main()</code> that intializes our scheme struct and registers the new scheme:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut scheme = VecScheme::new();

    let mut handler = File::create(":vec")
        .expect("Failed to create the vec scheme");
}</code></pre></pre>
<p>When other programs open/read/write/etc against our scheme, the Redox kernel will make those requests available to our program via this scheme handler. Our scheme will read that data, handle the requests, and send responses back to the kernel by writing to the scheme handler. The kernel will then pass the results of operations back to the caller.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // ...

    let mut packet = Packet::default();

    loop {
        // Wait for the kernel to send us requests
        let read_bytes = handler.read(&amp;mut packet)
            .expect("vec: failed to read event from vec scheme handler");

        if read_bytes == 0 {
            // Exit cleanly
            break;
        }

        // Scheme::handle passes off the info from the packet to the individual
        // scheme methods and writes back to it any information returned by
        // those methods.
        scheme.handle(&amp;mut packet);

        handler.write(&amp;packet)
            .expect("vec: failed to write response to vec scheme handler");
    }
}</code></pre></pre>
<p>Now let's deal with the specific operations on our scheme. The <code>scheme.handle(...)</code> call dispatches requests to these methods, so that we don't need to worry about the gory details of the <code>Packet</code> struct.</p>
<p>In most Unix systems (Redox included!), a program needs to open a file before it can do very much with it. Since our scheme is just a "virtual filesystem", programs call <code>open</code> with the path to the "file" they want to interact with when they want to start a conversation with our scheme.</p>
<p>For our vec scheme, let's push whatever path we're given to the vec:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl SchemeMut for VecScheme {
    fn open(&amp;mut self, path: &amp;str, _flags: usize, _uid: u32, _gid: u32) -&gt; Result&lt;usize&gt; {
        self.vec.extend_from_slice(path.as_bytes());
        Ok(0)
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Say a program calls <code>open("vec:/hello")</code>. That call will work its way through the kernel and end up being dispatched to this function through our <code>Scheme::handle</code> call.</p>
<p>The <code>usize</code> we return here will be passed back to us as the <code>id</code> parameter of the other scheme operations. This way we can keep track of different open files. In this case, we won't make a distinction between two different programs talking to us and simply return zero.</p>
<p>Similarly, when a process opens a file, the kernel returns a number (the file descriptor) that the process can use to read and write to that file. Now let's implement the read and write operations for <code>VecScheme</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl SchemeMut for VecScheme {
    // ...

    // Fill up buf with the contents of self.vec, starting from self.buf[0].
    // Note that this reverses the contents of the Vec.
    fn read(&amp;mut self, _id: usize, buf: &amp;mut [u8]) -&gt; Result&lt;usize&gt; {
        let num_written = min(buf.len(), self.vec.len());

        for b in buf {
            if let Some(x) = self.vec.pop() {
                *b = x;
            } else {
                break;
            }
        }

        Ok(num_written)
    }

    // Simply push any bytes we are given to self.vec
    fn write(&amp;mut self, _id: usize, buf: &amp;[u8]) -&gt; Result&lt;usize&gt; {
        for i in buf {
            self.vec.push(*i);
        }

        Ok(buf.len())
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Note that each of the methods of the <code>SchemeMut</code> trait provide a default implementation. These will all return errors since they are essentially unimplemented. There's one more method we need to implement in order to prevent errors for users of our scheme:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl SchemeMut for VecScheme {
    // ...

    fn close(&amp;mut self, _id: usize) -&gt; Result&lt;usize&gt; {
        Ok(0)
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Most languages' standard libraries call <code>close</code> automatically when a file object is destroyed, and Rust is no exception.</p>
<p>To see all the possible operations on schemes, check out the <a href="https://docs.rs/redox_syscall/">API docs</a>.</p>
<blockquote>
<p>TODO: there is no scheme documentation at this link.</p>
</blockquote>
<h2 id="a-simple-client"><a class="header" href="#a-simple-client">A Simple Client</a></h2>
<p>As mentioned earlier, we need to create a very simple client in order to use our scheme, since some command line tools (like <code>cat</code>) use operations other than open, read, write, and close. Put this code into <code>src/client.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust">use std::fs::File;
use std::io::{Read, Write};

fn main() {
    let mut vec_file = File::open("/scheme/vec/hi")
        .expect("Failed to open vec file");

    vec_file.write(b" Hello")
        .expect("Failed to write to vec");

    let mut read_into = String::new();
    vec_file.read_to_string(&amp;mut read_into)
        .expect("Failed to read from vec");

    println!("{}", read_into); // olleH ih/
}</code></pre></pre>
<p>We simply open some "file" in our scheme, write some bytes to it, read some bytes from it, and then spit those bytes out on stdout. Remember, it doesn't matter what path we use, since all our scheme does is add that path to the vec. In this sense, the vec scheme implements a global vector.</p>
<h2 id="running-the-scheme"><a class="header" href="#running-the-scheme">Running the Scheme</a></h2>
<p>Since we've already set up the program to build and run in QEMU, simply run:</p>
<pre><code class="language-sh">make r.scheme-name image qemu
</code></pre>
<p>We'll need multiple terminal windows open in the QEMU window for this step. Notice that both binaries we defined in our <code>Cargo.toml</code> can now be found in <code>/usr/bin</code> (<code>vec_scheme</code> and <code>vec</code>). In one terminal window, run <code>sudo vec_scheme</code>. A program needs to run as root in order to register a new scheme. In another terminal, run <code>vec</code> and observe the output.</p>
<h2 id="exercises-for-the-reader"><a class="header" href="#exercises-for-the-reader">Exercises for the Reader</a></h2>
<ul>
<li>Make the <code>vec</code> scheme print out something whenever it gets events. For example, print out the user and group IDs of the user who tries to open a file in the scheme.</li>
<li>Create a unique <code>vec</code> for each opened file in your scheme. You might find a hashmap useful for this.</li>
<li>Write a scheme that can run code for your favorite esoteric programming language.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="programs-and-libraries"><a class="header" href="#programs-and-libraries">Programs and Libraries</a></h1>
<ul>
<li>Redox is a general-purpose operating system, thus it can run any type of program.</li>
</ul>
<p>Some programs are interpreted by a runtime for the program's language, such as a script running in the GNU Bash shell or a Python program. Others are compiled into CPU instructions that run on a particular operating system (Redox) and specific hardware (e.g. x86 compatible CPU in 64-bit mode).</p>
<ul>
<li>In Redox, the binaries use the standard <a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format">ELF</a> ("Executable and Linkable Format") format.</li>
</ul>
<p>Programs could directly invoke Redox system calls, but most call library functions that are higher-level and more easy to use. The program is linked with the libraries it needs.</p>
<ul>
<li>Most C/C++ programs call functions in a <a href="https://en.wikipedia.org/wiki/C_standard_library">C Standard Library</a> (libc) such as <code>fopen()</code></li>
<li>Redox includes a Rust implementation of the C Standard Library called <a href="https://gitlab.redox-os.org/redox-os/relibc/">relibc</a>. This is how programs such as Git and Python can run on Redox. relibc has partial <a href="https://en.wikipedia.org/wiki/C_POSIX_library">POSIX compatibility</a>.</li>
<li>relibc has Linux functions for libraries and programs</li>
<li>Rust programs implicitly or explicitly call functions in the <a href="https://doc.rust-lang.org/std/">Rust Standard Library</a>.</li>
<li>The Rust libstd includes an implementation of its system-dependent parts (such as file access and setting environment variables) for Redox, in <code>src/libstd/sys/redox</code>. Most of libstd works in Redox, so many Rust programs can be compiled for Redox.</li>
</ul>
<p>The Redox <a href="https://gitlab.redox-os.org/redox-os/cookbook">Cookbook</a> package system contain recipes (software ports) for compiling C, C++ and Rust programs into Redox binaries.</p>
<p>The porting of programs on Redox is done case-by-case, if a program just need small patches, the programmer can modify the Rust crate source code or add <code>.patch</code> files on the recipe folder, but if big or dirty patches are needed, Redox create a fork of it on GitLab and rebase for a while in the <code>redox</code> branch of the fork (some Redox forks use branches for different versions).</p>
<ul>
<li><a href="https://wiki.osdev.org/How_kernel,_compiler,_and_C_library_work_together">OS Internals Documentation</a></li>
<li><a href="https://wiki.osdev.org/ELF">ELF Documentation</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="components-of-redox"><a class="header" href="#components-of-redox">Components of Redox</a></h1>
<p>Redox is made up of several discrete components.</p>
<h2 id="core"><a class="header" href="#core">Core</a></h2>
<ul>
<li>bootloader - Kernel bootstrap</li>
<li>kernel - System manager</li>
<li>bootstrap - User-space bootstrap</li>
<li>init</li>
<li>initfs</li>
<li>drivers - Device drivers</li>
<li>redoxfS - Filesystem</li>
<li>audiod - Audio daemon</li>
<li>netstack - TCP/UDP stack</li>
<li>ps2d - PS/2 driver</li>
<li>relibc - Redox C library</li>
<li>randd</li>
<li>zerod</li>
<li>ion - Terminal shell</li>
<li>orbital - Desktop environment</li>
</ul>
<h2 id="orbital-1"><a class="header" href="#orbital-1">Orbital</a></h2>
<ul>
<li>orblogin - Login manager</li>
<li>launcher - App panel</li>
<li>background - Wallpaper program</li>
<li>viewer - Image viewer</li>
<li>calculator - Math program</li>
<li>COSMIC Files - File manager</li>
<li>COSMIC Editor - Text editor</li>
<li>COSMIC Terminal - Terminal emulator</li>
<li>COSMIC Reader - Document viewer</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gui"><a class="header" href="#gui">GUI</a></h1>
<p>The desktop environment of Redox (Orbital) is provided by a set of programs that run in user-space.</p>
<ul>
<li>
<p>Orbital - The display server and window manager sets up the <code>orbital:</code> scheme, manages the display, and handles requests for window creation, redraws, and event polling.</p>
</li>
<li>
<p>Launcher - The launcher multi-purpose program that scans the applications in the <code>/apps/</code> directory and provides the following services:</p>
<ul>
<li>Called Without Arguments - A taskbar that displays icons for each application</li>
<li>Called With Arguments - An application chooser that opens a file in a matching program.
<ul>
<li>If one application is found that matches, it will be opened automatically</li>
<li>If more than one application is found, a chooser will be shown</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="ç¨‹å¼"><a class="header" href="#ç¨‹å¼">ç¨‹å¼</a></h3>
<p>The following are GUI utilities that can be found in the <code>/apps/</code> directory.</p>
<ul>
<li>Calculator - A calculator that provides similar functionality to the <code>calc</code> program.</li>
<li>Editor - A simple editor that is similar to Notepad.</li>
<li>File Browser - A file browser that displays icons, names, sizes, and details for files. It uses the <code>launcher</code> command to open files when they are clicked.</li>
<li>Image Viewer - A simple image viewer.</li>
<li>Sodium - A vi-like editor that provides syntax highlighting.</li>
<li>Terminal Emulator - An ANSI terminal emulator that launches the Ion shell by default.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ion"><a class="header" href="#ion">Ion</a></h1>
<p>Ion is a terminal shell and library for shells/command execution in Redox, it's used by default. Ion has it's own manual, which you can find on the <a href="https://doc.redox-os.org/ion-manual/">Ion Manual</a>.</p>
<h2 id="1-the-default-shell-in-redox"><a class="header" href="#1-the-default-shell-in-redox">1. The default shell in Redox</a></h2>
<h3 id="what-is-a-terminal-shell"><a class="header" href="#what-is-a-terminal-shell">What is a terminal shell?</a></h3>
<p>A terminal shell is a layer around the operating system kernel and libraries, that allows users to interact with the operating system. That means a shell can be used on any operating system (Ion runs on both Linux and Redox) or implementation of a standard library as long as the provided API is the same. Shells can either be graphical (GUI) or command-line (CLI).</p>
<h3 id="text-shells"><a class="header" href="#text-shells">Text shells</a></h3>
<p>Text shells are programs that provide interactive user interface with an operating system. A shell reads from users as they type and performs operations according to the input. This is similar to read-eval-print loop (REPL) found in many programming languages (e.g. Python).</p>
<h3 id="typical-unix-shells"><a class="header" href="#typical-unix-shells">Typical Unix shells</a></h3>
<p>Probably the most famous shell is <a href="https://www.gnu.org/software/bash/">GNU Bash</a>, which can be found in the majority of Linux distributions, and also in MacOSX. On the other hand, FreeBSD uses <strong>tcsh</strong> by default.</p>
<p>There are many more shell implementations, but these two form the base of two fundamentally different sets:</p>
<ul>
<li>Bourne shell syntax (bash, sh, zsh)</li>
<li>C shell syntax (csh, tcsh)</li>
</ul>
<p>Of course these two groups are not exhaustive; it is worth mentioning at least the <strong>fish</strong> shell and <strong>xonsh</strong>. These shells are trying to abandon some features of old-school shell to make the language safer and more sane.</p>
<h3 id="fancy-features"><a class="header" href="#fancy-features">Fancy features</a></h3>
<p>Writing commands without any help from the shell would be very exhausting and impossible to use for everyday work. Therefore, most shells (including Ion of course!) include features such as command history, autocompletion based on history or man pages, shortcuts to speed-up typing, etc.</p>
<h2 id="2-a-scripting-language"><a class="header" href="#2-a-scripting-language">2. A scripting language</a></h2>
<p>Ion can also be used to write simple scripts for common tasks or system configuration after startup. It is not meant as a fully-featured programming language, but more like a glue to connect other programs together.</p>
<h3 id="relation-to-terminals"><a class="header" href="#relation-to-terminals">Relation to terminals</a></h3>
<p>Early <a href="https://en.wikipedia.org/wiki/Computer_terminal">terminals</a> were devices used to communicate with large computer systems like <a href="https://en.wikipedia.org/wiki/IBM_mainframe">IBM mainframes</a>. Nowadays Unix-like operating systems usually implement so called virtual terminals (tty stands for teletypewriter ... whoa!) and terminal emulators (e.g. xterm, gnome-terminal).</p>
<p>Terminals are used to read input from a keyboard and display textual output of the shell and other programs running inside it. This means that a terminal converts key strokes into control codes that are further used by the shell. The shell provides the user with a command line prompt (for instance: user name and working directory), line editing capabilities (Ctrl + a,e,u,k...), history, and the ability to run other programs (ls, uname, vim, etc.) according to user's input.</p>
<p>TODO: In Linux we have device files like <code>/dev/tty</code>, how is this concept handled in Redox?</p>
<h1 id="shell"><a class="header" href="#shell">Shell</a></h1>
<p>When Ion is called without "-c", it starts a main loop, which can be found inside <code>Shell.execute()</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>        self.print_prompt();
        while let Some(command) = readln() {
            let command = command.trim();
            if !command.is_empty() {
                self.on_command(command, &amp;commands);
            }
            self.update_variables();
            self.print_prompt();
        }
<span class="boring">}</span></code></pre></pre>
<p><code>self.print_prompt();</code> is used to print the shell prompt.</p>
<p>The <code>readln()</code> function is the input reader. The code can be found in <code>crates/ion/src/input_editor</code>.</p>
<p>The documentation about <code>trim()</code> can be found on the <a href="https://doc.rust-lang.org/std/primitive.str.html#method.trim">libstd documentation</a>. If the command is not empty, the <code>on_command</code> method will be called. Then, the shell will update variables, and reprint the prompt.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn on_command(&amp;mut self, command_string: &amp;str, commands: &amp;HashMap&lt;&amp;str, Command&gt;) {
    self.history.add(command_string.to_string(), &amp;self.variables);

    let mut pipelines = parse(command_string);

    // Execute commands
    for pipeline in pipelines.drain(..) {
        if self.flow_control.collecting_block {
            // TODO move this logic into "end" command
            if pipeline.jobs[0].command == "end" {
                self.flow_control.collecting_block = false;
                let block_jobs: Vec&lt;Pipeline&gt; = self.flow_control
                                               .current_block
                                               .pipelines
                                               .drain(..)
                                               .collect();
                match self.flow_control.current_statement.clone() {
                    Statement::For(ref var, ref vals) =&gt; {
                        let variable = var.clone();
                        let values = vals.clone();
                        for value in values {
                            self.variables.set_var(&amp;variable, &amp;value);
                            for pipeline in &amp;block_jobs {
                                self.run_pipeline(&amp;pipeline, commands);
                            }
                        }
                    },
                    Statement::Function(ref name, ref args) =&gt; {
                        self.functions.insert(name.clone(), Function { name: name.clone(), pipelines: block_jobs.clone(), args: args.clone() });
                    },
                    _ =&gt; {}
                }
                self.flow_control.current_statement = Statement::Default;
            } else {
                self.flow_control.current_block.pipelines.push(pipeline);
            }
        } else {
            if self.flow_control.skipping() &amp;&amp; !is_flow_control_command(&amp;pipeline.jobs[0].command) {
                continue;
            }
            self.run_pipeline(&amp;pipeline, commands);
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>First, <code>on_command</code> adds the commands to the shell history with  <code>self.history.add(command_string.to_string(), &amp;self.variables);</code>.</p>
<p>Then the script will be parsed. The parser code is in <code>crates/ion/src/peg.rs</code>. The parse will return a set of pipelines, with each pipeline containing a set of jobs. Each job represents a single command with its arguments. You can take a look in <code>crates/ion/src/peg.rs</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Pipeline {
    pub jobs: Vec&lt;Job&gt;,
    pub stdout: Option&lt;Redirection&gt;,
    pub stdin: Option&lt;Redirection&gt;,
}
pub struct Job {
    pub command: String,
    pub args: Vec&lt;String&gt;,
    pub background: bool,
}
<span class="boring">}</span></code></pre></pre>
<p>What Happens Next:</p>
<ul>
<li>If the current block is a collecting block (a for loop or a function declaration) and the current command is ended, we close the block:
<ul>
<li>If the block is a for loop we run the loop.</li>
<li>If the block is a function declaration we push the function to the functions list.</li>
</ul>
</li>
<li>If the current block is a collecting block but the current command is not ended, we add the current command to the block.</li>
<li>If the current block is not a collecting block, we simply execute the current command.</li>
</ul>
<p>The code blocks are defined in <code>crates/ion/src/flow_control.rs</code>.</p>
<pre><code class="language-Rust">pub struct CodeBlock {
    pub pipelines: Vec&lt;Pipeline&gt;,
}
</code></pre>
<p>The function code can be found in <code>crates/ion/src/functions.rs</code>.</p>
<p>The execution of pipeline content will be executed in <code>run_pipeline()</code>.</p>
<p>The Command class inside <code>crates/ion/src/main.rs</code> maps each command with a description and a method to be executed. For example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>commands.insert("cd",
                Command {
                    name: "cd",
                    help: "Change the current directory\n    cd &lt;path&gt;",
                    main: box |args: &amp;[String], shell: &amp;mut Shell| -&gt; i32 {
                        shell.directory_stack.cd(args, &amp;shell.variables)
                    },
                });
<span class="boring">}</span></code></pre></pre>
<p><code>cd</code> is described by  <code>"Change the current directory\n    cd &lt;path&gt;"</code>, and when called the method <code>shell.directory_stack.cd(args, &amp;shell.variables)</code> will be used. You can see its code in <code>crates/ion/src/directory_stack.rs</code>.</p>
<!---
Sources:
http://hyperpolyglot.org/unix-shells
http://pubs.opengroup.org/onlinepubs/009695399/utilities/xcu_chap02.html
https://en.wikipedia.org/wiki/Shell_(computing)
http://unix.stackexchange.com/questions/4126/what-is-the-exact-difference-between-a-terminal-a-shell-a-tty-and-a-con
http://xonsh.org/
-->
<div style="break-before: page; page-break-before: always;"></div><h1 id="ç³»çµ±å·¥å…·"><a class="header" href="#ç³»çµ±å·¥å…·">ç³»çµ±å·¥å…·</a></h1>
<h3 id="coreutils"><a class="header" href="#coreutils">coreutils</a></h3>
<p>Coreutils is a collection of basic command line utilities included with Redox (or with Linux, BSD, etc.). This includes programs like <code>ls</code>, <code>cp</code>, <code>cat</code> and various other tools necessary for basic command line interaction.</p>
<p>Redox use the Rust implementation of the GNU Coreutils, <a href="https://github.com/uutils/coreutils">uutils</a>.</p>
<p>Available programs:</p>
<ul>
<li><code>ls</code> - é¡¯ç¤ºç•¶å‰ç›®éŒ„çš„æª”æ¡ˆèˆ‡è³‡æ–™å¤¾ã€‚</li>
<li><code>cp</code> - è¤‡è£½ä¸¦è²¼ä¸Šæª”æ¡ˆæˆ–è³‡æ–™å¤¾ã€‚</li>
<li><code>cat</code> - é¡¯ç¤ºæ–‡å­—æª”çš„è¼¸å‡ºã€‚</li>
<li><code>chmod</code> - Change the permissions of some file or directory.</li>
<li><code>clear</code> - æ¸…ç†çµ‚ç«¯æ©Ÿè¼¸å‡ºã€‚</li>
<li><code>dd</code> - Copies and converts a file.</li>
<li><code>df</code> - Show the disk partitions information.</li>
<li><code>du</code> - Shows disk usage on file systems.</li>
<li><code>env</code> - Displays and modifies environment variables.</li>
<li><code>free</code> - Show the RAM usage.</li>
<li><code>kill</code> - æ®ºæ­»é€²ç¨‹ã€‚</li>
<li><code>ln</code> - å»ºç«‹æª”æ¡ˆé€£çµã€‚</li>
<li><code>mkdir</code> - å»ºç«‹ç›®éŒ„ã€‚</li>
<li><code>ps</code> - é¡¯ç¤ºæ‰€æœ‰åŸ·è¡Œä¸­çš„é€²ç¨‹ã€‚</li>
<li><code>reset</code> - Restart the terminal to allow the command-line input.</li>
<li><code>shutdown</code> - Shutdown the system.</li>
<li><code>sort</code> - Sort, merge, or sequence check text files.</li>
<li><code>stat</code> - Returns data about an inode.</li>
<li><code>tail</code> - Copy the last part of a file.</li>
<li><code>tee</code> - Duplicate the standard output.</li>
<li><code>test</code> - Evaluate expression.</li>
<li><code>time</code> - Count the time that some command takes to finish it's operation.</li>
<li><code>touch</code> - Update the timestamp of some file or folder.</li>
<li><code>uname</code> - Show the system information, like kernel version and architecture type.</li>
<li><code>uptime</code> - Show how much time your system is running.</li>
<li><code>which</code> - Show the path where some program is located.</li>
</ul>
<h3 id="userutils"><a class="header" href="#userutils">userutils</a></h3>
<p>Userutils contains the utilities for dealing with users and groups in Redox OS.</p>
<p>They are heavily influenced by Unix and are, when needed, tailored to specific Redox use cases.</p>
<p>These implementations strive to be as simple as possible drawing particular inspiration by BSD systems. They are indeed small, by choice.</p>
<p>Available programs:</p>
<ul>
<li><code>getty</code> - Used by <code>init(8)</code> to open and initialize the TTY line, read a login name and invoke <code>login(1)</code>.</li>
<li><code>id</code> - Displays user identity.</li>
<li><code>login</code> - Allows users to login into the system</li>
<li><code>passwd</code> - Allows users to modify their passwords.</li>
<li><code>su</code> - Allows users to substitute identity.</li>
<li><code>sudo</code> - Enables users to execute a command as another user.</li>
<li><code>useradd</code> - Add a user</li>
<li><code>usermod</code> - ä¿®æ”¹ä½¿ç”¨è€…è³‡è¨Š</li>
<li><code>userdel</code> - åˆªé™¤ä½¿ç”¨è€…</li>
<li><code>groupadd</code> - Add a user group</li>
<li><code>groupmod</code> - ä¿®æ”¹ç¾¤çµ„è³‡è¨Š</li>
<li><code>groupdel</code> - ç§»é™¤ä½¿ç”¨è€…ç¾¤çµ„</li>
</ul>
<h3 id="extrautils"><a class="header" href="#extrautils">extrautils</a></h3>
<p>Some additional command line tools are included in extrautils, such as <code>less</code>, <code>grep</code>, and <code>dmesg</code>.</p>
<p>Available programs:</p>
<ul>
<li><code>calc</code> - Do math operations.</li>
<li><code>cur</code> - Move terminal cursor keys using <code>vi</code> keybindings.</li>
<li><code>dmesg</code> - Show the kernel message buffer.</li>
<li><code>grep</code> - Search all text matches in some text file.</li>
<li><code>gunzip</code> - Decompress <code>tar.gz</code> archives.</li>
<li><code>gzip</code> - Compress files into <code>tar.gz</code> archives.</li>
<li><code>info</code> - Read Markdown files with help pages.</li>
<li><code>keymap</code> - å»ºç«‹éµç›¤æ˜ å°„ã€‚</li>
<li><code>less</code> - Show the text file content one page at a time.</li>
<li><code>man</code> - é¡¯ç¤ºç¨‹å¼çš„æ‰‹å†Šã€‚</li>
<li><code>mdless</code> - Pager with Markdown support.</li>
<li><code>mtxt</code> - Various text conversions, like lowercase to uppercase.</li>
<li><code>rem</code> - Countdown tool.</li>
<li><code>resize</code> - Print the size of the terminal in the form of shell commands to export the <code>COLUMNS</code> and <code>LINES</code> environment variables.</li>
<li><code>screenfetch</code> - é¡¯ç¤ºç³»çµ±è³‡è¨Šã€‚</li>
<li><code>tar</code> - æ“ç¸± <code>tar</code> å°å­˜æª”ã€‚</li>
<li><code>unzip</code> - æ“ç¸± <code>zip</code> å°å­˜æª”ã€‚</li>
<li><code>watch</code> - Repeat a command every 2 seconds.</li>
</ul>
<h3 id="binutils"><a class="header" href="#binutils">binutils</a></h3>
<p>Binutils contains utilities for manipulating binary files.</p>
<p>Available programs:</p>
<ul>
<li><code>hex</code> - Filter and show files in hexadecimal format.</li>
<li><code>hexdump</code> - Filter and show files in hexadecimal format (better output formatting).</li>
<li><code>strings</code> - Find printable strings in files.</li>
</ul>
<h3 id="contain"><a class="header" href="#contain">contain</a></h3>
<p>This program provides containers (namespaces) on Redox.</p>
<ul>
<li><a href="https://gitlab.redox-os.org/redox-os/contain">å„²å­˜åº«</a></li>
</ul>
<h3 id="acid"><a class="header" href="#acid">acid</a></h3>
<p>The general-purpose test suite of Redox to detect crashes, regressions and race conditions.</p>
<ul>
<li><a href="https://gitlab.redox-os.org/redox-os/acid">å„²å­˜åº«</a></li>
</ul>
<h3 id="resist"><a class="header" href="#resist">resist</a></h3>
<p>The POSIX test suite of Redox to see how much % the system is compliant to the <a href="https://en.wikipedia.org/wiki/POSIX">POSIX</a> specification (more means better compatibility).</p>
<ul>
<li><a href="https://gitlab.redox-os.org/redox-os/resist">å„²å­˜åº«</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting started</a></h1>
<p>Redox is still at experimental/alpha stage, but there are many things that you can do with it, and it's fun to try it out. You can start by downloading and running the latest release. Read the instructions for <a href="./running-vm.html">running in a virtual machine</a> or <a href="./real-hardware.html">running on real hardware</a>.</p>
<p>The <a href="./podman-build.html">Building Redox</a> page has information about configuring your system to build Redox, which is necessary if you want to contribute to the development. The <a href="./advanced-podman-build.html">Advanced Podman Build</a> page gives a look under the hood of the build process to help you maintain your build environment.</p>
<p>By reading the <a href="./build-system-reference.html">Build System</a> page you can have a complete understanding of the build system.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="running-redox-in-a-virtual-machine"><a class="header" href="#running-redox-in-a-virtual-machine">Running Redox in a Virtual Machine</a></h1>
<ul>
<li><a href="running-vm.html#virtualbox-instructions">VirtualBox Instructions</a></li>
<li><a href="running-vm.html#qemu-instructions">QEMU Instructions</a></li>
</ul>
<h2 id="download-the-bootable-images"><a class="header" href="#download-the-bootable-images">Download the bootable images</a></h2>
<p>This section will guide you to download the Redox images.</p>
<p>(You need to use the <code>harddrive.img</code> image variant for QEMU or VirtualBox)</p>
<h3 id="stable-releases"><a class="header" href="#stable-releases">Stable Releases</a></h3>
<p>The bootable images for the 0.9.0 release are located on the <a href="https://static.redox-os.org/releases/0.9.0/x86_64/">build server release folder</a>. To try Redox using a virtual machine such as QEMU or VirtualBox, download the <a href="https://static.redox-os.org/releases/0.9.0/x86_64/redox_demo_x86_64_2024-09-07_1225_harddrive.img.zst">demo</a> variant, check the <a href="https://static.redox-os.org/releases/0.9.0/x86_64/SHA256SUM">SHA256 sum</a> to ensure it has downloaded correctly.</p>
<pre><code class="language-sh">sha256sum $HOME/Downloads/redox_demo_x86_64_*_harddrive.img.zst
</code></pre>
<p>If you have more than one demo image in the <code>Downloads</code> directory, you may need to replace the <code>*</code> symbol with the date of your file.</p>
<p>If the demo variant doesn't boot on your computer, try the <a href="https://static.redox-os.org/releases/0.9.0/x86_64/redox_desktop_x86_64_2024-09-07_1225_harddrive.img.zst">desktop</a> and <a href="https://static.redox-os.org/releases/0.9.0/x86_64/redox_server_x86_64_2024-09-07_1225_harddrive.img.zst">server</a> variants.</p>
<p>Even if the <code>desktop</code> and <code>server</code> variants doesn't work, use the daily images below.</p>
<h3 id="daily-images"><a class="header" href="#daily-images">Daily Images</a></h3>
<p>If you want to test the latest Redox changes you can use our bootable images created each day by opening the <a href="https://static.redox-os.org/img">build server images</a> and downloading your preferred variant. Once the download is complete, check the <a href="https://static.redox-os.org/img/x86_64/SHA256SUM">SHA256 sum</a>.</p>
<p>(Sometimes our daily images can be one week old or more because of breaking changes)</p>
<h2 id="decompression"><a class="header" href="#decompression">Decompression</a></h2>
<p>The Redox images are compressed using the <a href="https://github.com/facebook/zstd">Zstd</a> algorithm, to decompress follow the steps below:</p>
<h3 id="linux-1"><a class="header" href="#linux-1">Linux</a></h3>
<h4 id="gui-1"><a class="header" href="#gui-1">GUI</a></h4>
<ol>
<li>Install <a href="https://gitlab.gnome.org/GNOME/file-roller">GNOME File Roller</a> or <a href="https://apps.kde.org/ark/">KDE Ark</a> (both can be installed from <a href="https://flathub.org/">Flathub</a>)</li>
<li>Open the Redox image and click on the "Extract" button</li>
</ol>
<p>If you are using the GNOME Nautilus or KDE Dolphin file manager, right-click the file and select the option to extract the file.</p>
<h4 id="terminal"><a class="header" href="#terminal">Terminal</a></h4>
<p>Install the Zstd tool and run:</p>
<pre><code class="language-sh">zstd -d $HOME/Downloads/redox_*_x86_64_*_harddrive.img.zst
</code></pre>
<h3 id="windows"><a class="header" href="#windows">Windows</a></h3>
<h4 id="gui-2"><a class="header" href="#gui-2">GUI</a></h4>
<ol>
<li>Install <a href="https://www.7-zip.org/">7-Zip</a></li>
<li>Right-click the Redox image, hover the 7-Zip section and click on the option to extract the file or open the file on 7-Zip and extract</li>
</ol>
<h2 id="virtualbox-instructions"><a class="header" href="#virtualbox-instructions">VirtualBox Instructions</a></h2>
<p>To run Redox in a VirtualBox virtual machine you need to do the following steps:</p>
<ol>
<li>Create a VM with 2048 MB of RAM memory (or less if using a simpler Redox image variant) and 32MB of VRAM (video memory)</li>
<li>Enable Nested Paging</li>
<li>Change the keyboard and mouse interface to PS/2</li>
<li>Change the audio controller to Intel HDA</li>
<li>Disable USB support</li>
<li>Go to the network settings of the VM and change the NIC model to 82540EM</li>
<li>Go to the storage settings of the VM, create an IDE controller and add the Redox bootable image on it</li>
<li>Start the VM!</li>
</ol>
<p>If you want to install Redox on the VM create a VDI disk of 5GB (or less if you are using a simplier Redox image variant).</p>
<h3 id="command-for-the-pre-installed-image"><a class="header" href="#command-for-the-pre-installed-image">Command for the pre-installed image</a></h3>
<p>If you want to do this using the command-line, run the following commands:</p>
<ol>
<li>
<pre><code class="language-sh">VBoxManage createvm --name Redox --register
</code></pre>
</li>
<li>
<pre><code class="language-sh">VBoxManage modifyvm Redox --memory 2048 --vram 32 --nic1 nat --nictype1 82540EM \
--cableconnected1 on --usb off --keyboard ps2 --mouse ps2 --audiocontroller hda \
--audioout on --nestedpaging on
</code></pre>
</li>
<li>
<pre><code class="language-sh">VBoxManage convertfromraw $HOME/Downloads/redox_demo_x86_64_*_harddrive.img harddrive.vdi
</code></pre>
</li>
<li>
<pre><code class="language-sh">VBoxManage storagectl Redox --name SATA --add sata --bootable on --portcount 1
</code></pre>
</li>
<li>
<pre><code class="language-sh">VBoxManage storageattach Redox --storagectl SATA --port 0 --device 0 --type hdd --medium harddrive.vdi
</code></pre>
</li>
<li>
<pre><code class="language-sh">VBoxManage startvm Redox
</code></pre>
</li>
</ol>
<h3 id="command-for-the-live-iso-image"><a class="header" href="#command-for-the-live-iso-image">Command for the Live ISO image</a></h3>
<p>If you want to use the <a href="https://static.redox-os.org/releases/0.9.0/x86_64/redox_demo_x86_64_2024-09-07_1225_livedisk.iso.zst">Live ISO</a> run the following commands:</p>
<ol>
<li>
<pre><code class="language-sh">VBoxManage createvm --name Redox --register
</code></pre>
</li>
<li>
<pre><code class="language-sh">VBoxManage modifyvm Redox --memory 2048 --vram 32 --nic1 nat --nictype1 82540EM \
--cableconnected1 on --usb off --keyboard ps2 --mouse ps2 --audiocontroller hda \
--audioout on --nestedpaging on
</code></pre>
</li>
<li>
<pre><code class="language-sh">VBoxManage storagectl Redox --name SATA --add sata --bootable on --portcount 1
</code></pre>
</li>
<li>
<pre><code class="language-sh">VBoxManage storageattach Redox --storagectl SATA --port 0 --device 0 --type dvddrive --medium $HOME/Downloads/redox_demo_x86_64_*_livedisk.iso
</code></pre>
</li>
<li>
<pre><code class="language-sh">VBoxManage startvm Redox
</code></pre>
</li>
</ol>
<h2 id="qemu-instructions"><a class="header" href="#qemu-instructions">QEMU Instructions</a></h2>
<h3 id="linux-2"><a class="header" href="#linux-2">Linux</a></h3>
<p>If you don't have QEMU installed use one of the following commands on Ubuntu, Debian or PopOS based on the image that you want:</p>
<ul>
<li>x86-32 (i586) and x86-64 images</li>
</ul>
<pre><code class="language-sh">sudo apt-get install qemu-system-x86 qemu-kvm
</code></pre>
<ul>
<li>ARM64 images</li>
</ul>
<pre><code class="language-sh">sudo apt-get install qemu-system-arm qemu-kvm
</code></pre>
<ul>
<li>RISC-V images</li>
</ul>
<pre><code class="language-sh">sudo apt-get install qemu-system-riscv
</code></pre>
<p>Use one of the following commands to run QEMU with a Redox-compatible configuration:</p>
<blockquote>
<p>ğŸ’¡ <strong>Tip:</strong> if you encounter an error with the file name, verify that the name passed into the previous command (i.e., <code>$HOME/Downloads/redox_demo_x86_64_*_harddrive.img</code>) matches the file you downloaded.</p>
</blockquote>
<h4 id="x86-32-i586-image"><a class="header" href="#x86-32-i586-image">x86-32 (i586) image</a></h4>
<ul>
<li>Run QEMU</li>
</ul>
<pre><code>SDL_VIDEO_X11_DGAMOUSE=0 qemu-system-i386 -d cpu_reset,guest_errors -smp 1 -m 2048 \
    -chardev stdio,id=debug,signal=off,mux=on,"" -serial chardev:debug -mon chardev=debug \
    -machine pc -cpu pentium2 -device AC97 -netdev user,id=net0 \
    -device e1000,netdev=net0 -device nec-usb-xhci,id=xhci \
    -drive file=`echo $HOME/Downloads/redox_demo_i586_*_harddrive.img`,format=raw
</code></pre>
<h4 id="x86-64-image"><a class="header" href="#x86-64-image">x86-64 image</a></h4>
<ul>
<li>Run QEMU</li>
</ul>
<pre><code>SDL_VIDEO_X11_DGAMOUSE=0 qemu-system-x86_64 -d cpu_reset,guest_errors -enable-kvm -smp 4 -m 2048 \
    -chardev stdio,id=debug,signal=off,mux=on,"" -serial chardev:debug -mon chardev=debug \
    -machine q35 -cpu host -device ich9-intel-hda -device hda-duplex -netdev user,id=net0 \
    -device e1000,netdev=net0 -device nec-usb-xhci,id=xhci \
    -drive file=`echo $HOME/Downloads/redox_demo_x86_64_*_harddrive.img`,format=raw
</code></pre>
<h4 id="arm64-image"><a class="header" href="#arm64-image">ARM64 image</a></h4>
<ul>
<li>Run QEMU</li>
</ul>
<pre><code>SDL_VIDEO_X11_DGAMOUSE=0 qemu-system-aarch64 -d cpu_reset,guest_errors -smp 4 -m 2048 \
    -chardev stdio,id=debug,signal=off,mux=on,"" -serial chardev:debug -mon chardev=debug \
    -bios /usr/share/AAVMF/AAVMF_CODE.fd -machine virt -cpu max -vga none -device ramfb -netdev user,id=net0 \
    -device e1000,netdev=net0 -device nec-usb-xhci,id=xhci \
    -drive file=`echo $HOME/Downloads/redox_demo_aarch64_*_harddrive.img`,format=raw
</code></pre>
<h4 id="risc-v-image"><a class="header" href="#risc-v-image">RISC-V image</a></h4>
<p>Verify if the QEMU UEFI firmware is installed</p>
<ul>
<li>PFLASH0</li>
</ul>
<pre><code>ls -1 /usr/share/qemu-efi-riscv64/RISCV_VIRT_CODE.fd /usr/share/edk2/riscv/RISCV_VIRT_CODE.fd /usr/share/qemu/edk2-riscv-code.fd /usr/share/qemu-efi-riscv64/RISCV_VIRT_VARS.fd /usr/share/qemu/edk2-riscv-vars.fd
</code></pre>
<ul>
<li>PFLASH1</li>
</ul>
<pre><code>ls -1 /usr/share/qemu-efi-riscv64/RISCV_VIRT_VARS.fd /usr/share/edk2/riscv/RISCV_VIRT_VARS.fd /usr/share/qemu/edk2-riscv-vars.fd
</code></pre>
<p>At least one of each <code>PFLASH</code> command must be present, if the file location present on your system is different from the one used in the command you need to change it.</p>
<ul>
<li>Run QEMU</li>
</ul>
<p>TODO: fix not enough space for firmware error</p>
<pre><code>SDL_VIDEO_X11_DGAMOUSE=0 qemu-system-riscv64 -d cpu_reset,guest_errors -smp 4 -m 2048 \
    -chardev stdio,id=debug,signal=off,mux=on,"" -serial chardev:debug -mon chardev=debug \
    -drive if=pflash,format=raw,unit=0,file=/usr/share/qemu-efi-riscv64/RISCV_VIRT_CODE.fd,readonly=on -drive if=pflash,format=raw,unit=1,file=/usr/share/qemu-efi-riscv64/RISCV_VIRT_VARS.fd -machine virt,acpi=off -cpu max -vga none -device ramfb -audio none -netdev user,id=net0 \
    -device e1000,netdev=net0 -device nec-usb-xhci,id=xhci \
    -drive file=`echo $HOME/Downloads/redox_demo_riscv64gc_*_harddrive.img`,format=raw
</code></pre>
<h3 id="windows-1"><a class="header" href="#windows-1">Windows</a></h3>
<p>To install <strong>QEMU</strong> on Windows, follow the instructions <a href="https://www.qemu.org/download/#windows">here</a>. The installation of <strong>QEMU</strong> will probably not update your command path, so the necessary QEMU command needs to be specified using its full path. Or, you can add the installation folder to your <code>PATH</code> environment variable if you will be using it regularly.</p>
<p>Use one of the following commands to run QEMU with a Redox-compatible configuration:</p>
<h4 id="x86-32-i586-image-1"><a class="header" href="#x86-32-i586-image-1">x86-32 (i586) image</a></h4>
<ul>
<li>Run QEMU</li>
</ul>
<p>TODO: test</p>
<pre><code>"C:\Program Files\qemu\qemu-system-x86.exe" -d cpu_reset,guest_errors -smp 1 -m 2048
-chardev stdio,id=debug,signal=off,mux=on,"" -serial chardev:debug -mon chardev=debug
-machine pc -cpu pentium2 -device AC97 -netdev user,id=net0
-device e1000,netdev=net0 -device nec-usb-xhci,id=xhci -device usb-tablet
-drive file=redox_demo_i586_*_harddrive.img,format=raw
</code></pre>
<h4 id="x86-64-image-1"><a class="header" href="#x86-64-image-1">x86-64 image</a></h4>
<ul>
<li>Run QEMU</li>
</ul>
<p>TODO: test</p>
<pre><code>"C:\Program Files\qemu\qemu-system-x86_64.exe" -d cpu_reset,guest_errors -smp 4 -m 2048
-chardev stdio,id=debug,signal=off,mux=on,"" -serial chardev:debug -mon chardev=debug
-machine pc -cpu host -device ich9-intel-hda -device hda-duplex -netdev user,id=net0
-device e1000,netdev=net0 -device nec-usb-xhci,id=xhci -device usb-tablet
-drive file=redox_demo_x86_64_2024-09-07_1225_harddrive.img,format=raw
</code></pre>
<h4 id="arm64-image-1"><a class="header" href="#arm64-image-1">ARM64 image</a></h4>
<ul>
<li>Run QEMU</li>
</ul>
<p>TODO: test</p>
<pre><code>"C:\Program Files\qemu\qemu-system-aarch64.exe" -d cpu_reset,guest_errors -smp 4 -m 2048
-chardev stdio,id=debug,signal=off,mux=on,"" -serial chardev:debug -mon chardev=debug
-drive -bios "C:\Program Files\qemu\share\edk2-aarch64-code.fd" 
-machine virt -cpu max -vga none -device ramfb -netdev user,id=net0
-device e1000,netdev=net0 -device nec-usb-xhci,id=xhci -device usb-tablet
-drive file=redox_demo_aarch64_*_harddrive.img,format=raw
</code></pre>
<h4 id="risc-v-image-1"><a class="header" href="#risc-v-image-1">RISC-V image</a></h4>
<ul>
<li>Run QEMU</li>
</ul>
<p>TODO: test</p>
<pre><code>"C:\Program Files\qemu\qemu-system-riscv64.exe" -d cpu_reset,guest_errors -smp 4 -m 2048
-chardev stdio,id=debug,signal=off,mux=on,"" -serial chardev:debug -mon chardev=debug
-drive -bios "C:\Program Files\qemu\share\edk2-riscv-code.fd"
-machine virt,acpi=off -cpu max -vga none -device ramfb -audio none -netdev riscv,id=net0
-device e1000,netdev=net0 -device nec-usb-xhci,id=xhci -device usb-tablet
-drive file=redox_demo_riscv64gc_*_harddrive.img,format=raw
</code></pre>
<blockquote>
<p>ğŸ’¡ <strong>Tip:</strong> if you get a filename error, change <code>redox_demo_x86_64_*_harddrive.img</code> to the name of the file you downloaded.</p>
</blockquote>
<blockquote>
<p>ğŸ’¡ <strong>Tip:</strong> if necessary, change <code>"C:\Program Files\qemu\qemu-system-x86_64.exe"</code> to reflect where <strong>QEMU</strong> was installed. The quotes are needed if the path contains spaces.</p>
</blockquote>
<h3 id="using-the-qemu-emulation"><a class="header" href="#using-the-qemu-emulation">Using the QEMU emulation</a></h3>
<p>As the system boots, it will ask you for a screen resolution to use, for example <code>1024x768</code>. After selecting a screen size, the system will complete the boot, start the <strong>Orbital</strong> GUI, and display a Redox login screen. Login as user <code>user</code> with no password. The password for <code>root</code> is <code>password</code>. Use <strong>Ctrl+Alt+G</strong> to toggle the mouse behavior if you need to zoom out or exit the emulation. If your emulated cursor is out of alignment with your mouse position, type <strong>Ctrl+Alt+G</strong> to regain full cursor control, then click on your emulated cursor. <strong>Ctrl+Alt+F</strong> toggles between full screen and window views.</p>
<p>See <a href="./trying-out-redox.html">Trying Out Redox</a> for things to try.</p>
<p>If you want to try Redox in <strong>server</strong> mode, add <code>-nographic -vga none</code> to the command line above. You may wish to switch to the <code>redox_server</code> edition. There are also i586 editions available, although these are not part of the release.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="running-redox-on-real-hardware"><a class="header" href="#running-redox-on-real-hardware">Running Redox on Real Hardware</a></h1>
<p>(You need to use the <code>*livedisk.iso</code> image variant for real hardware)</p>
<p>Since version 0.8.0, Redox can now be installed on certain hard drives and internal SSDs, including some vintage systems. USB devices are not yet supported during run-time, although they can be used for installation and <em>livedisk</em> boot. Check the release notes for additional details on supported hardware. Systems with unsupported devices can still use the <em>livedisk</em> method described below. Ensure you backup your data before trying Redox on your hardware.</p>
<p>Hardware support is limited at the moment, so your milage may vary. Only USB input devices (HID) work. There is a PS/2 driver, which works with the keyboards and touchpads in many (but not all) laptops. For networking, the Realtek and Intel ethernet controllers are currently supported.</p>
<p>On some computers, hardware incompatibilities, e.g. disk driver issues, can slow down Redox performance. This is not reflective of Redox in general, so if you find that Redox is slow on your computer, please try it on a different model for a better experience.</p>
<p>The current ISO image uses a bootloader to load the filesystem into memory (<em>livedisk</em>) and emulates a hard drive. You can use the system in this mode without installing. Although its use of memory is inefficient, it is fully functional and does not require changes to your device. The ISO image is a great way to try out Redox on real hardware.</p>
<h2 id="creating-a-bootable-usb-drive"><a class="header" href="#creating-a-bootable-usb-drive">Creating a Bootable USB Drive</a></h2>
<h3 id="download-an-compressed-iso-image"><a class="header" href="#download-an-compressed-iso-image">Download an Compressed ISO Image</a></h3>
<p>You can obtain a <em>livedisk</em> ISO image either by downloading the <a href="https://static.redox-os.org/releases/0.9.0/x86_64/">latest release</a>, or by <a href="./building-redox.html">building one</a>. The <a href="https://static.redox-os.org/releases/0.9.0/x86_64/redox_demo_x86_64_2024-09-07_1225_livedisk.iso.zst">demo ISO</a> is recommended for most laptops. After downloading completes, check the <a href="https://static.redox-os.org/releases/0.9.0/x86_64/SHA256SUM">SHA256 sum</a>:</p>
<pre><code class="language-sh">sha256sum $HOME/Downloads/redox_demo_x86_64_*_livedisk.iso.zst
</code></pre>
<p>If you have more than one demo image in the <code>Downloads</code> directory, you may need to replace the <code>*</code> symbol with the date of your file.</p>
<p>If the <code>demo</code> variant doesn't boot on your computer, try the <a href="https://static.redox-os.org/releases/0.9.0/x86_64/redox_desktop_x86_64_2024-09-07_1225_livedisk.iso.zst"><code>desktop</code></a> and <a href="https://static.redox-os.org/releases/0.9.0/x86_64/redox_server_x86_64_2024-09-07_1225_livedisk.iso.zst"><code>server</code></a> variants.</p>
<p>If even the <code>desktop</code> and <code>server</code> variants don't work, use the daily images below.</p>
<h4 id="daily-images-1"><a class="header" href="#daily-images-1">Daily Images</a></h4>
<p>If you want to test the latest Redox changes you can use our bootable images created each day by opening the <a href="https://static.redox-os.org/img">build server images</a> and downloading your preferred variant.</p>
<p>(Sometimes our daily images can be one week old or more because of breaking changes) Once the download is complete, check the <a href="https://static.redox-os.org/img/x86_64/SHA256SUM">SHA256 sum</a>.</p>
<h3 id="decompress-the-iso-image"><a class="header" href="#decompress-the-iso-image">Decompress the ISO Image</a></h3>
<p>Downloaded Redox images are compressed using the <a href="https://github.com/facebook/zstd">Zstd</a> algorithm. To decompress an image, follow the appropriate steps below for your system:</p>
<h4 id="linux-gui"><a class="header" href="#linux-gui">Linux (GUI)</a></h4>
<ol>
<li>Install <a href="https://gitlab.gnome.org/GNOME/file-roller">GNOME File Roller</a> or <a href="https://apps.kde.org/ark/">KDE Ark</a> (both can be installed from <a href="https://flathub.org/">Flathub</a>)</li>
<li>Open the Redox image and click on the "Extract" button</li>
</ol>
<p>If you are using the GNOME Nautilus or KDE Dolphin file manager, right-click the file and select the option to extract the file.</p>
<h4 id="linux-terminal"><a class="header" href="#linux-terminal">Linux (Terminal)</a></h4>
<p>Install the Zstd tool and run:</p>
<pre><code class="language-sh">zstd -d $HOME/Downloads/redox_*_x86_64_*_livedisk.iso.zst
</code></pre>
<h4 id="windows-gui"><a class="header" href="#windows-gui">Windows (GUI)</a></h4>
<ol>
<li>Install <a href="https://www.7-zip.org/">7-Zip</a></li>
<li>Right-click the Redox image, hover the 7-Zip section and click on the option to extract the file or open the file on 7-Zip and extract</li>
</ol>
<h3 id="flash-the-iso-image"><a class="header" href="#flash-the-iso-image">Flash the ISO Image</a></h3>
<h4 id="linux-instructions"><a class="header" href="#linux-instructions">Linux Instructions</a></h4>
<p>We recommend using the <a href="https://github.com/pop-os/popsicle">Popsicle</a> tool to flash ISO images to USB devices on Linux. To flash an image, follow the steps below:</p>
<ol>
<li>Open the <a href="https://github.com/pop-os/popsicle/releases/latest">Releases</a> section to open the Popsicle releases page and download the <code>.AppImage</code> file.</li>
<li>Open your file manager, click with the right-button of your mouse on the <code>.AppImage</code> file and open the "Properties", find the "Permissions" section and mark it as executable.</li>
<li>Open the Popsicle <code>.AppImage</code> file, select the downloaded Redox image and your USB device.</li>
<li>Confirm the flash process and wait until the progress bar reach 100%. If the flashing process completes with no errors, the flash was successful.</li>
</ol>
<p>You can now restart your Linux machine and boot into Redox.</p>
<h4 id="windows-instructions"><a class="header" href="#windows-instructions">Windows Instructions</a></h4>
<p>We recommend using the <a href="https://etcher.balena.io/">balenaEtcher</a> tool on Windows to flash your USB device, follow the steps below:</p>
<ol>
<li>Open the <a href="https://etcher.balena.io/">balenaEtcher website</a>, click on the "Download Etcher" button and download the "Etcher for Windows" asset.</li>
<li>Install and open balenaEtcher, select the ISO image of Redox, select the USB device and click on "Flash!"</li>
<li>Confirm the permission to erase the data of your device and wait until the progress bar reach 100%</li>
</ol>
<p>Now you can now restart your Windows system and boot into Redox.</p>
<h2 id="booting-the-system"><a class="header" href="#booting-the-system">Booting the System</a></h2>
<p>Some computers don't come with USB booting enabled, to enable it press the keyboard key to open your UEFI or BIOS setup and allow the booting from USB devices (the name varies from firmware to firmware).</p>
<p>If you don't know the keyboard keys to open your UEFI/BIOS setup or boot menu, press the Esc or F keys (from 1 until 12), if you press the wrong key or got the wrong timing, don't stop your operating system boot process to try again, as it could corrupt your data.</p>
<p>Once the ISO image boots, the system will display the Orbital GUI. Log in as the user named <code>user</code> with no password. The password for <code>root</code> is <code>password</code>.</p>
<p>See <a href="./trying-out-redox.html">Trying Out Redox</a> for things to try.</p>
<p>To switch between Orbital and the console, use the following keys:</p>
<ul>
<li>F1: Display the console log messages</li>
<li>F2: Open a text-only terminal</li>
<li>F3: Return to the Orbital GUI</li>
</ul>
<p>If you want to be able to boot Redox from your HDD or SSD, follow the <a href="./installing.html">Installation</a> instructions.</p>
<p>Redox isn't currently going to replace your existing operating system, but testing is important to help us fix bugs and add features: boot Redox on your computer, and see what works.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installing-redox-on-a-drive"><a class="header" href="#installing-redox-on-a-drive">Installing Redox on a Drive</a></h1>
<p>Once you have <a href="./real-hardware.html#creating-a-bootable-usb-drive">downloaded</a> or <a href="./coding-and-building.html#testing-on-real-hardware">built</a> your ISO image, you can install it to your internal HDD or SSD. <strong>Please back up your system</strong> before attempting to install. Note that at this time (Release 0.8.0), you can't install onto a USB device, or use a USB device for your Redox filesystem, but you can install from it.</p>
<p>After starting your <em>livedisk</em> system from a USB device or CD/DVD, log in as the user named <code>user</code> with an empty password, click on the Redox OS icon in the Orbital bottom bar to open the app menu, then open the "System" app category and click on the "Redox Installer" app.</p>
<p>Of if you want to launch it from the terminal run the following command:</p>
<pre><code class="language-sh">sudo redox_installer_gui
</code></pre>
<p>If you are using the <code>server</code> variant or want to use the TUI interface open a terminal window and type:</p>
<pre><code class="language-sh">sudo redox_installer_tui
</code></pre>
<p>If Redox recognizes your device, it will prompt you to select a device to install on. Choose carefully, as it will erase all the data on that device. Note that if your device is not recognized, it may offer you the option to install on <code>disk/live</code> (the in-memory <em>livedisk</em>). Don't do this, as it will crash Redox.</p>
<p>You will be prompted for a <code>redoxfs password</code>. This is for a encrypted filesystem. Leave the password empty and press Enter if an encrypted filesystem is not required.</p>
<p>Once the installation completes, power off your computer, remove the USB device, power on your computer and you are ready to start using Redox!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="trying-out-redox"><a class="header" href="#trying-out-redox">Trying Out Redox</a></h1>
<p>There are several programs, games, demos and other things to try on Redox. Most of these are not included in the regular Redox build, so you will need to run the <code>demo</code> variant from the list of available Redox images. Currently, Redox does not have Wi-Fi support, so if you need Wi-Fi for some of the things you want to do, you are best to use an Ethernet cable or <a href="./running-vm.html">run Redox in a virtual machine</a>. Most of the suggestions below do not require Internet access.</p>
<p>On the <code>demo</code> variant, click on the Redox symbol in the bottom left corner of the screen. This brings up a menu, which, for the <code>demo</code> variant, includes some games. Feel free to give them a try!</p>
<p>Many of the available commands are in the folders <code>/usr/bin</code> and <code>/ui/bin</code>, which are included in your command path. Open a Terminal window and type <code>ls /usr/bin</code> (or <code>ls /scheme/file/usr/bin</code>) to see some of the available commands.</p>
<blockquote>
<p>ğŸ’¡ <strong>Note:</strong> some of the games listed below are installed in the <code>/usr/games</code> directory, which is not detected in the terminal shell by default. To run these games from the terminal, you may have to specify the path of their executables.</p>
</blockquote>
<h2 id="ç¨‹å¼-1"><a class="header" href="#ç¨‹å¼-1">ç¨‹å¼</a></h2>
<h3 id="ffmpeg"><a class="header" href="#ffmpeg">FFMPEG</a></h3>
<p>ä¸–ç•Œä¸Šæœ€å…ˆé€²çš„å¤šåª’é«”ç¨‹å¼åº«ã€‚</p>
<ul>
<li>åŸ·è¡Œä»¥ä¸‹å‘½ä»¤ä¾†æ’­æ”¾éŸ³è¨Šæª”ï¼š</li>
</ul>
<pre><code class="language-sh">ffplay music-name.mp3
</code></pre>
<p>ï¼ˆæ ¹æ“šæ‚¨çš„æª”æ¡ˆè®Šæ›´éŸ³è¨Šæ ¼å¼ï¼‰</p>
<ul>
<li>åŸ·è¡Œä»¥ä¸‹å‘½ä»¤ä¾†æ’­æ”¾è¦–è¨Šæª”ï¼š</li>
</ul>
<pre><code class="language-sh">ffplay video-name.mp4
</code></pre>
<p>ï¼ˆæ ¹æ“šæ‚¨çš„æª”æ¡ˆè®Šæ›´å½±è¨Šæ ¼å¼ï¼‰</p>
<h3 id="cosmic-æª”æ¡ˆ"><a class="header" href="#cosmic-æª”æ¡ˆ">COSMIC æª”æ¡ˆ</a></h3>
<p>ä¸€æ¬¾ä»¥ Rust ç·¨å¯«çš„é€²éšæª”æ¡ˆç®¡ç†å™¨ï¼Œé¡ä¼¼æ–¼ GNOME Nautilus æˆ– Filesã€‚</p>
<h3 id="cosmic-ç·¨è¼¯å™¨"><a class="header" href="#cosmic-ç·¨è¼¯å™¨">COSMIC ç·¨è¼¯å™¨</a></h3>
<p>An advanced text editor written in Rust, similar to KDE KWrite.</p>
<h3 id="git"><a class="header" href="#git">Git</a></h3>
<p>Git æ˜¯ä¸€æ¬¾ç”¨æ–¼ä¾†æºç¢¼ç®¡ç†çš„å·¥å…·ã€‚</p>
<ul>
<li>åŸ·è¡Œä»¥ä¸‹å‘½ä»¤ä¸‹è¼‰ Git å„²å­˜åº«ï¼š</li>
</ul>
<pre><code class="language-sh">git clone repository-link
</code></pre>
<p>(Replace the "repository-link" part with your repository URL)</p>
<h3 id="rustpython"><a class="header" href="#rustpython">RustPython</a></h3>
<p>RustPython æ˜¯ä¸€æ¬¾ä»¥ Rust ç·¨å¯«çš„ Python 3.11+ ç›´è­¯å™¨ã€‚</p>
<ul>
<li>Run the following command to run your Python script:</li>
</ul>
<pre><code class="language-sh">rustpython script-name.py
</code></pre>
<p>(The <a href="https://pypi.org/">PyPI</a> dependency manager is supported)</p>
<h3 id="é€±æœŸè¡¨"><a class="header" href="#é€±æœŸè¡¨">é€±æœŸè¡¨</a></h3>
<p>é€±æœŸè¡¨ <code>/usr/bin/periodictable</code> æ˜¯ <strong>OrbTk</strong> ä½¿ç”¨è€…ä»‹é¢å·¥å…·çµ„çš„ä¸€å€‹ç¤ºç¯„ã€‚</p>
<h3 id="kibi"><a class="header" href="#kibi">Kibi</a></h3>
<p>Kibi is the default terminal text editor inpisred on GNU Nano but with more features, run the <code>kibi</code> command to use it.</p>
<h3 id="rusthello"><a class="header" href="#rusthello">Rusthello</a></h3>
<p>Rusthello is an advanced Reversi AI, made by <a href="https://github.com/HenryTheCat">HenryTheCat</a>. It is highly concurrent, so this acts as a demonstration of Redox's multithreading capabilities. It supports various AIs, such as brute force, minimax, local optimizations, and hybrid AIs.</p>
<p>åœ¨çµ‚ç«¯æ©Ÿè¦–çª—ä¸­ï¼Œè¼¸å…¥ <code>rusthello</code>ã€‚</p>
<p>Then you will get prompted for various things, such as difficulty, AI setup, and so on. When this is done, Rusthello interactively starts the battle between you and an AI or an AI and an AI.</p>
<h2 id="games-1"><a class="header" href="#games-1">Games</a></h2>
<h3 id="freedoom"><a class="header" href="#freedoom">Freedoom</a></h3>
<p>Freedoom is a first-person shooter in the form of content for a Doom engine. For Redox, we have included the PrBoom engine to run Freedoom. You can read more about Freedoom on the <a href="https://freedoom.github.io/">Freedoom website</a>. PrBoom can be found on the <a href="https://prboom.sourceforge.net/">PrBoom website</a>.</p>
<p>Freedoom can be run by selecting its entry from the "Games" section of the Orbital system menu, or by running either <code>/usr/games/freedoom1</code> or <code>/usr/games/freedoom2</code> from a terminal.</p>
<p>Hit <code>Esc</code> and use the arrow keys to select Options-&gt;Setup-&gt;Key Bindings for keyboard help.</p>
<h3 id="neverball-and-nevergolf"><a class="header" href="#neverball-and-nevergolf">Neverball and Nevergolf</a></h3>
<p>Neverball and Nevergolf are 3D pinball and golf games, respectively. Both can be run from the Orbital system menu, under "Games".</p>
<h3 id="sopwith"><a class="header" href="#sopwith">Sopwith</a></h3>
<p>Sopwith is a game which allows players to pilot a small, virtual plane. The original game was written in 1984 and used PC graphics, but it is now presented to users using the SDL library. To play it, run the <code>sopwith</code> command from a terminal.</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Control Key</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">Comma (<code>,</code>)</td><td style="text-align: left">Pull back</td></tr>
<tr><td style="text-align: left">Slash (<code>/</code>)</td><td style="text-align: left">Push forward</td></tr>
<tr><td style="text-align: left">Dot (<code>.</code>)</td><td style="text-align: left">Flip aircraft</td></tr>
<tr><td style="text-align: left">Space</td><td style="text-align: left">Fire gun</td></tr>
<tr><td style="text-align: left"><code>b</code></td><td style="text-align: left">Drop bomb</td></tr>
</tbody></table>
</div>
<h3 id="syobon-action"><a class="header" href="#syobon-action">Syobon Action</a></h3>
<p>Syobon Action is 2D side-scrolling platformer that you <em>won't</em> enjoy. To play it, run <code>syobonaction</code> from a terminal window. It's recommended that you read the <a href="https://github.com/angelXwind/OpenSyobonAction">GitHub page</a> so you don't blame us.</p>
<h3 id="terminal-games-written-in-rust"><a class="header" href="#terminal-games-written-in-rust">Terminal Games Written in Rust</a></h3>
<p>Also check out some games that have been written in Rust, and use the Terminal Window for simple graphics. In a Terminal window, enter one of the following commands:</p>
<ul>
<li><code>baduk</code> - Baduk/Go</li>
<li><code>dem</code> - Democracy</li>
<li><code>flappy</code> - Flappy Bird clone</li>
<li><code>ice</code> - Ice Sliding Puzzle</li>
<li><code>minesweeper</code> - Minesweeper but it wraps</li>
<li><code>reblox</code> - Tetris-like falling blocks</li>
<li><code>redoku</code> - Sudoku</li>
<li><code>snake</code> - Snake</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tasks"><a class="header" href="#tasks">Tasks</a></h1>
<p>This page contain commands used for common and specific tasks on Redox.</p>
<ul>
<li><a href="tasks.html#hardware">Hardware</a></li>
<li><a href="tasks.html#system">System</a></li>
<li><a href="tasks.html#networking">Networking</a></li>
<li><a href="tasks.html#user">User</a></li>
<li><a href="tasks.html#files-and-folders">Files and Folders</a></li>
<li><a href="tasks.html#media">Media</a></li>
<li><a href="tasks.html#graphics">Graphics</a></li>
</ul>
<!--

This is the template for new tasks

### Task description

```sh
command
```

-->
<h2 id="hardware"><a class="header" href="#hardware">Hardware</a></h2>
<h3 id="é¡¯ç¤º-cpu-è³‡è¨Š"><a class="header" href="#é¡¯ç¤º-cpu-è³‡è¨Š">é¡¯ç¤º CPU è³‡è¨Š</a></h3>
<pre><code class="language-sh">cat /scheme/sys/cpu
</code></pre>
<h2 id="system"><a class="header" href="#system">System</a></h2>
<h3 id="change-current-keyboard-layout-map"><a class="header" href="#change-current-keyboard-layout-map">Change current keyboard layout (map)</a></h3>
<ul>
<li>Show all available layouts</li>
</ul>
<pre><code class="language-sh">inputd --keymaps
</code></pre>
<ul>
<li>Change current layout</li>
</ul>
<pre><code class="language-sh">inputd -K layout-name
</code></pre>
<h3 id="show-system-information"><a class="header" href="#show-system-information">Show system information</a></h3>
<pre><code class="language-sh">uname -a
</code></pre>
<p>Or</p>
<pre><code class="language-sh">screenfetch
</code></pre>
<h3 id="show-memory-ram-information"><a class="header" href="#show-memory-ram-information">Show memory (RAM) information</a></h3>
<pre><code class="language-sh">free -h
</code></pre>
<h3 id="show-storage-information"><a class="header" href="#show-storage-information">Show storage information</a></h3>
<pre><code class="language-sh">df -h
</code></pre>
<h3 id="shutdown-the-computer"><a class="header" href="#shutdown-the-computer">Shutdown the computer</a></h3>
<pre><code class="language-sh">sudo shutdown
</code></pre>
<h3 id="show-all-running-processes"><a class="header" href="#show-all-running-processes">Show all running processes</a></h3>
<pre><code class="language-sh">ps
</code></pre>
<h3 id="show-system-wide-common-programs"><a class="header" href="#show-system-wide-common-programs">Show system-wide common programs</a></h3>
<pre><code class="language-sh">ls /usr/bin
</code></pre>
<h3 id="show-all-schemes"><a class="header" href="#show-all-schemes">Show all schemes</a></h3>
<pre><code class="language-sh">ls /scheme
</code></pre>
<h3 id="show-all-scheme-resources"><a class="header" href="#show-all-scheme-resources">Show all scheme resources</a></h3>
<pre><code class="language-sh">ls /scheme/scheme-name
</code></pre>
<h3 id="show-the-system-log"><a class="header" href="#show-the-system-log">Show the system log</a></h3>
<pre><code class="language-sh">dmesg
</code></pre>
<p>Or</p>
<pre><code class="language-sh">cat /scheme/sys/log
</code></pre>
<h2 id="networking"><a class="header" href="#networking">Networking</a></h2>
<h4 id="show-system-dns-name"><a class="header" href="#show-system-dns-name">Show system DNS name</a></h4>
<pre><code class="language-sh">hostname
</code></pre>
<h4 id="show-all-network-addresses-of-your-system"><a class="header" href="#show-all-network-addresses-of-your-system">Show all network addresses of your system</a></h4>
<pre><code class="language-sh">hostname -I
</code></pre>
<h3 id="ping-a-website-or-ip"><a class="header" href="#ping-a-website-or-ip">Ping a website or IP</a></h3>
<pre><code class="language-sh">ping (website-url/ip-address)
</code></pre>
<h3 id="show-website-information"><a class="header" href="#show-website-information">Show website information</a></h3>
<pre><code class="language-sh">whois https://website-name.com
</code></pre>
<h3 id="download-a-git-repository"><a class="header" href="#download-a-git-repository">Download a Git repository</a></h3>
<pre><code class="language-sh">git clone https://website-name.com/repository-name
</code></pre>
<h3 id="download-a-git-repository-to-the-specified-directory"><a class="header" href="#download-a-git-repository-to-the-specified-directory">Download a Git repository to the specified directory</a></h3>
<pre><code class="language-sh">git clone https://website-name.com/repository-name folder-name
</code></pre>
<h3 id="download-a-file-with-wget"><a class="header" href="#download-a-file-with-wget">Download a file with wget</a></h3>
<pre><code class="language-sh">wget https://website-name.com/file-name
</code></pre>
<h3 id="resume-an-incomplete-download"><a class="header" href="#resume-an-incomplete-download">Resume an incomplete download</a></h3>
<pre><code class="language-sh">wget -c https://website-name.com/file-name
</code></pre>
<h3 id="download-from-multiple-links-in-a-text-file"><a class="header" href="#download-from-multiple-links-in-a-text-file">Download from multiple links in a text file</a></h3>
<pre><code class="language-sh">wget -i file.txt
</code></pre>
<h3 id="download-an-entire-website-and-convert-it-to-work-locally-offline"><a class="header" href="#download-an-entire-website-and-convert-it-to-work-locally-offline">Download an entire website and convert it to work locally (offline)</a></h3>
<pre><code class="language-sh">wget --recursive --page-requisites --html-extension --convert-links --no-parent https://website-name.com
</code></pre>
<h3 id="download-a-file-with-curl"><a class="header" href="#download-a-file-with-curl">Download a file with curl</a></h3>
<pre><code class="language-sh">curl -O https://website-name.com
</code></pre>
<h3 id="download-files-from-multiple-websites-at-once"><a class="header" href="#download-files-from-multiple-websites-at-once">Download files from multiple websites at once</a></h3>
<pre><code class="language-sh">curl -O https://website-name.com/file-name -O https://website2-name.com/file-name
</code></pre>
<h3 id="host-a-website-with-simple-http-server"><a class="header" href="#host-a-website-with-simple-http-server">Host a website with <a href="https://github.com/TheWaWaR/simple-http-server">Simple HTTP Server</a></a></h3>
<ul>
<li>Point the program to the website folder</li>
<li>The Home page of the website should be available on the root of the folder</li>
<li>The Home page should be named as <code>index.html</code></li>
</ul>
<pre><code class="language-sh">simple-http-server -i -p 80 folder-name
</code></pre>
<p>This command will use the port 80 (the certified port for HTTP servers), you can change as you wish.</p>
<h2 id="user"><a class="header" href="#user">User</a></h2>
<h3 id="clean-the-terminal-content"><a class="header" href="#clean-the-terminal-content">Clean the terminal content</a></h3>
<pre><code class="language-sh">clear
</code></pre>
<h3 id="exit-the-terminal-session-current-shell-or-root-privileges"><a class="header" href="#exit-the-terminal-session-current-shell-or-root-privileges">Exit the terminal session, current shell or root privileges</a></h3>
<pre><code class="language-sh">exit
</code></pre>
<h3 id="current-user-on-the-shell"><a class="header" href="#current-user-on-the-shell">Current user on the shell</a></h3>
<pre><code class="language-sh">whoami
</code></pre>
<h3 id="show-the-default-terminal-shell"><a class="header" href="#show-the-default-terminal-shell">Show the default terminal shell</a></h3>
<pre><code class="language-sh">echo $SHELL
</code></pre>
<h3 id="show-your-current-terminal-shell"><a class="header" href="#show-your-current-terminal-shell">Show your current terminal shell</a></h3>
<pre><code class="language-sh">echo $0
</code></pre>
<h3 id="show-your-installed-terminal-shells-active-on-path"><a class="header" href="#show-your-installed-terminal-shells-active-on-path">Show your installed terminal shells (active on $PATH)</a></h3>
<pre><code class="language-sh">cat /etc/shells
</code></pre>
<h3 id="change-your-default-terminal-shell-permanently-common-path-is-usrbin"><a class="header" href="#change-your-default-terminal-shell-permanently-common-path-is-usrbin">Change your default terminal shell permanently (common path is <code>/usr/bin</code>)</a></h3>
<pre><code class="language-sh">chsh -s /path/of/your/shell
</code></pre>
<h3 id="add-an-abbreviation-for-a-command-on-the-ion-shell"><a class="header" href="#add-an-abbreviation-for-a-command-on-the-ion-shell">Add an abbreviation for a command on the Ion shell</a></h3>
<pre><code class="language-sh">alias name='command'
</code></pre>
<h3 id="change-the-user-password"><a class="header" href="#change-the-user-password">Change the user password</a></h3>
<pre><code class="language-sh">passwd user-name
</code></pre>
<h3 id="show-the-commands-history"><a class="header" href="#show-the-commands-history">Show the commands history</a></h3>
<pre><code class="language-sh">history
</code></pre>
<h3 id="show-the-commands-with-the-name-specified-in-history"><a class="header" href="#show-the-commands-with-the-name-specified-in-history">Show the commands with the name specified in history</a></h3>
<pre><code class="language-sh">history name
</code></pre>
<h3 id="change-the-ownership-of-a-file-folder-device-and-mounted-partition-recursively"><a class="header" href="#change-the-ownership-of-a-file-folder-device-and-mounted-partition-recursively">Change the ownership of a file, folder, device and mounted-partition (recursively)</a></h3>
<pre><code class="language-sh">sudo chown -R user-name:group-name directory-name
</code></pre>
<p>Or</p>
<pre><code class="language-sh">chown user-name file-name
</code></pre>
<h3 id="show-system-wide-configuration-files"><a class="header" href="#show-system-wide-configuration-files">Show system-wide configuration files</a></h3>
<pre><code class="language-sh">ls /etc
</code></pre>
<h3 id="show-the-user-configuration-files-of-programs"><a class="header" href="#show-the-user-configuration-files-of-programs">Show the user configuration files of programs</a></h3>
<pre><code class="language-sh">ls ~/.local/share ~/.config
</code></pre>
<h3 id="print-a-text-on-terminal"><a class="header" href="#print-a-text-on-terminal">Print a text on terminal</a></h3>
<pre><code class="language-sh">echo text
</code></pre>
<h3 id="show-the-directory-paths-in-the-path-environment-variable"><a class="header" href="#show-the-directory-paths-in-the-path-environment-variable">Show the directory paths in the <code>PATH</code> environment variable</a></h3>
<pre><code class="language-sh">echo $PATH
</code></pre>
<h3 id="show-the-dynamically-linked-libraries-used-by-a-program"><a class="header" href="#show-the-dynamically-linked-libraries-used-by-a-program">Show the dynamically linked libraries used by a program</a></h3>
<pre><code class="language-sh">ldd program-name
</code></pre>
<h3 id="add-a-new-directory-on-the-path-environment-variable-of-the-ion-shell"><a class="header" href="#add-a-new-directory-on-the-path-environment-variable-of-the-ion-shell">Add a new directory on the <code>PATH</code> environment variable of the Ion shell</a></h3>
<pre><code class="language-sh">TODO
</code></pre>
<h3 id="restore-the-shell-variables-to-default-values"><a class="header" href="#restore-the-shell-variables-to-default-values">Restore the shell variables to default values</a></h3>
<pre><code class="language-sh">reset
</code></pre>
<h3 id="measure-the-time-spent-by-a-program-to-run-a-command"><a class="header" href="#measure-the-time-spent-by-a-program-to-run-a-command">Measure the time spent by a program to run a command</a></h3>
<pre><code class="language-sh">time command
</code></pre>
<h3 id="run-a-executable-file-on-the-current-directory"><a class="header" href="#run-a-executable-file-on-the-current-directory">Run a executable file on the current directory</a></h3>
<pre><code class="language-sh">./
</code></pre>
<h3 id="run-a-non-executable-shell-script"><a class="header" href="#run-a-non-executable-shell-script">Run a non-executable shell script</a></h3>
<pre><code class="language-sh">sh script-name
</code></pre>
<p>Or</p>
<pre><code class="language-sh">bash script-name
</code></pre>
<h2 id="files-and-folders"><a class="header" href="#files-and-folders">Files and Folders</a></h2>
<h3 id="show-files-and-folders-in-the-current-directory"><a class="header" href="#show-files-and-folders-in-the-current-directory">Show files and folders in the current directory</a></h3>
<pre><code class="language-sh">ls
</code></pre>
<h3 id="print-some-text-file"><a class="header" href="#print-some-text-file">Print some text file</a></h3>
<pre><code class="language-sh">cat file-name
</code></pre>
<h3 id="edit-a-text-file"><a class="header" href="#edit-a-text-file">Edit a text file</a></h3>
<pre><code class="language-sh">kibi file-name
</code></pre>
<p>Save your changes by pressing Ctrl+S</p>
<h3 id="show-the-current-directory"><a class="header" href="#show-the-current-directory">Show the current directory</a></h3>
<pre><code class="language-sh">pwd
</code></pre>
<h3 id="change-the-active-directory-to-the-specified-folder"><a class="header" href="#change-the-active-directory-to-the-specified-folder">Change the active directory to the specified folder</a></h3>
<pre><code class="language-sh">cd folder-name
</code></pre>
<h3 id="change-to-the-previous-directory"><a class="header" href="#change-to-the-previous-directory">Change to the previous directory</a></h3>
<pre><code class="language-sh">cd -
</code></pre>
<h3 id="change-to-the-upper-directory"><a class="header" href="#change-to-the-upper-directory">Change to the upper directory</a></h3>
<pre><code class="language-sh">cd ..
</code></pre>
<h3 id="change-the-current-directory-to-the-user-folder"><a class="header" href="#change-the-current-directory-to-the-user-folder">Change the current directory to the user folder</a></h3>
<pre><code class="language-sh">cd ~
</code></pre>
<h3 id="show-files-and-folders-including-the-hidden-ones"><a class="header" href="#show-files-and-folders-including-the-hidden-ones">Show files and folders (including the hidden ones)</a></h3>
<pre><code class="language-sh">ls -A
</code></pre>
<h3 id="show-the-files-folders-and-subfolders"><a class="header" href="#show-the-files-folders-and-subfolders">Show the files, folders and subfolders</a></h3>
<pre><code class="language-sh">ls *
</code></pre>
<h3 id="show-advanced-information-about-the-filesfolders-of-the-directory"><a class="header" href="#show-advanced-information-about-the-filesfolders-of-the-directory">Show advanced information about the files/folders of the directory</a></h3>
<pre><code class="language-sh">ls -l
</code></pre>
<h3 id="create-a-new-folder"><a class="header" href="#create-a-new-folder">Create a new folder</a></h3>
<pre><code class="language-sh">mkdir folder-name
</code></pre>
<h3 id="copy-a-file"><a class="header" href="#copy-a-file">Copy a file</a></h3>
<pre><code class="language-sh">cp -v file-name destination-folder
</code></pre>
<h3 id="copy-a-folder"><a class="header" href="#copy-a-folder">Copy a folder</a></h3>
<pre><code class="language-sh">cp -v folder-name destination-folder
</code></pre>
<h3 id="move-a-folder"><a class="header" href="#move-a-folder">Move a folder</a></h3>
<pre><code class="language-sh">mv folder-name destination-folder
</code></pre>
<h3 id="remove-a-file"><a class="header" href="#remove-a-file">Remove a file</a></h3>
<pre><code class="language-sh">rm file-name
</code></pre>
<h3 id="remove-a-folder"><a class="header" href="#remove-a-folder">Remove a folder</a></h3>
<p>(Use with caution if you called the command with <code>su</code>, <code>sudo</code> or <code>doas</code>)</p>
<pre><code class="language-sh">rm -rf folder-name
</code></pre>
<h3 id="add-text-in-a-text-file"><a class="header" href="#add-text-in-a-text-file">Add text in a text file</a></h3>
<pre><code class="language-sh">echo "text" &gt;&gt; directory/file
</code></pre>
<h3 id="search-for-files"><a class="header" href="#search-for-files">Search for files</a></h3>
<pre><code class="language-sh">find . -type f -name file-name
</code></pre>
<p>(Run with <code>sudo</code> or <code>su</code> if these directories are under root permissions)</p>
<h3 id="search-for-folders"><a class="header" href="#search-for-folders">Search for folders</a></h3>
<pre><code class="language-sh">find . -type d -name folder-name
</code></pre>
<p>(Run with <code>sudo</code> or <code>su</code> if the directories are under root permissions)</p>
<h3 id="show-filesfolders-in-a-tree"><a class="header" href="#show-filesfolders-in-a-tree">Show files/folders in a tree</a></h3>
<pre><code class="language-sh">tree
</code></pre>
<h2 id="media"><a class="header" href="#media">Media</a></h2>
<h3 id="play-a-video"><a class="header" href="#play-a-video">Play a video</a></h3>
<pre><code class="language-sh">ffplay video-name
</code></pre>
<h3 id="play-a-music"><a class="header" href="#play-a-music">Play a music</a></h3>
<pre><code class="language-sh">ffplay music-name
</code></pre>
<h3 id="show-an-image"><a class="header" href="#show-an-image">Show an image</a></h3>
<pre><code class="language-sh">image-viewer image-name
</code></pre>
<h2 id="graphics"><a class="header" href="#graphics">Graphics</a></h2>
<h3 id="show-the-opengl-information"><a class="header" href="#show-the-opengl-information">Show the OpenGL information</a></h3>
<pre><code class="language-sh">glxinfo | grep OpenGL
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="downloading-packages-with-pkg"><a class="header" href="#downloading-packages-with-pkg">Downloading packages with pkg</a></h1>
<p><a href="https://gitlab.redox-os.org/redox-os/pkgutils">pkg</a> is the Redox package manager installing binary packages to a running system. If you want to build packages, or include binary packages during the build, please see the <a href="./including-programs.html">Including Programs in Redox</a> page.</p>
<p>Due to limited device support, you may get better results in an virtual machine than on real hardware.</p>
<p>The most commonly used <code>pkg</code> commands are show below:</p>
<ul>
<li>
<p>Install a package:</p>
<pre><code class="language-sh">sudo pkg install &lt;package-name&gt;
</code></pre>
</li>
<li>
<p>Upgrade all installed packages:</p>
<pre><code class="language-sh">sudo pkg upgrade
</code></pre>
</li>
<li>
<p>List package contents:</p>
<pre><code class="language-sh">pkg list &lt;package-name&gt;
</code></pre>
</li>
<li>
<p>Get a file signature:</p>
<pre><code class="language-sh">pkg sign &lt;package-name&gt;
</code></pre>
</li>
<li>
<p>Download a package:</p>
<pre><code class="language-sh">pkg fetch &lt;package-name&gt;
</code></pre>
</li>
<li>
<p>Clean an extracted package:</p>
<pre><code class="language-sh">pkg clean &lt;package-name&gt;
</code></pre>
</li>
<li>
<p>Create a package:</p>
<pre><code class="language-sh">pkg create &lt;package-name&gt;
</code></pre>
</li>
<li>
<p>Extract a package:</p>
<pre><code class="language-sh">pkg extract &lt;package-name&gt;
</code></pre>
</li>
<li>
<p>Get detailed information about one of the above options:</p>
<pre><code class="language-sh">pkg help &lt;pkg-command&gt;
</code></pre>
</li>
</ul>
<blockquote>
<p>ğŸ“ <strong>Note:</strong> Some <code>pkg</code> commands must be run with <code>sudo</code> because they manipulate the contents of protected folders: <code>/usr/bin</code> and <code>/pkg</code>.</p>
</blockquote>
<p>The available packages can be found on the <a href="https://static.redox-os.org/pkg/">build server list</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contributing"><a class="header" href="#contributing">Contributing</a></h1>
<p>Now that you are ready to contribute to Redox, read our <a href="https://gitlab.redox-os.org/redox-os/redox/-/blob/master/CONTRIBUTING.md">CONTRIBUTING</a> document to guide you.</p>
<p>Please follow our guidelines for <a href="./using-redox-gitlab.html">Using Redox GitLab</a> and our <a href="./best-practices.html">Best Practices</a>.</p>
<p>If you are contributing to Redox, it's important to join us on <a href="./chat.html">Chat</a>. Merge Requests are only reviewed if you post a link in the MRs room on Chat. It's also important to join so you can align with our current efforts and avoid unnecessary work.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chat"><a class="header" href="#chat">Chat</a></h1>
<p>The best way to communicate with the Redox team is on Matrix Chat, to join our chat, you must request an invitation in the <a href="https://matrix.to/#/#redox-join:matrix.org">Join Requests room</a> (this room acts as a guard against spam and bots)</p>
<p>When your invitation is sent, you will receive a notification on Matrix.</p>
<p>After you accept the invitation, you can open the <a href="https://matrix.to/#/#redox:matrix.org">Redox Matrix space</a> and see the rooms that are available.</p>
<p>These rooms are English-only, we cannot offer support in other languages because the maintainers will not be able to verify the correctness of your responses. But if you post translator-generated messages, we will do our best to understand them.</p>
<h2 id="é—œæ–¼-matrix"><a class="header" href="#é—œæ–¼-matrix">é—œæ–¼ Matrix</a></h2>
<p><a href="https://en.wikipedia.org/wiki/Matrix_(protocol)">Matrix</a> is an open chat protocol and has several different <a href="https://matrix.org/ecosystem/clients/">clients</a>. <a href="https://element.io/">Element</a> is a commonly used choice, it works on web browsers, Linux, MacOSX, Windows, Android and iOS.</p>
<h2 id="è¦å‰‡"><a class="header" href="#è¦å‰‡">è¦å‰‡</a></h2>
<p>æˆ‘å€‘éµå¾ª <a href="https://www.rust-lang.org/policies/code-of-conduct">Rust è¡Œç‚ºå®ˆå‰‡</a>ä½œç‚ºèŠå¤©å®¤çš„è¦å‰‡ã€‚</p>
<h3 id="è¨è«–ä¸²"><a class="header" href="#è¨è«–ä¸²">è¨è«–ä¸²</a></h3>
<ul>
<li>If you want to have a big discussion in our Matrix space you should use a thread.</li>
<li>A thread is a list of messages, like a forum topic.</li>
<li>A thread is linked to the original message, but displayed to the side to help improve the visibility of new questions in the main message area.</li>
</ul>
<p>Not all Matrix clients support threads, so if you are not able to see threads in your client, try a different client.</p>
<p>If you are unable to use a client that supports threads, let us know when you ask a question, and we will try to accommodate you as best we can.</p>
<ul>
<li>To start a thread on Element, hover your mouse cursor over the desired message and click on the button with the message icon (a rectangular speech bubble).</li>
<li>To see all threads in a room click on the top-right button with a message icon.</li>
</ul>
<p>We mostly use Element threads but there are other Matrix clients with threads support, like nheko.</p>
<h2 id="the-redox-space"><a class="header" href="#the-redox-space">The Redox Space</a></h2>
<p>All rooms available on the Redox space:</p>
<ul>
<li><a href="https://matrix.to/#/#redox-join:matrix.org">#redox-join:matrix.org</a> - A room to be invited to Redox space.</li>
<li><a href="https://matrix.to/#/#redox-announcements:matrix.org">#redox-announcements:matrix.org</a> - A room for important announcements.</li>
<li><a href="https://matrix.to/#/#redox-general:matrix.org">#redox-general:matrix.org</a> - A room for Redox-related discussions (questions, suggestions, porting, etc).</li>
<li><a href="https://matrix.to/#/#redox-dev:matrix.org">#redox-dev:matrix.org</a> - A room for the development, here you can talk about anything development-related (code, proposals, achievements, styling, bugs, etc).</li>
<li><a href="https://matrix.to/#/#redox-gitlab-updates:matrix.org">#redox-gitlab-updates:matrix.org</a> - GitLab activity notifications room</li>
<li><a href="https://matrix.to/#/#redox-rfcs:matrix.org">#redox-rfcs:matrix.org</a> - A room for system architecture design discussions and brainstorming for RFCs.</li>
<li><a href="https://matrix.to/#/#redox-support:matrix.org">#redox-support:matrix.org</a> - A room for testing and building support (problems, errors, questions).</li>
<li><a href="https://matrix.to/#/#redox-mrs:matrix.org">#redox-mrs:matrix.org</a> - A room to send all ready merge requests without conflicts  (if you have a ready MR to merge, send there).</li>
<li><a href="https://matrix.to/#/#redox-gitlab:matrix.org">#redox-gitlab:matrix.org</a> - A room to send new GitLab accounts for approval.</li>
<li><a href="https://matrix.to/#/#redox-soc:matrix.org">#redox-soc:matrix.org</a> - A room for the Redox Summer Of Code program.</li>
<li><a href="https://matrix.to/#/#redox-board:matrix.org">#redox-board:matrix.org</a> - A room for meetings of the Board of Directors.</li>
<li><a href="https://matrix.to/#/#redox-voip:matrix.org">#redox-voip:matrix.org</a> - A room for voice chat discussions.</li>
<li><a href="https://matrix.to/#/#redox-random:matrix.org">#redox-random:matrix.org</a> - A room for off-topic discussions.</li>
<li><a href="https://matrix.to/#/#redox-memes:matrix.org">#redox-memes:matrix.org</a> - A room for memes.</li>
</ul>
<h3 id="ç–‘é›£æ’è§£"><a class="header" href="#ç–‘é›£æ’è§£">ç–‘é›£æ’è§£</a></h3>
<p>If you don't to deal with the Element problems, try <a href="https://nheko-reborn.github.io/">Nheko</a> or <a href="https://gitlab.gnome.org/World/fractal">Fractal</a>.</p>
<p>If you have connection problems see <a href="https://status.matrix.org/">this</a> website to see if the <code>matrix.org</code> homeserver is normal.</p>
<h4 id="element"><a class="header" href="#element">Element</a></h4>
<ul>
<li>
<p>Threads on Element have some bugs, typically marking messages as still unread, even after you have read them.</p>
</li>
<li>
<p>Element in the web browser does not show new messages in a thread as part of its new message count. It only shows a green or red dot over the Threads icon on the lower left of the display. A red dot means that the message is a reply to you. Click the Threads icon to see which rooms have new thread messages.</p>
</li>
<li>
<p>To display all threads in a room on Element in the web browser, click on the Threads icon on the top right of the display.</p>
</li>
<li>
<p>If the Threads button on the top right has a dot, you may have unread messages on some thread, but this could be wrong.</p>
</li>
<li>
<p>If a thread has a dot to the right, you have unread messages in that thread. Click on the thread to read it.</p>
</li>
<li>
<p>When entering a room where you have previously received replies in a thread, you may hear a notification bell, even though there is no new message.</p>
</li>
<li>
<p>Due to bugs, a thread you have previously read can show a dot and possibly count as unread messages. Click on the thread and make sure you have read it, and  to clear it. If it is still not cleared, click on the "Thread options" <code>...</code> button on the top right and select "Show in room". This will often clear it.</p>
</li>
</ul>
<p>You can also mark an entire room as "Read" by mousing over the room name and selecting "Mark as read" from the "Room options" <code>...</code> button.</p>
<ul>
<li>
<p>After doing the steps above, if you still have problems, try reloading the page.</p>
</li>
<li>
<p>Element uses a cache, but clearing the cache sometimes causes problems, if you have encrypted rooms, like DM rooms, save your encryption keys before clearing your cache or you may lose the room history.</p>
</li>
</ul>
<p>Read the Element documentation to learn more about encryption keys.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="best-practices-and-guidelines"><a class="header" href="#best-practices-and-guidelines">Best Practices and Guidelines</a></h1>
<p>é€™äº›æ˜¯åœ¨ç‚º Redox åšå‡ºè²¢ç»æ™‚éœ€è¦ç‰¢è¨˜çš„ä¸€ç³»åˆ—æœ€ä½³å¯¦è¸ã€‚ä¸€å¦‚æ—¢å¾€ï¼Œè¦å‰‡æ˜¯ç”¨ä¾†æ‰“ç ´çš„ï¼Œä½†é€™äº›ç‰¹å®šè¦å‰‡åœ¨æ±ºå®šæ˜¯å¦åˆä½µæ‚¨çš„è²¢ç»æ™‚èµ·è‘—é—œéµä½œç”¨ã€‚å› æ­¤ï¼Œè«‹å‹™å¿…å˜—è©¦éµå¾ªé€™äº›è¦å‰‡ã€‚</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="literate-programming"><a class="header" href="#literate-programming">Literate programming</a></h1>
<p>Literate programming is an approach to programming where the source code serves equally as:</p>
<ul>
<li>The complete description of the program, that a computer can understand</li>
<li>The program's manual for the human, that an <em>average</em> human can understand</li>
</ul>
<p>Literate programs are written in such a way that humans can read them from front to back, and understand the entire purpose and operation of the program without preexisting knowledge about the programming language used, the architecture of the program's components, or the intended use of the program. As such, literate programs tend to have lots of clear and well-written comments. In extreme cases of literate programming, the lines of "code" intended for humans far outnumbers the lines of code that actually gets compiled!</p>
<p>Tools can be used to generate documentation for human use only based on the original source code of a program. The <code>rustdoc</code> tool is a good example of such a tool. In particular, <code>rustdoc</code> uses comments with three slashes <code>///</code>, with special sections like <code># Examples</code> and code blocks bounded by three backticks. The code blocks can be used to writeout examples or unit tests inside of comments. You can read more about <code>rustdoc</code> on the <a href="https://doc.rust-lang.org/book/ch14-02-publishing-to-crates-io.html#making-useful-documentation-comments">Rust documentation</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="writing-documentation-correctly-tm"><a class="header" href="#writing-documentation-correctly-tm">Writing Documentation Correctly (TM)</a></h1>
<p>Redox çš„æ–‡ä»¶å‡ºç¾åœ¨å…©å€‹åœ°æ–¹ï¼š</p>
<ul>
<li>In the source code</li>
<li>On the website (the Redox Book and online API documentation)</li>
</ul>
<p>Redox functions and modules should use <code>rustdoc</code> annotations where possible, as they can be used to generate online API documentation - this ensures uniform documentation between those two halves. In particular, this is more strictly required for public APIs; internal functions can generally eschew them (though having explanations for any code can still help newcomers to understand the codebase). When in doubt, making code more literate is better, so long as it doesn't negatively affect the functionality. Run <code>rustdoc</code> against any added documentation of this type before submitting them to check for correctness, errors, or odd formatting.</p>
<p>Documentation for the Redox Book generally should not include API documentation directly, but rather cover higher-level overviews of the entire codebase, project, and community. It is better to have information in the Book than not to have it, so long as it is accurate, relevant, and well-written. When writing documentation for the Book, be sure to run <code>mdbook</code> against any changes to test the results before submitting them.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-style"><a class="header" href="#rust-style">Rust Style</a></h1>
<p>Since Rust is a relatively small and new language compared to others like C, there's really only one standard. Just follow the official Rust standards for formatting, and maybe run rustfmt on your changes, until we setup the CI system to do it automatically.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rusting-properly"><a class="header" href="#rusting-properly">Rusting Properly</a></h1>
<p>Some general guidelines:</p>
<ul>
<li>Use <code>std::mem::replace</code> and <code>std::mem::swap</code> when you can.</li>
<li>Use <code>.into()</code> and <code>.to_owned()</code> over <code>.to_string()</code>.</li>
<li>Prefer passing references to the data over owned data. (Don't take <code>String</code>, take <code>&amp;str</code>. Don't take <code>Vec&lt;T&gt;</code> take <code>&amp;[T]</code>).</li>
<li>Use generics, traits, and other abstractions Rust provides.</li>
<li>Avoid using lossy conversions (for example: don't do <code>my_u32 as u16 == my_u16</code>, prefer <code>my_u32 == my_u16 as u32</code>).</li>
<li>Prefer in place (<code>box</code> keyword) when doing heap allocations.</li>
<li>Prefer platform independently sized integer over pointer sized integer (<code>u32</code> over <code>usize</code>, for example).</li>
<li>Follow the usual idioms of programming, such as "composition over inheritance", "let your program be divided in smaller pieces", and "resource acquisition is initialization".</li>
<li>When <code>unsafe</code> is unnecessary, don't use it. 10 lines longer safe code is better than more compact unsafe code!</li>
<li>Be sure to mark parts that need work with <code>TODO</code>, <code>FIXME</code>, <code>BUG</code>, <code>UNOPTIMIZED</code>, <code>REWRITEME</code>, <code>DOCME</code>, and <code>PRETTYFYME</code>.</li>
<li>Use the compiler hint attributes, such as <code>#[inline]</code>, <code>#[cold]</code>, etc. when it makes sense to do so.</li>
<li>Try to banish <code>unwrap()</code> and <code>expect()</code> from your code in order to manage errors properly. Panicking must indicate a bug in the program (not an error you didn't want to manage). If you cannot recover from an error, print a nice error to stderr and exit. Check Rust's book about <a href="https://doc.rust-lang.org/book/error-handling.html">Error Handling</a>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="avoiding-panics"><a class="header" href="#avoiding-panics">Avoiding Panics</a></h1>
<p>Panics should be avoided in kernel, and should only occur in drivers and other services when correct operation is not possible, in which case it should be a call to <code>panic!()</code>.</p>
<p>Please also read the kernel <a href="https://gitlab.redox-os.org/redox-os/kernel/-/blob/master/README.md">README</a> for kernel-specific suggestions.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testing"><a class="header" href="#testing">Testing</a></h1>
<ul>
<li>
<p>It's always better to test boot every time you make a system change, because it is important to see how the OS boots and works after it compiles.</p>
</li>
<li>
<p>Even though Rust is a safety-oriented language, something as unstable and low-level as a work-in-progress operating system will almost certainly have problems in many cases and may completely break on even the slightest critical change.</p>
</li>
<li>
<p>Also, make sure you verified how the unmodified version runs on your machine before making any changes. Else, you won't have anything to compare to, and it will generally just lead to confusion. TLDR: rebuild and test boot often.</p>
</li>
<li>
<p>The real hardware testing is bigger than QEMU testing and thus detect more bugs</p>
</li>
<li>
<p>There's also the <a href="https://gitlab.redox-os.org/redox-os/acid">acid</a> test suite from Redox, to use it run the <code>make rp.acid</code> command from the build system to install the suite in the Redox image, run the <code>cd acid</code> command to go to the <code>acid</code> directory and use the <code>cargo test</code> command to run correctness tests and <code>cargo bench</code> command to run stress tests.</p>
</li>
<li>
<p>The <a href="https://gitlab.redox-os.org/redox-os/relibc/-/tree/master/tests">relibc test suite</a> is used to complement <code>acid</code>, use the <code>make r.relibc-tests-bins</code> command from the build system to run it or the <code>make rp.relibc-tests</code> command to add the source in the Redox image, build (<code>cd relibc-tests</code> and <code>make run</code> commands) and run it (<code>make test</code> command) later inside of Redox for more testing.</p>
</li>
<li>
<p>The <a href="https://sortix.org/os-test/">os-test</a> test suite has the largest number of tests and is the recommended method to test the system, use the <code>make r.os-test-bins</code> command from the build system to run it or the <code>make rp.os-test</code> command to add the source in the Redox image, build (<code>cd os-test</code> and <code>make all</code> commands) and run it (<code>make test</code> command) later inside of Redox for more testing.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ä½¿ç”¨-redox-gitlab"><a class="header" href="#ä½¿ç”¨-redox-gitlab">ä½¿ç”¨ Redox GitLab</a></h1>
<p>The Redox project is hosted here: <a href="https://gitlab.redox-os.org/">Redox GitLab</a>. You can download or clone the Redox source from there. However, if you wish to contribute, you will need a Redox Gitlab account.</p>
<p>This chapter provides an overview of Redox GitLab, how to get access, and how to use it as a Redox contributor.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ç™»å…¥-gitlab"><a class="header" href="#ç™»å…¥-gitlab">ç™»å…¥ GitLab</a></h1>
<h2 id="åŠ å…¥-redox-gitlab"><a class="header" href="#åŠ å…¥-redox-gitlab">åŠ å…¥ Redox GitLab</a></h2>
<p>You don't need to join our GitLab to build Redox, but you will if you want to contribute. Obtaining a Redox account requires approval from a GitLab administrator, because of the high number of spam accounts (bots) that are created on this type of project. To join, first, go to <a href="https://gitlab.redox-os.org/">Redox GitLab</a> and click the Sign In/Register button. Create your User ID and Password. Then, send an message to the <a href="https://matrix.to/#/#redox-gitlab:matrix.org">GitLab Approvals</a> room indicating your GitLab User ID and requesting that your account be approved. Please give a brief statement about what you intend to use the account for. This is mainly to ensure that you are a genuine user.</p>
<p>æ‚¨çš„ GitLab å¸³è™Ÿå¯©æ ¸å¯èƒ½éœ€è¦å¹¾åˆ†é˜æˆ–å¹¾å°æ™‚çš„æ™‚é–“ï¼Œåœ¨æ­¤æœŸé–“ï¼Œæ­¡è¿åŠ å…¥æˆ‘å€‘çš„<a href="./chat.html">èŠå¤©å®¤</a>ï¼Œè®“æˆ‘å€‘çŸ¥é“æ‚¨æ­£åœ¨é€²è¡Œçš„å·¥ä½œã€‚</p>
<h2 id="setting-up-2fa"><a class="header" href="#setting-up-2fa">Setting up 2FA</a></h2>
<p>Your new GitLab account will not require 2 Factor Authentication at the beginning, but it will eventually insist. Some details and options are described in detail <a href="signing-in-to-gitlab.html#2fa-apps">below</a>.</p>
<h2 id="2fa-apps"><a class="header" href="#2fa-apps">2FA Apps</a></h2>
<h3 id="requirements-before-logging-into-gitlab"><a class="header" href="#requirements-before-logging-into-gitlab">Requirements Before Logging Into GitLab</a></h3>
<p>åœ¨ç™»å…¥ä¹‹å‰ï¼Œæ‚¨éœ€è¦ï¼š</p>
<ul>
<li>your web browser open at <a href="https://gitlab.redox-os.org/redox-os/">Redox GitLab</a></li>
<li>your phone</li>
<li>æ‚¨æ‰‹æ©Ÿä¸Šå®‰è£çš„ 2FA æ‡‰ç”¨ç¨‹å¼ã€‚</li>
<li>to add https://gitlab.redox-os.org/redox-os/ as a site in your 2FA App.  Once added and the site listed, underneath you'll see 2 sets of 3 digits, 6 digits in all. i.e. <strong>258 687</strong>. That's the 2FA Verification Code.  It changes every so often around every minute.</li>
</ul>
<h3 id="available-2fa-apps-for-android"><a class="header" href="#available-2fa-apps-for-android">Available 2FA Apps for Android</a></h3>
<p>On Android, you may use:</p>
<ul>
<li>Aegis Authenticator - <a href="https://f-droid.org/en/packages/com.beemdevelopment.aegis">F-Droid</a>/<a href="https://play.google.com/store/apps/details?id=com.beemdevelopment.aegis">Play Store</a></li>
<li><a href="https://play.google.com/store/apps/details?id=com.google.android.apps.authenticator2&amp;hl=en_CA&amp;gl=US">Google Authenticator</a></li>
</ul>
<h3 id="available-2fa-apps-for-iphone"><a class="header" href="#available-2fa-apps-for-iphone">Available 2FA Apps for iPhone</a></h3>
<p>On iPhone iOS, you may use:</p>
<ul>
<li><a href="https://apps.apple.com/us/app/google-authenticator/id388497605">Google Authenticator</a></li>
<li><a href="https://apps.apple.com/us/app/tofu-authenticator/id1082229305">Tofu Authenticator (open-source)</a></li>
<li><a href="https://support.apple.com/guide/iphone/automatically-fill-in-verification-codes-ipha6173c19f/ios">iOS built-in authenticator</a></li>
</ul>
<h3 id="logging-in-with-an-android-phone"><a class="header" href="#logging-in-with-an-android-phone">Logging-In With An Android Phone</a></h3>
<p>Here are the steps:</p>
<ul>
<li>From your computer web browser, open the <a href="https://gitlab.redox-os.org/redox-os/">Redox GitLab</a></li>
<li>é»æ“Šç™»å…¥æŒ‰éˆ•</li>
<li>è¼¸å…¥æ‚¨çš„ä½¿ç”¨è€…åç¨±/é›»å­éƒµä»¶</li>
<li>è¼¸å…¥æ‚¨çš„å¯†ç¢¼</li>
<li>é»æ“Šæäº¤æŒ‰éˆ•</li>
<li>Finally you will be prompted for a 2FA verification code from your phone. Go to your Android phone, go to Google/Aegis Authenticator, find the site gitlab redox and underneith those 6 digits in looking something like <strong>258 687</strong> that's your 2FA code.  Enter those 6 digits into the prompt on your computer.  Click Verify.  Done.  You're logged into Gitlab.</li>
</ul>
<h3 id="ä½¿ç”¨-iphone-ç™»å…¥"><a class="header" href="#ä½¿ç”¨-iphone-ç™»å…¥">ä½¿ç”¨ iPhone ç™»å…¥</a></h3>
<p>Here are the steps:</p>
<ul>
<li>From your computer web browser, open the <a href="https://gitlab.redox-os.org/redox-os/">Redox GitLab</a></li>
<li>é»æ“Šç™»å…¥æŒ‰éˆ•</li>
<li>è¼¸å…¥æ‚¨çš„ä½¿ç”¨è€…åç¨±/é›»å­éƒµä»¶</li>
<li>è¼¸å…¥æ‚¨çš„å¯†ç¢¼</li>
<li>é»æ“Šæäº¤æŒ‰éˆ•</li>
<li>Finally you will be prompted for a 2FA verification code from your phone. Go to your iPhone, go to 2stable/Tofu Authenticator or to your Settings-&gt;Passwords for iOS Authenticator, find the site gitlab redox and underneath those 6 digits in looking something like <strong>258 687</strong> that's your 2FA code.  Enter those 6 digits into the prompt on your computer.  Click Verify.  Done.  You're logged into Gitlab.</li>
</ul>
<h2 id="setting-up-pat"><a class="header" href="#setting-up-pat">Setting up PAT</a></h2>
<p>Personal Access Token (PAT) is a replacement for passwords when authenticating via Git clients. When pushing code to GitLab, you need to create one.</p>
<p>Here are the steps needed to create a PAT after logging in to GitLab:</p>
<ul>
<li>Open <a href="https://gitlab.redox-os.org/-/user_settings/personal_access_tokens">Personal access tokens in User settings</a></li>
<li>Click "Add new Token" at the top right of the page</li>
<li>Enter the token name (can be anything) and expiration date (max is 1 year from today)</li>
<li>Check <code>read_repository</code> and <code>write_repository</code> scopes</li>
<li>Click "Create Token"</li>
<li>Copy the PAT (displayed as masked password) under the section "Your Token"</li>
<li>Save the PAT somewhere safe, like your password manager</li>
</ul>
<p>When doing <code>git push</code>, you'll be asked for username and password. Enter the password from the PAT token you've created. This will happen every time you run <code>git push</code>. To remember it forever, run the command below to store it later in <code>~/.git-credentials</code>:</p>
<pre><code class="language-sh">git config --global credential.helper store
</code></pre>
<p>If you don't like to store it as plain text, it's also possible to save it only in RAM cache:</p>
<pre><code class="language-sh"># &lt;timeout&gt; is how long it will be preserved in memory, defaults to 900 (seconds)
git config --global credential.helper 'cache --timeout=&lt;timeout&gt;'
</code></pre>
<p>If you have lost your PAT, it's OK to create another one.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="å„²å­˜åº«çµæ§‹"><a class="header" href="#å„²å­˜åº«çµæ§‹">å„²å­˜åº«çµæ§‹</a></h1>
<p>The <a href="https://gitlab.redox-os.org/">Redox GitLab</a> consists of a large number of <strong>Projects</strong>, you will find the projects organized as a very large, flat alphabetical list. This is not indicative of the role or importance of the various projects.</p>
<h2 id="redox-å°ˆæ¡ˆ"><a class="header" href="#redox-å°ˆæ¡ˆ">Redox å°ˆæ¡ˆ</a></h2>
<p>The <code>redox</code> project is actually just the root of the build system. It does not contain any of the code that the final Redox image will include. It includes the Makefiles, configuration files, package system and a few scripts to simplify setup and building. The <code>redox</code> project can be found on the <a href="https://gitlab.redox-os.org/redox-os/redox">GitLab repository</a>.</p>
<h2 id="recipes"><a class="header" href="#recipes">Recipes</a></h2>
<p>The many <strong>recipes</strong> that are added into the Redox image are built from the corresponding software sources. The name of a Redox package almost always matches the name of its program or library, although this is not enforced.</p>
<p>The <strong>recipe</strong> contains the instructions to download and build a program, for its inclusion in the Redox image.</p>
<h2 id="cookbook"><a class="header" href="#cookbook">Cookbook</a></h2>
<p>The <code>cookbook</code> system contains the infrastructure for building the Redox recipes, you can find its source code in the <code>src</code> folder and recipes under the <code>recipes</code> folder.</p>
<h2 id="crates"><a class="header" href="#crates">Crates</a></h2>
<p>Some Redox projects are built as Rust crates, and included in Redox recipes using Cargo's dependency management system. Updates to a crate must be pushed to the crate repository in order for it to be included in your build.</p>
<h2 id="forks-tarballs-and-other-sources"><a class="header" href="#forks-tarballs-and-other-sources">Forks, Tarballs and Other Sources</a></h2>
<p>Some recipes obtain their source code from places other than Redox GitLab. The Cookbook system can pull in source from any Git repository URL. It can also obtain tarballs which is most used by C/C++ programs.</p>
<p>In some cases, the Redox GitLab has a fork of another repository, in order to add Redox-specific patches. Where possible, we try to push these changes upstream, but there are some reasons why this might not be feasible.</p>
<h2 id="personal-forks"><a class="header" href="#personal-forks">Personal Forks</a></h2>
<p>When you are contributing to Redox, you are expected to make your changes in a personal fork of the relevant project, then create a Merge Request (PR) to have your changes pulled from your fork into the <code>master</code> or <code>main</code> branches. Note that your personal fork is required to have public visibility.</p>
<p>In some rare situations, e.g. for experimental features or projects with licensing that is not compatible with Redox, a recipe may download sources located in a personal repository. Before using one of these recipes, please check with us on the <a href="./chat.html">chat</a> to understand why the project is set up this way, and do not commit a Redox configuration file containing such a recipe without permission.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="å»ºç«‹åˆé©çš„è‡­èŸ²å ±å‘Š"><a class="header" href="#å»ºç«‹åˆé©çš„è‡­èŸ²å ±å‘Š">å»ºç«‹åˆé©çš„è‡­èŸ²å ±å‘Š</a></h1>
<p>If you identify a problem with the system that has not been identified previously, please create a GitLab Issue. In general, we prefer that you are able to reproduce your problem with the latest build of the system.</p>
<ul>
<li>Make sure the code you are seeing the issue with is up to date with <code>upstream/master</code>. This helps to weed out reports for bugs that have already been addressed.</li>
<li>Search Redox Issues to see if a similar problem has been reported before. Then search outstanding merge requests to see if a fix is pending.</li>
<li>Make sure the issue is reproducible (trigger it several times). Try to identify the minimum number of steps to reproduce it. If the issue happens inconsistently, it may still be worth filing a bug report for it, but indicate approximately how often the bug occurs.</li>
<li>Explain if your problem happens in a virtual machine, real hardware or both. Also say your configuration (default options or customized), if you had the problem on real hardware say your computer model.</li>
<li>If it is a significant problem, join us on the <a href="./chat.html">chat</a> and ask if it is a known problem, or if someone plans to address it in the short term.</li>
<li>Identify the recipe that is causing the issue. If a particular command is the source of the problem, look for a repository on Redox GitLab with the same name. Or, for certain programs such as <code>games</code> or command line utilities, you can search for the package containing the command with <code>grep -rnw COMMAND --include Cargo.toml</code>, where <code>COMMAND</code> is the name of the command causing the problem. The location of the <code>Cargo.toml</code> file can help indicate which recipe contains the command. This is where you should expect to report the issue.</li>
<li>If the problem involves multiple recipes, kernel interactions with other programs, or general build problems, then you should plan to log the issue against the <code>redox</code> repository.</li>
<li>If the problem occurs during build, record the build log using <code>script</code> or <code>tee</code>, e.g.</li>
</ul>
<pre><code class="language-sh">make r.recipe-name 2&gt;&amp;1 | tee recipe-name.log
</code></pre>
<p>If the problem occurs while using the Redox command line, use <code>script</code> in combination with your Terminal window.</p>
<pre><code class="language-sh">tee qemu.log
</code></pre>
<pre><code class="language-sh">make qemu
</code></pre>
<ul>
<li>Wait for Redox to start, then in this window:</li>
</ul>
<pre><code>redox login: user
</code></pre>
<ul>
<li>Execute the commands to demonstrate the bug</li>
<li>Terminate QEMU</li>
</ul>
<pre><code class="language-sh">sudo shutdown
</code></pre>
<ul>
<li>If shutdown does not work (there are known bugs) then</li>
<li>ä½¿ç”¨ QEMU é¸å–®é€€å‡º</li>
<li>Then exit the shell created by script</li>
</ul>
<pre><code class="language-sh">exit
</code></pre>
<ul>
<li>
<p>Join us in the chat.</p>
</li>
<li>
<p>Record build information like:</p>
<ul>
<li>The rust toolchain you used to build Redox
<ul>
<li><code>rustc -V</code> and/or <code>rustup show</code> from your Redox project folder</li>
</ul>
</li>
<li>The commit hash of the code you used
<ul>
<li><code>git rev-parse HEAD</code></li>
</ul>
</li>
<li>The environment you are running Redox in (the "target")
<ul>
<li><code>qemu-system-x86_64 -version</code> or your current hardware configuration, if applicable</li>
</ul>
</li>
<li>The operating system you used to build Redox
<ul>
<li><code>uname -a</code> or an alternative format</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Format your log on the message in Markdown syntax to avoid a flood on the chat, you can see how to do it on the <a href="https://docs.github.com/en/get-started/writing-on-github/getting-started-with-writing-and-formatting-on-github/basic-writing-and-formatting-syntax#quoting-code">GitHub documentation</a>.</p>
</li>
<li>
<p>Make sure that your bug doesn't already have an issue on GitLab. Feel free to ask in the Redox <a href="./chat.html">Chat</a> if you're uncertain as to whether your issue is new.</p>
</li>
<li>
<p>Create a GitLab issue following the template. Non-bug report issues may ignore this template.</p>
</li>
<li>
<p>Once you create the issue don't forget to post the link on the Dev or Support rooms of the chat, because the GitLab email notifications have distractions (service messages or spam) and most developers don't left their GitLab pages open to receive desktop notifications from the web browser (which require a custom setting to receive issue notifications).</p>
</li>
</ul>
<p>By doing this you help us to pay attention to your issues and avoid them to be accidentally forgotten.</p>
<ul>
<li>Watch the issue and be available for questions.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="å»ºç«‹åˆé©çš„æ‹‰å–è«‹æ±‚"><a class="header" href="#å»ºç«‹åˆé©çš„æ‹‰å–è«‹æ±‚">å»ºç«‹åˆé©çš„æ‹‰å–è«‹æ±‚</a></h1>
<p>In order for changes you have made to be added to Redox, or other related projects, it is necessary to have someone review your changes, and merge them into the official repository.</p>
<p>This is done by preparing a feature branch, and submitting a merge request.</p>
<p>For small changes, it is sufficient to just submit a pull request. For larger changes, which may require planning or more extensive review, it is better to start by creating an <a href="./filing-issues.html">issue</a>. This provides a shared reference for proposed changes, and a place to collect discussion and feedback related to it.</p>
<p>The steps given below are for the main Redox project repository - submodules and other projects may vary, though most of the approach is the same.</p>
<h3 id="please-note"><a class="header" href="#please-note">Please note:</a></h3>
<ul>
<li><strong>Once you have marked your MR as ready, don't add new commits.</strong></li>
<li><strong>If you need to add new commits mark the MR as draft again.</strong></li>
</ul>
<h2 id="æº–å‚™æ‚¨çš„åˆ†æ”¯"><a class="header" href="#æº–å‚™æ‚¨çš„åˆ†æ”¯">æº–å‚™æ‚¨çš„åˆ†æ”¯</a></h2>
<ol>
<li>
<p>In an appropriate directory, e.g. <code>~/tryredox</code>, clone the Redox repository to your computer using the following command:</p>
<pre><code class="language-sh">git clone https://gitlab.redox-os.org/redox-os/redox.git --origin upstream --recursive
</code></pre>
</li>
</ol>
<ul>
<li>If you used <code>podman_bootstrap.sh</code> or <code>native_bootstrap.sh</code> scripts (see the <a href="./podman-build.html">Building Redox</a> page), the <code>git clone</code> was done for you and you can skip this step.</li>
<li>You need to create a <a href="./signing-in-to-gitlab.html#setting-up-pat">Personal Access Token</a> for pushing your code into your repository fork later.</li>
</ul>
<ol start="2">
<li>
<p>Change to the newly created redox directory and rebase to ensure you're using the latest changes:</p>
<pre><code class="language-sh">cd redox
</code></pre>
<pre><code class="language-sh">git rebase upstream master
</code></pre>
</li>
<li>
<p>You should have a fork of the repository on GitLab and a local copy on your computer. The local copy should have two remotes; <code>upstream</code> and <code>origin</code>, <code>upstream</code> should be set to the main repository and <code>origin</code> should be your fork. Log into Redox Gitlab and fork the <a href="https://gitlab.redox-os.org/redox-os/redox">build system repository</a> - look for the button in the upper right.</p>
</li>
<li>
<p>Add your fork to your list of Git remotes with:</p>
<pre><code class="language-sh">git remote add origin https://gitlab.redox-os.org/MY_USERNAME/redox.git
</code></pre>
</li>
</ol>
<ul>
<li>Note: If you made an error in your <code>git remote</code> command, use <code>git remote remove origin</code> and try again.</li>
</ul>
<ol start="5">
<li>
<p>Alternatively, if you already have a fork and copy of the repo, you can simply check to make sure you're up-to-date. Fetch the upstream, rebase with local commits, and update the submodules:</p>
<pre><code class="language-sh">git fetch upstream master
</code></pre>
<pre><code class="language-sh">git rebase upstream/master
</code></pre>
<pre><code class="language-sh">git submodule update --recursive --init
</code></pre>
<p>Usually, when syncing your local copy with the master branch, you will want to rebase instead of merge. This is because it will create duplicate commits that don't actually do anything when merged into the master branch.</p>
</li>
<li>
<p>Before you start to make changes, you will want to create a separate branch, and keep the <code>master</code> branch of your fork identical to the main repository, so that you can compare your changes with the main branch and test out a more stable build if you need to. Create a separate branch:</p>
<pre><code class="language-sh">git checkout -b MY_BRANCH
</code></pre>
</li>
<li>
<p>Make your changes and test them.</p>
</li>
<li>
<p>Commit:</p>
<pre><code class="language-sh">git add . --all
</code></pre>
<pre><code class="language-sh">git commit -m "COMMIT MESSAGE"
</code></pre>
<p>Commit messages should describe their changes in present-tense, e.g. "<code>Add stuff to file.ext</code>" instead of "<code>added stuff to file.ext</code>". Try to remove duplicate/merge commits from PRs as these clutter up history, and may make it hard to read.</p>
</li>
<li>
<p>Optionally run <a href="https://github.com/rust-lang/rustfmt">rustfmt</a> on the files you changed and commit again if it did anything (check with <code>git diff</code> first).</p>
</li>
<li>
<p>Test your changes with <code>make qemu</code> or <code>make virtualbox</code></p>
</li>
<li>
<p>Pull from upstream:</p>
<pre><code class="language-sh">git fetch upstream
</code></pre>
<pre><code class="language-sh">git rebase upstream/master
</code></pre>
</li>
</ol>
<ul>
<li>Note: try not to use <code>git pull</code>, it is equivalent to doing <code>git fetch upstream; git merge master upstream/master</code></li>
</ul>
<ol start="12">
<li>
<p>Repeat step 10 to make sure the rebase still builds and starts.</p>
</li>
<li>
<p>Push your changes to your fork:</p>
<pre><code class="language-sh">git push origin MY_BRANCH
</code></pre>
</li>
</ol>
<h2 id="æäº¤åˆä½µè«‹æ±‚"><a class="header" href="#æäº¤åˆä½µè«‹æ±‚">æäº¤åˆä½µè«‹æ±‚</a></h2>
<ol>
<li>On <a href="https://gitlab.redox-os.org/">Redox GitLab</a>, create a Merge Request, following the template. Explain your changes in the title in an easy way and write a short statement in the description if you did multiple changes. <strong>Submit!</strong></li>
<li>Once your merge request is ready, notify reviewers by sending the link to the <a href="https://matrix.to/#/#redox-mrs:matrix.org">Redox Merge Requests</a> room.</li>
</ol>
<h2 id="incorporating-feedback"><a class="header" href="#incorporating-feedback">Incorporating feedback</a></h2>
<p>Sometimes a reviewer will request modifications. If changes are required:</p>
<ol>
<li>
<p>Reply or add a thread to the original merge request notification in the <a href="https://matrix.to/#/#redox-mrs:matrix.org">Redox Merge Requests</a> room indicating that you intend to make additional changes.</p>
<p><strong>Note</strong>: It's best to avoid making large changes or additions to a merge request branch, but if necessary, please indicate in chat that you will be making significant changes.</p>
</li>
<li>
<p>Mark the merge request as "Draft" before pushing any changes to the branch being reviewed.</p>
</li>
<li>
<p>Make any necessary changes.</p>
</li>
<li>
<p>Reply on the same thread in the <a href="https://matrix.to/#/#redox-mrs:matrix.org">Redox Merge Requests</a> room that your merge request is now ready.</p>
</li>
<li>
<p>Mark the merge request as "Ready"</p>
</li>
</ol>
<p>This process communicates that the branch may be changing, and prevents reviewers from expending time and effort reviewing changes that are still in progress.</p>
<h2 id="using-gitlab-web-interface"><a class="header" href="#using-gitlab-web-interface">Using GitLab web interface</a></h2>
<ul>
<li>Update your fork before new changes (click on the button to update the branch in the fork page)</li>
</ul>
<ol>
<li>Fork the repository that you want and click in the "Web IDE" button inside the "Code" blue button.</li>
<li>If you have many changes and prefer a faster review create a branch for each part of the changes by clicking in the button named as "master" or "main" in the bottom left position</li>
<li>Make your changes in the files and click in the "Source Control" button on the left side.</li>
<li>Explain your commits and apply</li>
<li>After the first commit creation a pop-up window will appear suggesting to create a MR, if your changes are ready click on the "Create MR" button.</li>
<li>If you want to make more changes continue in the IDE, once you finish to create commits return to the fork page and reload it</li>
<li>Click on the "Create merge request" button that will appear</li>
<li>Explain your changes and create the MR (you can squash your commits if their names don't contain relevant information)</li>
<li>If your merge request is ready send the link in the <a href="https://matrix.to/#/#redox-mrs:matrix.org">Redox Merge Requests</a> room.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gitlab-è­°é¡Œ"><a class="header" href="#gitlab-è­°é¡Œ">GitLab è­°é¡Œ</a></h1>
<p>GitLab issues are a formal way to communicate with Redox developers. They are best used to document and discuss specific features or to provide detailed bug reports. This communication is preserved and available for later reference.</p>
<p>For problems that can be quickly resolved, or require a quick response, using the <a href="./chat.html">chat</a> is probably better.</p>
<p>Once you create an issue don't forget to post the link on the Dev or Support rooms of the chat, because the GitLab email notifications have distractions (service messages or spam) and most developers don't left their GitLab pages open to receive desktop notifications from the web browser (which require a custom setting to receive issue notifications).</p>
<p>By doing this you help us to pay attention to your issues and avoid them to be accidentally forgotten.</p>
<p>If you haven't joined the chat yet, you should (if at all interested in contributing)!</p>
<p>Please follow the <a href="./creating-proper-bug-reports.html">Guidelines</a> for your issues, if applicable. You will need a Redox GitLab account. See <a href="./signing-in-to-gitlab.html">Signing in to GitLab</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-build-process"><a class="header" href="#the-build-process">The Build Process</a></h1>
<p>This chapter will cover the advanced build process of Redox.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="building-redox"><a class="header" href="#building-redox">Building Redox</a></h1>
<p>Congrats on making it this far! Now you will build Redox. This process is for <strong>x86-64</strong> machines (Intel/AMD). There are also similar processes for <a href="./i686.html">i586</a> and <a href="./aarch64.html">AArch64/ARM64</a>.</p>
<p>The build process fetches files from the Redox Gitlab server. From time to time, errors may occur which may result in you being asked to provide a username and password during the build process. If this happens, first check for typos in the <code>git</code> URL. If that doesn't solve the problem and you don't have a Redox GitLab login, try again later, and if it continues to happen, you can let us know through the <a href="./chat.html">chat</a>.</p>
<p>To avoid bugs from different build environments (operating systems) we are using <strong>Rootless Podman</strong> for major parts of the build. <strong>Podman</strong> is invoked automatically and transparently within the Makefiles.</p>
<p>The TL;DR version is <a href="podman-build.html#tldr---new-or-existing-working-directory">here</a>. More details are available in the <a href="./advanced-podman-build.html">Advanced Podman Build</a> page.</p>
<p>You can find out more about Podman on the <a href="https://docs.podman.io/en/latest/Introduction.html">Podman documentation</a>.</p>
<p>(Don't forget to read the <a href="./build-system-reference.html">Build System</a> page to know our build system organization and how it works)</p>
<h2 id="podman-build-overview"><a class="header" href="#podman-build-overview">Podman Build Overview</a></h2>
<p><strong>Podman</strong> is a <strong>container manager</strong> that creates <strong>containers</strong> to execute a Linux distribution <strong>image</strong>. In our case, we are creating an <strong>Debian</strong> image, with a <strong>Rust</strong> installation and all the dependencies needed to build the system and programs.</p>
<p>The build process is performed in your normal working directory, e.g., <code>~/tryredox/redox</code>. Compilation of the Redox components is performed in the container, but the final Redox image (<code>build/$ARCH/$CONFIG/harddrive.img</code> or <code>build/$ARCH/$CONFIG/livedisk.iso</code>) is constructed using <a href="https://github.com/libfuse/libfuse">FUSE</a> running directly on your host machine.</p>
<p>Setting <code>PODMAN_BUILD</code> to 1 in <a href="./configuration-settings.html#config">.config</a>, on the <code>make</code> command line (e.g., <code>make PODMAN_BUILD=1 all</code>) or in the environment (e.g., <code>export PODMAN_BUILD=1; make all</code>) will enable Podman.</p>
<p>First, a <strong>base image</strong> called <code>redox_base</code> will be constructed, with all the necessary packages for the build system. A "home" directory will also be created in <code>build/podman</code>. This is the home directory of your container alter ego, <code>poduser</code>. It will contain the <code>rustup</code> install, and the <code>.bashrc</code>. This takes some time, but is only done when necessary. The <em>tag</em> file <a href="./advanced-podman-build.html#buildcontainertag">build/container.tag</a> is also created at this time to prevent unnecessary image builds.</p>
<p>Then, various <code>make</code> commands are executed in <strong>containers</strong> built from the <strong>base image</strong>. The files are constructed in your working directory tree, just as they would for a non-Podman build. In fact, if all necessary packages are installed on your host system, you can switch Podman on and off relatively seamlessly, although there is no benefit of doing so.</p>
<p>The build process is using <strong>Podman</strong>'s <code>keep-id</code> feature, which allows your regular User ID to be mapped to <code>poduser</code> in the container. The first time a container is built, it takes some time to set up this mapping. After the first container is built, new containers can be built almost instantly.</p>
<h2 id="tldr---new-or-existing-working-directory"><a class="header" href="#tldr---new-or-existing-working-directory">TL;DR - <a href="podman-build.html#new-working-directory">New</a> or <a href="podman-build.html#existing-working-directory">Existing</a> Working Directory</a></h2>
<h3 id="new-working-directory"><a class="header" href="#new-working-directory">New Working Directory</a></h3>
<p>If you have already read the <a href="./building-redox.html">Building Redox</a> instructions, but you wish to use <strong>Podman Build</strong>, follow these steps:</p>
<ol>
<li>
<p>Ensure you have the <code>curl</code> program installed. e.g., for Pop!_OS/Ubuntu/Debian:</p>
<pre><code class="language-sh">which curl || sudo apt-get install curl 
</code></pre>
</li>
<li>
<p>Create a new directory and run <code>podman_bootstrap.sh</code> inside of it. This will clone the repository and install <strong>Podman</strong>.</p>
<pre><code class="language-sh">mkdir -p ~/tryredox
</code></pre>
<pre><code class="language-sh">cd ~/tryredox
</code></pre>
<pre><code class="language-sh">curl -sf https://gitlab.redox-os.org/redox-os/redox/raw/master/podman_bootstrap.sh -o podman_bootstrap.sh
</code></pre>
<pre><code class="language-sh">time bash -e podman_bootstrap.sh
</code></pre>
<p>You may be asked which QEMU installation you want. Please select <code>full</code>.</p>
<p>You may be asked which Podman container runtime you want to use, <code>crun</code> or <code>runc</code>. Choose <code>crun</code>, but <code>runc</code> will also work.</p>
</li>
<li>
<p>Update your path to include <code>cargo</code> and the Rust compiler.</p>
<pre><code class="language-sh">source ~/.cargo/env
</code></pre>
</li>
<li>
<p>Navigate to the <code>redox</code> directory.</p>
<pre><code class="language-sh">cd ~/tryredox/redox
</code></pre>
</li>
<li>
<p>Build the system. This will take some time.</p>
<pre><code class="language-sh">time make all
</code></pre>
</li>
</ol>
<ul>
<li>If the command ask your to choose an image repository select the first item, it will give an error and you need to run the <code>time make all</code> command again</li>
</ul>
<h3 id="existing-working-directory"><a class="header" href="#existing-working-directory">Existing Working Directory</a></h3>
<p>If you already have the build system, simply perform the following steps:</p>
<ol>
<li>
<p>Change to your working directory</p>
<pre><code class="language-sh">cd ~/tryredox/redox
</code></pre>
</li>
<li>
<p>Update the build system and wipe all binaries</p>
<pre><code class="language-sh">make clean pull
</code></pre>
</li>
<li>
<p>Install Podman. If your Linux distribution is not supported, check the <a href="./advanced-podman-build.html#installation">installation instructions</a> to determine which dependencies are needed. Or, run the following in your <code>redox</code> base` directory:</p>
<pre><code class="language-sh">./podman_bootstrap.sh -d
</code></pre>
</li>
<li>
<p>Enable Podman.</p>
<pre><code class="language-sh">nano .config
</code></pre>
<pre><code>PODMAN_BUILD?=1
</code></pre>
<blockquote>
<p>ğŸ“ <strong>Note:</strong> the initial container setup for the Podman build can take 15 minutes or more, but it is comparable in speed to native build after that.</p>
</blockquote>
</li>
<li>
<p>Build the Redox image.</p>
<pre><code class="language-sh">make all
</code></pre>
</li>
</ol>
<h3 id="run-in-a-virtual-machine"><a class="header" href="#run-in-a-virtual-machine">Run in a virtual machine</a></h3>
<p>You can immediately run the new image (<code>build/x86_64/desktop/harddrive.img</code>) in a virtual machine with the following command:</p>
<pre><code class="language-sh">make qemu
</code></pre>
<blockquote>
<p>ğŸ“ <strong>Note:</strong> if you are building the system using <code>build.sh</code> to change the CPU architecture or filesystem contents, you can also provide the <code>qemu</code> option to run the virtual machine:</p>
<pre><code class="language-sh">./build.sh -a i586 -c demo qemu
</code></pre>
<p>This will build <code>build/i586/demo/harddrive.img</code> (if it doesn't already exist) and run it in the QEMU emulator.</p>
</blockquote>
<p>The emulator will display the Redox GUI (Orbital). See <a href="./running-vm.html#using-the-emulation">Using the emulation</a> for general instructions and <a href="./trying-out-redox.html">Trying out Redox</a> for things to try.</p>
<h4 id="run-without-a-gui"><a class="header" href="#run-without-a-gui">Run without a GUI</a></h4>
<p>To run the virtual machine without a GUI, use:</p>
<pre><code class="language-sh">make qemu gpu=no
</code></pre>
<p>If you want to capture the terminal output, read the <a href="./troubleshooting.html#debug-methods">Debug Methods</a> section.</p>
<blockquote>
<p>ğŸ’¡ <strong>Tip:</strong> if you encounter problems running the virtual machine, try turning off various virtualization features with <code>make qemu kvm=no</code> or <code>make qemu iommu=no</code>. These same arguments can also be used with <code>build.sh</code>.</p>
</blockquote>
<h4 id="qemu-tap-for-network-testing"><a class="header" href="#qemu-tap-for-network-testing">QEMU Tap For Network Testing</a></h4>
<p>Expose Redox to other computers within a LAN. Configure QEMU with a "TAP" which will allow other computers to test Redox client/server/networking capabilities.</p>
<p>Please join the <a href="./chat.html">chat</a> if this is something you are interested in pursuing.</p>
<h3 id="building-a-redox-bootable-image"><a class="header" href="#building-a-redox-bootable-image">Building A Redox Bootable Image</a></h3>
<p>Read the <a href="./coding-and-building.html#testing-on-real-hardware">Testing on Real Hardware</a> section.</p>
<h2 id="contributor-note"><a class="header" href="#contributor-note">Contributor Note</a></h2>
<p>If you intend to contribute to Redox or its subprojects, please read the <a href="https://gitlab.redox-os.org/redox-os/redox/-/blob/master/CONTRIBUTING.md">CONTRIBUTING</a> document to understand how the Redox build system works, and how to set up your repository fork appropriately. You can use <code>./bootstrap.sh -d</code> in the <code>redox</code> folder to install the prerequisite packages if you have already done a <code>git clone</code> of the sources.</p>
<p>If you encounter any bugs, errors, obstructions, or other annoying things, please join the <a href="./chat.html">chat</a> or <a href="./creating-proper-bug-reports.html">report the issue</a> to the <a href="https://gitlab.redox-os.org/redox-os/redox">build system repository</a> or a proper repository for the component. Thanks!</p>
<h3 id="buildsh"><a class="header" href="#buildsh">build.sh</a></h3>
<p><code>build.sh</code> is a shell script for quickly invoking <code>make</code> for a specified variant, CPU architecture, and output file.</p>
<blockquote>
<p>ğŸ’¡ <strong>Tip:</strong> for doing Redox development, such settings should usually be configured in the <code>.config</code> file (see the <a href="./configuration-settings.html">Configuration Settings</a> page). But for users who are just trying things out, the <code>build.sh</code> script can be used to run <code>make</code> for you.</p>
</blockquote>
<h4 id="example-1"><a class="header" href="#example-1">Example 1</a></h4>
<p>The following builds the <code>server</code> variant of Redox for the <code>i586</code> (32-bit Intel/AMD) CPU architecture (defined in <code>config/i586/server.toml</code>):</p>
<pre><code>./build.sh -a i586 -c server live
</code></pre>
<p>The resulting image is <code>build/i586/server/livedisk.iso</code>, which can be used to install Redox from a USB device.</p>
<h4 id="example-2"><a class="header" href="#example-2">Example 2</a></h4>
<p>The following builds the <code>desktop</code> variant of Redox for the <code>aarch64</code> (64-bit ARM) CPU architecture (defined in <code>config/aarch64/desktop.toml</code>).</p>
<pre><code>./build.sh -f config/aarch64/desktop.toml qemu
</code></pre>
<p>The resulting image is <code>build/aarch64/desktop/harddrive.img</code>, which is then run in the QEMU emulator upon completion of the build.</p>
<blockquote>
<p>ğŸ’¡ <strong>Tip:</strong> if you are going to use <code>build.sh</code> repeatedly, it's recommended that you do so <em>consistently</em>. The script's underlying <code>make</code> command doesn't keep any record of the build settings used between <code>build.sh</code> runs.</p>
</blockquote>
<p>Details of <code>build.sh</code> and other settings are described in the <a href="./configuration-settings.html">Configuration Settings</a> page.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="native-build"><a class="header" href="#native-build">Native Build</a></h1>
<p>This page explains how to build Redox in your operating system's native environment, without Podman.</p>
<blockquote>
<p>âš ï¸ <strong>Warning:</strong> Building outside Podman is not guaranteed to succeed. Unless you have problems using Podman, we recommend you to use the <a href="./podman-build.html">Podman Build</a> before trying the Native Build to avoid build environment bugs.</p>
</blockquote>
<blockquote>
<p>ğŸ“ <strong>Note:</strong> Read the <a href="./build-system-reference.html">Build System Reference</a> page after installation for an explanation of the build system's organization and functionality.</p>
</blockquote>
<h2 id="supported-unix-like-distributions-and-podman-build"><a class="header" href="#supported-unix-like-distributions-and-podman-build">Supported Unix-like Distributions and Podman Build</a></h2>
<p>The following Unix-like systems are supported:</p>
<ul>
<li>Pop_OS!</li>
<li>Ubuntu</li>
<li>Debian</li>
<li>Fedora</li>
<li>Arch Linux</li>
<li>OpenSUSE</li>
<li>Gentoo</li>
<li>FreeBSD (experimental)</li>
<li>MacOS (experimental, require <a href="./advanced-build.html#macos-users">workarounds</a>)</li>
<li>Nix (experimental)</li>
<li>Solus (not maintained)</li>
</ul>
<p>If you encounter a weird or difficult-to-fix problem, test the <a href="./podman-build.html">Podman Build</a> to determine if the problem occurs there as well.</p>
<h2 id="preparing-the-build"><a class="header" href="#preparing-the-build">Preparing the Build</a></h2>
<h3 id="bootstrap-prerequisites-and-fetch-sources"><a class="header" href="#bootstrap-prerequisites-and-fetch-sources">Bootstrap Prerequisites and Fetch Sources</a></h3>
<p>On supported Linux distributions, build system preparation can be performed automatically via the build system's bootstrap script:</p>
<ol>
<li>
<p>Ensure you have the <code>curl</code> program installed. e.g., for Pop!_OS/Ubuntu/Debian:</p>
<pre><code class="language-sh">which curl || sudo apt-get install curl
</code></pre>
</li>
<li>
<p>Create a new directory and run the <code>native_bootstrap.sh</code> script in it.</p>
<pre><code class="language-sh">mkdir -p ~/tryredox
</code></pre>
<pre><code class="language-sh">cd ~/tryredox
</code></pre>
<pre><code class="language-sh">curl -sf https://gitlab.redox-os.org/redox-os/redox/raw/master/native_bootstrap.sh -o native_bootstrap.sh
</code></pre>
<pre><code class="language-sh">time bash -e native_bootstrap.sh
</code></pre>
<p>You will be asked to confirm some steps: answer with <code>y</code> or <code>1</code>.</p>
<p>For an explanation of what the <code>native_bootstrap.sh</code> script does, read <a href="./build-phases.html#native_bootstrapsh">this</a> section.</p>
<p>Note that <code>curl -sf</code> operates silently, so if there are errors, you may get an empty or incorrect version of <code>native_bootstrap.sh</code>. Check for typos in the command and try again. If you continue to have problems, join the <a href="./chat.html">chat</a> and let us know.</p>
<p>Please be patient. The bootstrapping process can take anywhere from 5 minutes to an hour depending on the hardware and network it's being run on.</p>
<p>If the <code>native_bootstrap.sh</code> script does not work for you, please try reading the <a href="./advanced-build.html">Advanced Build</a> page to install the right packages for your operating system.</p>
</li>
<li>
<p>After bootstrapping is completed, update the <code>PATH</code> environment variable for the current shell:</p>
<pre><code class="language-sh">source ~/.cargo/env
</code></pre>
</li>
</ol>
<h3 id="setting-configuration-values"><a class="header" href="#setting-configuration-values">Setting Configuration Values</a></h3>
<p>The build system uses several configuration files, which contain settings that you may wish to change. These are detailed in the <a href="./configuration-settings.html">Configuration Settings</a> page. For the Native Build we recommend setting these in the <code>.config</code> file:</p>
<ul>
<li><code>ARCH=x86_64</code></li>
<li><code>CONFIG_NAME=desktop</code></li>
<li><code>PODMAN_BUILD=0</code> to disable Podman Build</li>
<li><code>PREFIX_BINARY=0</code> to disable <a href="./advanced-build.html#prefix">prebuilt prefix binary</a></li>
<li><code>PREFIX_USE_UPSTREAM_RUST_COMPILER=1</code> to <a href="./advanced-build.html#prefix-rust">avoid compiling Rust compiler</a></li>
</ul>
<p>The <a href="./configuration-settings.html#buildsh">build.sh</a> script also allows the user to specify the CPU architecture and filesystem contents to be used in the build, although these settings needs to be written again every time the script is executed.</p>
<h2 id="compiling-redox"><a class="header" href="#compiling-redox">Compiling Redox</a></h2>
<p>At this point we have:</p>
<ul>
<li>Downloaded the sources</li>
<li>Tweaked the settings to our liking</li>
<li>Probably added our recipe to the filesystem</li>
</ul>
<p>We are ready to build the Redox operating system image. Skip ahead to <a href="./configuration-settings.html">Configuration Settings</a> if you want to build for a different CPU architecture or with different filesystem contents.</p>
<h3 id="build-all-system-components-and-programs"><a class="header" href="#build-all-system-components-and-programs">Build all system components and programs</a></h3>
<p>To build all the components and packages to be included in the filesystem.</p>
<pre><code class="language-sh">cd ~/tryredox/redox
</code></pre>
<pre><code class="language-sh">time make all
</code></pre>
<p>This will build the target <code>build/x86_64/desktop/harddrive.img</code>, which can be run in a virtual machine.</p>
<p>Give it a while. Redox is big. Read the <a href="./build-phases.html#make-all-first-run"><code>make all</code> (first run)</a> section for an explanation of what the <code>make all</code> command does.</p>
<blockquote>
<p>ğŸ’¡ <strong>Tip:</strong> the filesystem parts are merged into the final system image using the <a href="https://github.com/libfuse/libfuse">FUSE</a> library. The <code>bootstrap.sh</code> script installs <code>libfuse</code> automatically. If you encounter problems with the final Redox image, verify <code>libfuse</code> is installed and that you are able to use it.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="from-nothing-to-hello-world"><a class="header" href="#from-nothing-to-hello-world">From Nothing To Hello World</a></h1>
<p>This page explain the quickest way to test a program on Redox. This tutorial doesn't build Redox from source.</p>
<p>In this example we will use a "Hello World" program written in Rust.</p>
<ol>
<li>
<p>å»ºç«‹ <code>tryredox</code> è³‡æ–™å¤¾ã€‚</p>
<pre><code class="language-sh">mkdir -p ~/tryredox
</code></pre>
</li>
<li>
<p>Navigate to the <code>tryredox</code> folder.</p>
<pre><code class="language-sh">cd ~/tryredox
</code></pre>
</li>
<li>
<p>ä¸‹è¼‰ç”¨æ–¼çµ„æ…‹ Podman çš„è…³æœ¬ï¼Œä¸¦ä¸‹è¼‰ Redox å»ºç½®ç³»çµ±ã€‚</p>
<pre><code class="language-sh">curl -sf https://gitlab.redox-os.org/redox-os/redox/raw/master/podman_bootstrap.sh -o podman_bootstrap.sh
</code></pre>
</li>
<li>
<p>åŸ·è¡Œä¸‹è¼‰çš„è…³æœ¬ã€‚</p>
<pre><code class="language-sh">time bash -e podman_bootstrap.sh
</code></pre>
</li>
<li>
<p>åœ¨ç•¶å‰å¤–æ®¼ä¸­å•Ÿç”¨ Rust å·¥å…·éˆã€‚</p>
<pre><code class="language-sh">source ~/.cargo/env
</code></pre>
</li>
<li>
<p>Navigate to the Redox build system directory.</p>
<pre><code class="language-sh">cd ~/tryredox/redox
</code></pre>
</li>
<li>
<p>å»ºç«‹ <code>.config</code> æª”æ¡ˆï¼Œä¸¦å¢æ·» <code>REPO_BINARY</code> ç’°å¢ƒè®Šæ•¸ä¾†ä¸‹è¼‰é ç·¨è­¯è»Ÿé«”åŒ…ã€‚</p>
<pre><code class="language-sh">echo "REPO_BINARY?=1 \n CONFIG_NAME?=my-config" &gt;&gt; .config
</code></pre>
</li>
<li>
<p>å»ºç«‹ <code>hello-world</code> é…æ–¹è³‡æ–™å¤¾ã€‚</p>
<pre><code class="language-sh">mkdir recipes/other/hello-world
</code></pre>
</li>
<li>
<p>Create the <code>source</code> folder for the recipe.</p>
<pre><code class="language-sh">mkdir recipes/other/hello-world/source
</code></pre>
</li>
<li>
<p>Navigate to the recipe's <code>source</code> folder.</p>
<pre><code class="language-sh">cd recipes/other/hello-world/source
</code></pre>
</li>
<li>
<p>Initialize a Cargo project with the "Hello World" string.</p>
<pre><code class="language-sh">cargo init --name="hello-world"
</code></pre>
</li>
<li>
<p>Create the <code>hello-world</code> recipe configuration.</p>
<pre><code class="language-sh">cd ~/tryredox/redox
</code></pre>
<pre><code class="language-sh">nano recipes/other/hello-world/recipe.toml
</code></pre>
</li>
<li>
<p>Add the following to the recipe configuration:</p>
<pre><code class="language-toml">[build]
template = "cargo"
</code></pre>
</li>
<li>
<p>å»ºç«‹ <code>my-config</code> æª”æ¡ˆç³»çµ±çµ„æ…‹ã€‚</p>
<pre><code class="language-sh">cp config/x86_64/desktop.toml config/x86_64/my-config.toml
</code></pre>
</li>
<li>
<p>Open the <code>my-config</code> filesystem configuration file (i.e., <code>config/x86_64/my-config.toml</code>) and add the <code>hello-world</code> package to it.</p>
<pre><code class="language-toml">[packages]
# Add the item below
hello-world = "source"
</code></pre>
</li>
<li>
<p>ç·¨è­¯ Hello World ç¨‹å¼ä¸¦æ›´æ–° Redox æ˜ åƒæª”ã€‚</p>
<pre><code class="language-sh">time make prefix rp.hello-world
</code></pre>
</li>
<li>
<p>Start the Redox virtual machine without a GUI.</p>
<pre><code class="language-sh">make qemu gpu=no
</code></pre>
</li>
<li>
<p>åœ¨ Redox ç™»å…¥ç•«é¢ï¼Œæ–¼ä½¿ç”¨è€…åç¨±æ¬„ä½è¼¸å…¥ã€Œuserã€ä¸¦æŒ‰ä¸‹ Enterã€‚</p>
</li>
<li>
<p>åŸ·è¡Œã€ŒHello Worldã€ç¨‹å¼ã€‚</p>
<pre><code class="language-sh">helloworld
</code></pre>
</li>
<li>
<p>é—œé–‰ Redox è™›æ“¬æ©Ÿã€‚</p>
<pre><code class="language-sh">sudo shutdown
</code></pre>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="çµ„æ…‹è¨­å®š"><a class="header" href="#çµ„æ…‹è¨­å®š">çµ„æ…‹è¨­å®š</a></h1>
<p>The Redox build system applies configuration settings from various places to determine the final Redox image. Most of these settings ultimately come from the build system's <a href="configuration-settings.html#environment-variables">environment variables</a> (or similarly-named Make variables) and the contents of the chosen <a href="configuration-settings.html#filesystem-configuration">filesystem configuration</a> file.</p>
<ul>
<li><a href="configuration-settings.html#environment-variables">ç’°å¢ƒè®Šæ•¸</a>
<ul>
<li><a href="configuration-settings.html#config">.config</a></li>
<li><a href="configuration-settings.html#cookbook-configuration">Cookbook Configuration</a></li>
<li><a href="configuration-settings.html#command-line">Command Line</a></li>
<li><a href="configuration-settings.html#mkconfigmk">mk/config.mk</a></li>
<li><a href="configuration-settings.html#buildsh">build.sh</a></li>
</ul>
</li>
<li><a href="configuration-settings.html#filesystem-configuration">æª”æ¡ˆç³»çµ±çµ„æ…‹</a>
<ul>
<li><a href="configuration-settings.html#cpu-architecture-codenames">CPU Architecture Codenames</a></li>
<li><a href="configuration-settings.html#filesystem-size">Filesystem Size</a></li>
<li><a href="configuration-settings.html#filesystem-customization">Filesystem Customization</a>
<ul>
<li><a href="configuration-settings.html#creating-a-custom-filesystem-configuration">Creating a custom filesystem configuration</a></li>
<li><a href="configuration-settings.html#adding-a-package-to-the-filesystem-configuration">Adding a package to the filesystem configuration</a></li>
</ul>
</li>
<li><a href="configuration-settings.html#binary-packages">Binary Packages</a>
<ul>
<li><a href="configuration-settings.html#repo_binary">REPO_BINARY</a></li>
</ul>
</li>
<li><a href="configuration-settings.html#local-recipe-changes">Local Recipe Changes</a></li>
<li><a href="configuration-settings.html#cookbook-offline-mode">Cookbook Offline Mode</a></li>
</ul>
</li>
</ul>
<h2 id="environment-variables"><a class="header" href="#environment-variables">Environment Variables</a></h2>
<p>The default values for the build system's environment variables are mostly defined in the <code>mk</code> directoryâ€”particularly in <a href="configuration-settings.html#mkconfigmk"><code>mk/config.mk</code></a>. Local changes from the default values, however, should be applied in the <a href="configuration-settings.html#config"><code>.config</code></a> file, or temporarily on the <code>make</code> <a href="configuration-settings.html#command-line">command line</a>.</p>
<p>The build system uses GNU Make and Cookbook to coordinate the build system in order. The <a href="./build-system-reference.html#cookbook">build system reference</a> and <a href="./porting-applications.html#cookbook">porting application guide</a> have more information about Cookbook.</p>
<p>Three important variables of interest are <code>ARCH</code>, <code>CONFIG_NAME</code>, and <code>BOARD</code>, as they specify the system to be built. These, and other important environment variables, can be seen in the following table:</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Variable</th><th style="text-align: left">Definition</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>ARCH</code></td><td style="text-align: left">Specifies the <a href="configuration-settings.html#architecture-names">CPU architecture</a> that the system is to be built for. The default value is <code>x86_64</code>.</td></tr>
<tr><td style="text-align: left"><code>CONFIG_NAME</code></td><td style="text-align: left">Determines the name of the filesystem configuration, and is normally used to construct the <code>FILESYSTEM_CONFIG</code> name (the <code>desktop</code> variant is used by default).</td></tr>
<tr><td style="text-align: left"><code>BOARD</code></td><td style="text-align: left">For single board computers such as Raspberry Pi 3B+ (<code>raspi3bp</code>) that require special configuration. Defaults to empty.</td></tr>
<tr><td style="text-align: left"><code>FILESYSTEM_CONFIG</code></td><td style="text-align: left">Determines the filesystem configuration file location. See the <a href="configuration-settings.html#filesystem-configuration">Filesystem Configuration</a> section below. The default value is <code>config/$ARCH/$BOARD/$CONFIG_NAME.toml</code> or <code>config/$ARCH/$CONFIG_NAME.toml</code> if <code>$BOARD</code> is empty, but this can be changed if the desired configuration file is in a different location.</td></tr>
<tr><td style="text-align: left"><code>QEMU_MEM</code></td><td style="text-align: left">Sets the QEMU RAM memory quantity, e.g., <code>QEMU_MEM=2048</code>.</td></tr>
<tr><td style="text-align: left"><code>QEMU_SMP</code></td><td style="text-align: left">Sets the QEMU CPU core quantity, e.g.,  <code>QEMU_SMP=4</code>.</td></tr>
<tr><td style="text-align: left"><code>PREFIX_BINARY</code></td><td style="text-align: left">If set to 0 (<code>PREFIX_BINARY=0</code>), the build system will build the Redox toolchain from source and will not download the toolchain binaries from the Redox build server.</td></tr>
<tr><td style="text-align: left"><code>PREFIX_USE_UPSTREAM_RUST_COMPILER</code></td><td style="text-align: left">If set to 1 (<code>PREFIX_BINARY=1</code>) the build system will download the Rust compiler from rustup (Rust upstream compiler binaries) instead of building it (only used with <code>PREFIX_BINARY=0</code>)</td></tr>
<tr><td style="text-align: left"><code>REPO_BINARY</code></td><td style="text-align: left">If set to 1 (<code>REPO_BINARY=1</code>), the build system will download/install pre-compiled packages from the Redox package server by default, rather than build them from source (i.e., recipes).</td></tr>
<tr><td style="text-align: left"><code>REPO_OFFLINE</code></td><td style="text-align: left">Enable the offline mode of Cookbook where recipe sources will not be updated and use less Internet connection as possible.</td></tr>
<tr><td style="text-align: left"><code>REPO_NONSTOP</code></td><td style="text-align: left">Enable the nonstop mode of Cookbook where recipe build failure will not stop the compilation of other recipes.</td></tr>
<tr><td style="text-align: left"><code>FILESYSTEM_SIZE</code></td><td style="text-align: left">The size in MB of the filesystem contained in the final Redox image. See the <a href="configuration-settings.html#filesystem-size">Filesystem Size</a> section before changing it.</td></tr>
<tr><td style="text-align: left"><code>REDOXFS_MKFS_FLAGS</code></td><td style="text-align: left">Flags to the program that builds the Redox filesystem. The <code>--encrypt</code> option enables disk encryption.</td></tr>
<tr><td style="text-align: left"><code>PODMAN_BUILD</code></td><td style="text-align: left">If set to 0 (<code>PODMAN_BUILD?=0</code>), the build system will use the build environment from your Linux distribution or Unix-like system instead of Podman. See the <a href="./building-redox.html">Native Build</a> page for more information.</td></tr>
<tr><td style="text-align: left"><code>FSTOOLS_IN_PODMAN</code></td><td style="text-align: left">If set to 1 (<code>FSTOOLS_IN_PODMAN=1</code>), the build system will build the installer inside Podman to avoid FUSE in the host system. See the <a href="./advanced-podman-build.html#installing-without-fuse">Installing without FUSE</a> page for more information.</td></tr>
<tr><td style="text-align: left"><code>FSTOOLS_NO_MOUNT</code></td><td style="text-align: left">If set to 1 (<code>FSTOOLS_NO_MOUNT=1</code>), the installer will not use FUSE to create images. See the <a href="./advanced-podman-build.html#installing-without-fuse">Installing without FUSE</a> section for more information.</td></tr>
<tr><td style="text-align: left"><code>CONTAINERFILE</code></td><td style="text-align: left">The Podman container configuration file. See the <a href="./podman-build.html">Podman Build</a> page for more information.</td></tr>
<tr><td style="text-align: left"><code>COOKBOOK_MAKE_JOBS</code></td><td style="text-align: left">The number of maximum CPU cores used when building recipes, default is using all CPU cores from <code>nproc</code>.</td></tr>
<tr><td style="text-align: left"><code>CI</code></td><td style="text-align: left">If set to any value (<code>CI=1</code>), the build system will not activate TUI, and parallel execution of the build step is disabled .</td></tr>
<tr><td style="text-align: left"><code>COOKBOOK_LOGS</code></td><td style="text-align: left">A boolean option (<code>true</code>/<code>false</code>) to let the build system save build logs in <code>build/logs/$TARGET</code> directory. The default value is <code>true</code> if TUI is enabled, <code>false</code> otherwise.</td></tr>
<tr><td style="text-align: left"><code>COOKBOOK_VERBOSE</code></td><td style="text-align: left">A boolean option (<code>true</code>/<code>false</code>) to print more information about the build process. The default value is <code>true</code>.</td></tr>
</tbody></table>
</div>
<p>The Redox image that is built is typically named <code>build/$ARCH/$CONFIG_NAME/harddrive.img</code> or <code>build/$ARCH/$CONFIG/livedisk.iso</code>.</p>
<h3 id="config"><a class="header" href="#config">.config</a></h3>
<p>The purpose of the <code>.config</code> file is to allow default configuration settings to be changed without explicitly setting those changes in every <code>make</code> command (or modifying the contents of the <code>mk</code> directory). The file is also included in the <code>.gitignore</code> list to ensure it won't be committed by accident.</p>
<p>To permanently override the settings in the <a href="configuration-settings.html#mkconfigmk"><code>mk/config.mk</code></a> section, add a <code>.config</code> file to the <code>redox</code> base directory (i.e., where <code>make</code> commands are run) and set the overriding values in that file.</p>
<p>For example, the following configuration specifies the <code>desktop-minimal</code> image variant will be built for the <code>i586</code> CPU architecture. These settings will be applied implicitly to all subsequent <code>make</code> commands:</p>
<pre><code>ARCH?=i586
CONFIG_NAME?=desktop-minimal
</code></pre>
<blockquote>
<p>ğŸ“ <strong>Note:</strong> Comments are supported using the <code>#</code> character ğŸ“ <strong>Note:</strong> Any QEMU option can be inserted ğŸ“ <strong>Note:</strong> if <a href="./podman-build.html#new-working-directory"><code>podman_bootstrap.sh</code></a> was run previously, the <code>.config</code> file may already exist. ğŸ’¡ <strong>Tip:</strong> when adding environment variables in the <code>.config</code> file, don't forget the <code>?</code> symbol at the end of variable names. This allows the variable to be overridden on the command line or in the environment. In particular, <code>PODMAN_BUILD?=1</code> <em>must</em> include the question mark to function correctly.</p>
</blockquote>
<h3 id="cookbook-configuration"><a class="header" href="#cookbook-configuration">Cookbook Configuration</a></h3>
<p>In addition to <code>.config</code>, <code>cookbook.toml</code> is a configuration file that is used by Cookbook and has more customization. Any configuration in this file will override configuration from <code>.config</code> or environment variables. The <code>cookbook.toml</code> configuration below can be used as a template:</p>
<pre><code class="language-toml"># These options have defaults set below
#[cook]
#jobs = &lt;nproc&gt;
#nonstop = false
#offline = false
#tui = true
#logs = true
#verbose = true

[mirrors]
# The uncommented option below is the default if [mirrors] is not set
# see the list of GNU FTP mirrors at: https://www.gnu.org/prep/ftp.en.html
"ftp.gnu.org/gnu" = "mirrors.ocf.berkeley.edu/gnu"
# "github.com/foo/bar" = "github.com/baz/bar" 
</code></pre>
<p>The <code>cookbook.toml</code> file mainly configures Cookbook options (<code>[cook]</code>) and mirrors (<code>[mirror]</code>). Mirrors are used to replace code and binary sources used across Cookbook, useful for a quick way to use alternative sources when the main server is offline or slow.</p>
<p>Each Cookbook configuration defaults to environment variables which are:</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Environment Variable</th><th style="text-align: left">How to use the variable</th><th style="text-align: left">Definition in cookbook.toml</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>CI</code></td><td style="text-align: left"><code>CI=1</code>, <code>CI=</code></td><td style="text-align: left"><code>cook.tui</code> (disables TUI if variable is set)</td></tr>
<tr><td style="text-align: left"><code>COOKBOOK_MAKE_JOBS</code></td><td style="text-align: left"><code>COOKBOOK_MAKE_JOBS=4</code></td><td style="text-align: left"><code>cook.jobs</code></td></tr>
<tr><td style="text-align: left"><code>COOKBOOK_LOGS</code></td><td style="text-align: left"><code>COOKBOOK_LOGS=true</code></td><td style="text-align: left"><code>cook.logs</code></td></tr>
<tr><td style="text-align: left"><code>COOKBOOK_OFFLINE</code></td><td style="text-align: left"><code>COOKBOOK_OFFLINE=true</code> (see notes)</td><td style="text-align: left"><code>cook.logs</code></td></tr>
<tr><td style="text-align: left"><code>COOKBOOK_VERBOSE</code></td><td style="text-align: left"><code>COOKBOOK_VERBOSE=false</code> (see notes)</td><td style="text-align: left"><code>cook.verbose</code></td></tr>
<tr><td style="text-align: left"><code>COOKBOOK_NONSTOP</code></td><td style="text-align: left"><code>COOKBOOK_NONSTOP=true</code></td><td style="text-align: left"><code>cook.nonstop</code></td></tr>
</tbody></table>
</div>
<blockquote>
<p>ğŸ“ <strong>Note:</strong> <code>REPO_OFFLINE=1</code> and <code>REPO_NONSTOP=1</code> are the recommended ways to set options instead of <code>COOKBOOK_OFFLINE=true</code> and <code>COOKBOOK_NONSTOP=true</code> ğŸ“ <strong>Note:</strong> <code>.config</code> cannot be used to save <code>COOKBOOK_*</code> options as those are not Makefile variables, so you need to use <code>cookbook.toml</code> to make options persist ğŸ’¡ <strong>Tip:</strong> Running Cookbook with <code>CI=1 COOKBOOK_LOGS=true COOKBOOK_NONSTOP=true COOKBOOK_VERBOSE=false</code> will hide successful build logs in the terminal ğŸ’¡ <strong>Tip:</strong> Mirrors option can also be used to override <a href="configuration-settings.html#repo_binary">binary builds</a> source URL.</p>
</blockquote>
<h4 id="changing-the-qemu-cpu-core-and-memory-quantity"><a class="header" href="#changing-the-qemu-cpu-core-and-memory-quantity">Changing the QEMU CPU Core and Memory Quantity</a></h4>
<p>For example, to change the CPU core and RAM memory quantities used when running the Redox image in QEMU, add the following environment variables to your <code>.config</code> file:</p>
<pre><code>QEMU_SMP?=&lt;number-of-threads&gt;
QEMU_MEM?=&lt;number-in-mb&gt;
</code></pre>
<h3 id="command-line"><a class="header" href="#command-line">Command Line</a></h3>
<p>The default settings in <code>mk/config.mk</code> can be manually overridden by explicitly setting them on the <code>make</code> command line.</p>
<p>For example, the following command builds the <code>demo</code> image variant and loads it into QEMU:</p>
<pre><code class="language-sh">make CONFIG_NAME=demo qemu
</code></pre>
<p>Some environment variables can also be set for the lifetime of the current shell by setting them at the command line:</p>
<pre><code class="language-sh">export ARCH=i586; make all
</code></pre>
<p>Overriding settings in this way is only temporary, however. Additionally, for those using the <a href="./podman-build.html">Podman Build</a>, some settings may be ignored when using this method. For best results, use <a href="configuration-settings.html#config"><code>.config</code></a>.</p>
<h3 id="mkconfigmk"><a class="header" href="#mkconfigmk">mk/config.mk</a></h3>
<p>The Redox build system uses several Makefiles, most of which are in the <code>mk</code> directory. Most settings of interest have have been grouped together in <code>mk/config.mk</code>.</p>
<p>Feel free to open <code>mk/config.mk</code> in your favorite editor and have a look through it; just be sure not to apply any changes:</p>
<pre><code class="language-sh">nano mk/config.mk
</code></pre>
<p>The <code>mk/config.mk</code> file should never be modified directly, especially if you are contributing to the Redox project, as doing so could create conflicts in the <code>make pull</code> command.</p>
<p>To apply lasting changes to environment variables, please refer to the <a href="configuration-settings.html#config"><code>.config</code></a> section. To apply changes only <em>temporarily</em>, see the <a href="configuration-settings.html#command-line">Command Line</a> section.</p>
<h4 id="buildsh-1"><a class="header" href="#buildsh-1">build.sh</a></h4>
<p>The <code>build.sh</code> script allows you to easily set <code>ARCH</code>, <code>FILESYSTEM_CONFIG</code> and <code>CONFIG_NAME</code> when running <code>make</code>. If you are not changing the values very often, it is recommended that you set the values in <a href="configuration-settings.html#config"><code>.config</code></a> rather than use <code>build.sh</code>. But if you are testing against different CPU architectures or configurations, this script can help minimize effort, errors and confusion.</p>
<pre><code class="language-sh">./build.sh [-a &lt;ARCH&gt;] [-c &lt;CONFIG_NAME&gt;] [-f &lt;FILESYSTEM_CONFIG&gt;] &lt;TARGET&gt; ...
</code></pre>
<p>The <code>TARGET</code> parameter may be any valid <code>make</code> target, although the recommended target is <code>qemu</code>. Additional variable settings may also be included, such as <code>gpu=no</code></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Option</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>-a &lt;ARCH&gt;</code></td><td style="text-align: left">The CPU architecture you are building for, <code>x86_64</code>, <code>i586</code>, <code>aarch64</code> or <code>riscv64gc</code>. Uppercase options <code>-X</code>, <code>-5</code>, <code>-A</code>, <code>-R</code> can be used as shorthands for <code>-a x86_64</code>, <code>-a i586</code>, <code>-a aarch64</code> and <code>riscv64gc</code>, respectively.</td></tr>
<tr><td style="text-align: left"><code>-c &lt;CONFIG_NAME&gt;</code></td><td style="text-align: left">The name of the filesystem configuration which appears in the name of the image being built.</td></tr>
<tr><td style="text-align: left"><code>-f &lt;FILESYSTEM_CONFIG&gt;</code></td><td style="text-align: left">Determines the filesystem configuration file location, which can be in any location but is normally in directory <code>config/$ARCH</code>.<br><br>ğŸ“ <strong>Note:</strong> If you <em>do</em> specify <code>-f &lt;FILESYSTEM_CONFIG&gt;</code>, but not <code>-a</code> or <code>-c</code>, the file path determines the other values. Normally the file would be located at e.g., <code>config/x86_64/desktop.toml</code>. <code>ARCH</code> is determined from the second-to-last element of the path. If the second last element is not a known <code>ARCH</code> value, you must specify <code>-a ARCH</code>. <code>CONFIG_NAME</code> is determined from the <em>basename</em> of the file.</td></tr>
</tbody></table>
</div>
<p>The default value of <code>FILESYSTEM_CONFIG</code> is constructed from <code>ARCH</code> and <code>CONFIG_NAME</code>: <code>config/$ARCH/$CONFIG_NAME.toml</code>.</p>
<p>The default values for <code>ARCH</code> and <code>CONFIG_NAME</code> are <code>x86_64</code> and <code>desktop</code>, respectively. These produce a default <code>FILESYSTEM_CONFIG</code> value of <code>config/x86_64/desktop.toml</code>.</p>
<h2 id="æª”æ¡ˆç³»çµ±çµ„æ…‹"><a class="header" href="#æª”æ¡ˆç³»çµ±çµ„æ…‹">æª”æ¡ˆç³»çµ±çµ„æ…‹</a></h2>
<p>The packages to be included in the final Redox image are determined by the chosen <strong>filesystem configuration</strong> file, which is a <code>.toml</code> file (e.g., <code>config/x86_64/desktop.toml</code>). Open <code>desktop.toml</code> and have a look through it:</p>
<pre><code class="language-sh">nano config/x86_64/desktop.toml
</code></pre>
<p>For each supported CPU architecture, there are some filesystem configurations to choose from. For <code>x86_64</code>, there are <code>desktop</code>, <code>demo</code> and <code>server</code> configurations, as well as a few others. For <code>i586</code>, there are also some stripped down configurations for embedded devices or legacy systems with minimal RAM. Feel free to browse the <code>config/x86_64</code> directory for more examples.</p>
<p>For more details on the filesystem configuration, and how to add additional packages to the build image, please see the <a href="./including-programs.html">Including Programs in Redox</a> page.</p>
<p>Feel free to create your own <strong>filesystem configuration</strong>.</p>
<h3 id="cpu-architecture-codenames"><a class="header" href="#cpu-architecture-codenames">CPU Architecture Codenames</a></h3>
<p>The Redox build system supports cross-compilation to other CPU architectures. The CPU architecture that Redox is built for (specified by the <code>ARCH</code> environment variable) usually determines the filesystem configuration file that will be used by the build system.</p>
<p>See the currently supported CPU architectures by Redox below:</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">CPU Architecture</th><th style="text-align: left">Other Aliases</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>i586</code></td><td style="text-align: left">x86 (32-bit), IA32 , <code>x86</code></td></tr>
<tr><td style="text-align: left"><code>x86_64</code></td><td style="text-align: left">x86 (64-bit), <code>x86-64</code>, <code>amd64</code>, <code>x64</code></td></tr>
<tr><td style="text-align: left"><code>aarch64</code></td><td style="text-align: left">ARM (64-bit), ARMv8, <code>ARM64</code></td></tr>
<tr><td style="text-align: left"><code>riscv64gc</code></td><td style="text-align: left">RISC-V (64-bit)</td></tr>
</tbody></table>
</div>
<p>The filesystem configurations for a given CPU architecture can be found in the <a href="https://gitlab.redox-os.org/redox-os/redox/-/tree/master/config"><code>config</code></a> folder's correspondingly named sub-directory (e.g. <code>config/x86_64</code>).</p>
<h3 id="filesystem-size"><a class="header" href="#filesystem-size">Filesystem Size</a></h3>
<p>The filesystem size is the total amount of storage space allocated for the filesystem that is built into the image, including all programs. It is specified in Megabytes (MB). The typical size is 512MB, although some configs (e.g., <code>demo</code>) are larger. The filesystem must be large enough to accommodate the packages included in the filesystem. For a <em>livedisk</em> system, the filesystem must not exceed the size of your system's RAM, and must also leave room for the package's installation and system execution.</p>
<p>The filesystem size is normally set from the <strong>filesystem configuration</strong> file, e.g. <code>config/x86_64/demo.toml</code>.</p>
<pre><code class="language-toml">[general]
...
filesystem_size = 768
...
</code></pre>
<p>To change this, it is recommended that you create your own filesystem configuration and apply changes there. However, this can be temporarily overridden on the <code>make</code> command line, e.g.:</p>
<pre><code class="language-sh">make FILESYSTEM_SIZE=512 image qemu
</code></pre>
<blockquote>
<p>âš ï¸ <strong>Warning:</strong> setting the <code>filesystem_size</code> value too low will produce an error resembling the following:</p>
<pre><code>thread 'main' panicked at src/lib.rs:94:53:
called `Result::unwrap()` on an `Err` value: Error(Path("/tmp/redox_installer_759506/include/openssl/.pkgar.srtp.h"), State { next_error: Some(Os { code: 28, kind: StorageFull, message: "No space left on device" }), backtrace: InternalBacktrace { backtrace: None } })
</code></pre>
</blockquote>
<h3 id="filesystem-customization"><a class="header" href="#filesystem-customization">Filesystem Customization</a></h3>
<p>The Redox image can be customized by tweaking the configuration files at <code>config/your-cpu/*.toml</code>. However, it is recommended that you create your own configuration file and apply changes there. (The configuration files at <code>config/your-cpu</code> can override the data type values from the filesystem templates at <code>config</code>)</p>
<h4 id="creating-a-custom-filesystem-configuration"><a class="header" href="#creating-a-custom-filesystem-configuration">Creating a custom filesystem configuration</a></h4>
<p>The following items describe the process for creating a custom filesystem configuration file (<code>my-desktop.toml</code>):</p>
<ol>
<li>
<p>Create the <code>my-desktop.toml</code> file from an existing filesystem configuration:</p>
<pre><code class="language-sh">cp config/your-cpu-arch/desktop.toml config/your-cpu-arch/my_desktop.toml
</code></pre>
</li>
<li>
<p>Add the following to the <code>.config</code> file to set the new configuration as the build system's default:</p>
<pre><code>CONFIG_NAME?=my_desktop
</code></pre>
</li>
</ol>
<p>Many filesystem configuration settings can be adjusted. See the templates in the <code>config</code> folder for reference.</p>
<blockquote>
<p>ğŸ’¡ <strong>Tip:</strong> files named with the prefix "<code>my-</code>" in the <code>redox</code> repo are git-ignored. Be sure to follow this convention for all custom filesystem configurations to avoid accidentally committing them to the Redox project.</p>
</blockquote>
<h4 id="adding-a-package-to-the-filesystem-configuration"><a class="header" href="#adding-a-package-to-the-filesystem-configuration">Adding a package to the filesystem configuration</a></h4>
<p>In the following example, the <code>acid</code> package is added to the <code>my_desktop.toml</code> configuration:</p>
<ol>
<li>
<p>Open the <code>my-desktop.toml</code> file:</p>
<pre><code class="language-sh">nano config/your-cpu/my-desktop.toml
</code></pre>
</li>
<li>
<p>Add the <code>acid</code> package to the <code>[packages]</code> section:</p>
<pre><code class="language-toml">[packages]
acid = {}
</code></pre>
</li>
<li>
<p>Build the <code>acid</code> package and update the Redox image:</p>
<pre><code class="language-sh">make rp.acid
</code></pre>
</li>
</ol>
<p>Done! The <code>acid</code> package is now included in your Redox image.</p>
<h3 id="binary-packages"><a class="header" href="#binary-packages">Binary Packages</a></h3>
<p>By default, the Redox build system builds all packages from source (i.e., recipes). If you want to use <a href="https://static.redox-os.org/pkg/">pre-compiled packages</a> from our build server, however, there's a TOML option for it.</p>
<p>This is useful for some purposes, such as producing development builds, confirming package status from the Redox package server, and reducing image build time with large programs.</p>
<ol>
<li>
<p>Open the <code>my-desktop.toml</code> file:</p>
<pre><code class="language-sh">nano config/your-cpu/my-desktop.toml
</code></pre>
</li>
<li>
<p>Add the binary package below the <code>[packages]</code> section:</p>
<pre><code class="language-toml">[packages]
...
new-package = "binary"
...
</code></pre>
</li>
<li>
<p>Download and add the binary package on your Redox image:</p>
<pre><code class="language-sh">make image
</code></pre>
</li>
<li>
<p>Open QEMU to verify your binary package:</p>
<pre><code class="language-sh">make qemu
</code></pre>
</li>
</ol>
<h4 id="repo_binary"><a class="header" href="#repo_binary">REPO_BINARY</a></h4>
<p>In the previous example, the build system's default behavior was overridden by explicitly setting a package to use a pre-built binary. To configure the build system to download pre-built packages by <em>default</em>, however, we can set the <code>REPO_BINARY</code> environment variable (<code>REPO_BINARY?=1</code>).</p>
<p>When <code>REPO_BINARY</code> is enabled, the Redox image is made to use pre-built binaries for all packages assigned to <code>{}</code>; when <code>REPO_BINARY</code> is <em>disabled</em>, however, those same packages are compiled from source (i.e., recipes).</p>
<p>For example:</p>
<pre><code class="language-toml">[packages]
...
package-name1 = {} # use the REPO_BINARY setting ("source" if 0; "binary" if 1)
package-name2 = "binary" # pre-built package
package-name3 = "source" # source-based recipe
...
</code></pre>
<h3 id="local-recipe-changes"><a class="header" href="#local-recipe-changes">Local Recipe Changes</a></h3>
<p>By default every time a recipe build is triggered Cookbook will update the recipe source. Cookbook will check the tarball BLAKE3 hash from the recipe configuration (<code>recipe.toml</code>), or pull from the <code>origin</code> remote when the recipe source is a Git repository. This will also remove local changes that are not saved in a branch.</p>
<p>To preserve and use local changes and skip updating the source for a specific recipe, change the recipe type to <code>"local"</code> in the filesystem configuration, for example:</p>
<pre><code class="language-toml">[packages]
...
package-name = "local"
...
</code></pre>
<p>An old way for preserving and using local changes by commenting out the <code>[source]</code> section at the top of the file of a <code>recipe.toml</code> is also working but less recommended as it's prone to merge conflicts when pulling Redox repository:</p>
<pre><code class="language-toml"># [source]
# git = "https://gitlab.redox-os.org/redox-os/games.git"
</code></pre>
<h3 id="cookbook-offline-mode"><a class="header" href="#cookbook-offline-mode">Cookbook Offline Mode</a></h3>
<p>Cookbook also has a mode where it will reduce Internet activity by adding <code>REPO_OFFLINE=1</code> into <code>.config</code>. This mode is useful when you are in places where the Internet is slow or absent, or when you want a fixed build system state or faster incremental compilation.</p>
<p>In this mode, Cookbook will not update the source of any recipe or a package binary if also set with <code>REPO_BINARY=1</code>. It also adds the <code>--offline</code> option to some Cargo build methods inside recipes where it is supported. When Cookbook or Cargo must access the Internet because sources do not exist locally it will throw an error instead.</p>
<p>To temporarily allow Cookbook and Cargo to have Internet activity and update sources, run <code>make f.package-name</code> (single recipe source fetch) or <code>make fetch</code> (to fetch all enabled recipe sources), as these commands will ignore the <code>REPO_OFFLINE</code> environment variable.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="å»ºç½®ç³»çµ±åƒè€ƒ"><a class="header" href="#å»ºç½®ç³»çµ±åƒè€ƒ">å»ºç½®ç³»çµ±åƒè€ƒ</a></h1>
<p>The build system downloads and creates several files that you may want to know about. There are also several <code>make</code> commands mentioned below, and a few extras that you may find useful. Here's a quick summary. All file paths are relative to your <code>redox</code> base directory.</p>
<ul>
<li><a href="build-system-reference.html#build-system-organization">å»ºç½®ç³»çµ±çµ„ç¹”çµæ§‹</a>
<ul>
<li><a href="build-system-reference.html#root-folder">æ ¹ç›®éŒ„è³‡æ–™å¤¾</a></li>
<li><a href="build-system-reference.html#gnu-make-configuration">GNU Make çµ„æ…‹</a></li>
<li><a href="build-system-reference.html#podman-configuration">Podman çµ„æ…‹</a></li>
<li><a href="build-system-reference.html#filesystem-configuration">æª”æ¡ˆç³»çµ±çµ„æ…‹</a></li>
<li><a href="build-system-reference.html#cookbook">Cookbook</a></li>
<li><a href="build-system-reference.html#build-system-files">å»ºç½®ç³»çµ±æª”æ¡ˆ</a></li>
</ul>
</li>
<li><a href="build-system-reference.html#gnu-make-commands">GNU Make å‘½ä»¤</a>
<ul>
<li><a href="build-system-reference.html#build-system-1">å»ºç½®ç³»çµ±</a></li>
<li><a href="build-system-reference.html#podman">Podman</a></li>
<li><a href="build-system-reference.html#qemuvirtualbox">QEMU/VirtualBox</a></li>
</ul>
</li>
<li><a href="build-system-reference.html#environment-variables">ç’°å¢ƒè®Šæ•¸</a></li>
<li><a href="build-system-reference.html#scripts">è…³æœ¬</a></li>
<li><a href="build-system-reference.html#git-auto-checkout">Git Auto-checkout</a></li>
<li><a href="build-system-reference.html#update-the-build-system">æ›´æ–°å»ºç½®ç³»çµ±</a></li>
<li><a href="build-system-reference.html#fix-breaking-changes">Fix Breaking Changes</a>
<ul>
<li><a href="build-system-reference.html#all-recipes">All Recipes</a></li>
<li><a href="build-system-reference.html#one-recipe">One Recipe</a></li>
</ul>
</li>
<li><a href="build-system-reference.html#configuration">çµ„æ…‹</a>
<ul>
<li><a href="build-system-reference.html#format">Format</a></li>
<li><a href="build-system-reference.html#filesystem-customization">Filesystem Customization</a></li>
</ul>
</li>
<li><a href="build-system-reference.html#cross-compilation">Cross-Compilation</a></li>
<li><a href="build-system-reference.html#build-phases">Build Phases</a></li>
</ul>
<h2 id="build-system-organization"><a class="header" href="#build-system-organization">Build System Organization</a></h2>
<h3 id="root-folder"><a class="header" href="#root-folder">Root Folder</a></h3>
<ul>
<li><code>podman_bootstrap.sh</code> - The script used to configure the Podman build</li>
<li><code>native_bootstrap.sh</code> - The script used to configure the Native build</li>
<li><code>Makefile</code> - The main Makefile of the build system, it loads all the other Makefiles.</li>
<li><code>.config</code> - Where you override your build system settings. It is loaded by the Makefile (it is ignored by <code>git</code>).</li>
</ul>
<h3 id="gnu-make-çµ„æ…‹"><a class="header" href="#gnu-make-çµ„æ…‹">GNU Make çµ„æ…‹</a></h3>
<ul>
<li><code>mk/config.mk</code> - The build system settings are here. You can override these settings in your <code>.config</code>, don't change them here to avoid conflicts in the <code>make pull</code> command.</li>
<li><code>mk/*.mk</code> - The rest of the Makefiles. You should not need to change them.</li>
</ul>
<h3 id="podman-çµ„æ…‹"><a class="header" href="#podman-çµ„æ…‹">Podman çµ„æ…‹</a></h3>
<ul>
<li><code>podman/redox-base-containerfile</code> - The file used to create the image used by the Podman build. The installation of Ubuntu packages needed for the build is done here. See the <a href="./advanced-podman-build.html#adding-packages-to-the-build">Adding Packages to the Build</a> section if you need to add additional Ubuntu packages.</li>
</ul>
<h3 id="æª”æ¡ˆç³»çµ±çµ„æ…‹-1"><a class="header" href="#æª”æ¡ˆç³»çµ±çµ„æ…‹-1">æª”æ¡ˆç³»çµ±çµ„æ…‹</a></h3>
<ul>
<li><code>config</code> - This folder contains all filesystem configurations.</li>
<li><code>config/*.toml</code> - Filesystem templates used by the CPU target configurations (a template can use other template to reduce duplication)</li>
<li><code>config/your-cpu-arch/your-config.toml</code> - The filesystem configuration of the QEMU image to be built, e.g. <code>config/x86_64/desktop.toml</code></li>
<li><code>config/your-cpu-arch/server.toml</code> - The variant with system components (without Orbital) and some important tools. Aimed for servers, low-end computers, testers and developers (try this config if you have boot problems on QEMU or real hardware).</li>
<li><code>config/your-cpu-arch/desktop.toml</code> - The variant with system components, the Orbital desktop environment and some important programs (this is the default configuration of the build system). Aimed for end-users, gamers, testers and developers.</li>
<li><code>config/your-cpu-arch/dev.toml</code> - The variant with development tools included. Aimed for developers.</li>
<li><code>config/your-cpu-arch/demo.toml</code> - The variant with a complete system and optional programs and games. Aimed for end-users, gamers, testers and developers.</li>
<li><code>config/your-cpu-arch/desktop-minimal.toml</code> - The minimal <code>desktop</code> variant for low-end computers and embedded hardware. Aimed for servers, low-end computers, embedded hardware and developers.</li>
<li><code>config/your-cpu-arch/minimal.toml</code> - The variant without network support and Orbital. Aimed for low-end computers, embedded hardware, testers and developers.</li>
<li><code>config/your-cpu-arch/minimal-net.toml</code> - The variant without Orbital and tools. Aimed for low-end computers, embedded hardware, testers and developers.</li>
<li><code>config/your-cpu-arch/resist.toml</code> - The variant with the <code>resist</code> POSIX test suite. Aimed for developers.</li>
<li><code>config/your-cpu-arch/acid.toml</code> - The variant with the <code>acid</code> general-purpose test suite. Aimed for developers.</li>
<li><code>config/your-cpu-arch/ci.toml</code> - The continuous integration variant, recipes added here become packages on the <a href="https://static.redox-os.org/pkg/">build server</a>. Aimed for packagers and developers.</li>
<li><code>config/your-cpu-arch/jeremy.toml</code> - The build of <a href="https://soller.dev/">Jeremy Soller</a> (creator/BDFL of Redox) with the recipes that he is testing at the moment.</li>
</ul>
<h3 id="build-system-files"><a class="header" href="#build-system-files">Build System Files</a></h3>
<ul>
<li><code>build</code> - The directory where the build system will place the final image. Usually <code>build/$(ARCH)/$(CONFIG_NAME)</code>, e.g. <code>build/x86_64/desktop</code></li>
<li><code>build/your-cpu-arch/your-config/harddrive.img</code> - The Redox image file, to be used by QEMU or VirtualBox for virtual machine execution on a Unix-like host.</li>
<li><code>build/your-cpu-arch/your-config/redox-live.iso</code> - The Redox bootable image file, to be used on real hardware for testing and possible installation.</li>
<li><code>build/your-cpu-arch/your-config/fetch.tag</code> - An empty file that, if present, tells the build system that the downloading of recipe sources is done.</li>
<li><code>build/your-cpu-arch/your-config/repo.tag</code> - An empty file that, if present, tells the build system that all recipes required for the Redox image have been successfully built. <strong>The build system will not check for changes to your code when this file is present.</strong> Use <code>make rebuild</code> to force the build system to check for changes.</li>
<li><code>build/podman</code> - The directory where Podman Build places the container user's home directory, including the container's Rust installation. Use <code>make container_clean</code> to remove it. In some situations, you may need to remove this directory manually, possibly with root privileges.</li>
<li><code>build/container.tag</code> - An empty file, created during the first Podman build, so a Podman build knows when a reusable Podman image is available. Use <code>make container_clean</code> to force a rebuild of the Podman image on your next <code>make rebuild</code> run.</li>
</ul>
<h3 id="cookbook-1"><a class="header" href="#cookbook-1">Cookbook</a></h3>
<ul>
<li><code>prefix/*</code> - Tools used by the Cookbook system. They are normally downloaded during the first system build (if you are having a problem with the build system, you can remove the <code>prefix</code> directory and it will be recreated during the next build).</li>
<li><code>repo</code> - Contains all packaged recipes.</li>
<li><code>recipes/recipe-name</code> - A recipe (software port) directory (represented as <code>recipe-name</code>), this directory holds the <code>recipe.toml</code> file.</li>
<li><code>recipes/recipe-name/recipe.toml</code> - The recipe configuration file, this configuration contains instructions for downloading Git repositories or tarballs, then creating executables or other files to include in the Redox filesystem. Note that a recipe can contain dependencies that cause other recipes to be built, even if the dependencies are not otherwise part of your Redox build.</li>
</ul>
<p>(To learn more about the recipe system read the <a href="./porting-applications.html">Porting Applications using Recipes</a> page)</p>
<ul>
<li><code>recipes/recipe-name/recipe.sh</code> - The old recipe configuration format (can't be used as dependency of a recipe with a TOML syntax).</li>
<li><code>recipes/recipe-name/source.tar</code> - The tarball of the recipe (renamed).</li>
<li><code>recipes/recipe-name/source</code> - The directory where the recipe source is extracted or downloaded.</li>
<li><code>recipes/recipe-name/target</code> - The directory where the recipe binaries are stored.</li>
<li><code>recipes/recipe-name/target/${TARGET}</code> - The directory for the recipes binaries of the CPU architecture (<code>${TARGET}</code> is the environment variable of your CPU architecture).</li>
<li><code>recipes/recipe-name/target/${TARGET}/build</code> - The directory where the recipe build system run its commands.</li>
<li><code>recipes/recipe-name/target/${TARGET}/stage</code> - The directory where recipe binaries go before the packaging, after <code>make all</code>, <code>make rebuild</code> and <code>make image</code> the <a href="https://gitlab.redox-os.org/redox-os/installer">installer</a> will extract the recipe package on the QEMU image, generally at <code>/usr/bin</code> or <code>/usr/lib</code> in a Redox filesystem hierarchy.</li>
<li><code>recipes/recipe-name/target/${TARGET}/sysroot</code> - The folder where recipe build dependencies (libraries) goes, for example: <code>library-name/src/example.c</code></li>
<li><code>recipes/recipe-name/target/${TARGET}/stage.pkgar</code> - Redox package file.</li>
<li><code>recipes/recipe-name/target/${TARGET}/stage.sig</code> - Signature for the <code>tar</code> package format.</li>
<li><code>recipes/recipe-name/target/${TARGET}/stage.tar.gz</code> - Legacy <code>tar</code> package format, produced for compatibility reasons as we are working to make the package manager use the <code>pkgar</code> format.</li>
<li><code>recipes/recipe-name/target/${TARGET}/stage.toml</code> - Contains the runtime dependencies of the package and is part of both package formats.</li>
</ul>
<h2 id="gnu-make-commands"><a class="header" href="#gnu-make-commands">GNU Make Commands</a></h2>
<p>You can combine <code>make</code> commands, but order is significant. For example, <code>make r.games image</code> will build the <code>games</code> recipe and create a new Redox image, but <code>make image r.games</code> will make the Redox image before the recipe building, thus the new recipe binary will not be included on your Redox filesystem.</p>
<h3 id="build-system"><a class="header" href="#build-system">Build System</a></h3>
<ul>
<li><code>make pull</code> - Update the source code of the build system without building.</li>
<li><code>make all</code> - Builds the entire system, checking for changes and only building as required. Only use this for the first build. If the system was successfully built previously, this command may report <code>Nothing to be done for 'all'</code>, even if some recipes have changed. Use <code>make rebuild</code> instead.</li>
<li><code>make rebuild</code> - Update all binaries from recipes with source code changes (it don't detect changes on the Redox toolchain), it should be your normal <code>make</code> target.</li>
<li><code>make prefix</code> - Download the Rust/GCC forks and build relibc.</li>
<li><code>make fstools</code> - Build the Redox image builder (installer), Cookbook and RedoxFS.</li>
<li><code>make fetch</code> - Update recipe sources, according to each recipe, without building them. Only the recipes that are included in your <code>(CONFIG_NAME).toml</code> are downloaded. Does nothing if <code>$(BUILD)/fetch.tag</code> is present. You won't need this.</li>
<li><code>make cook</code> - Build recipes enabled in the active filesystem configuration</li>
<li><code>make repo</code> - Package the recipe binaries, according to each recipe. Does nothing if <code>$(BUILD)/repo.tag</code> is present. You won't need this.</li>
<li><code>make find</code> - Show the recipe packages location</li>
<li><code>make tree</code> - Show the filesystem configuration recipes and recipe dependencies tree</li>
<li><code>make image</code> - Builds a new QEMU image, <code>build/harddrive.img</code>, without checking if any recipes have changed. It can save you some time if you are just updating one recipe with <code>make r.recipe-name</code></li>
<li><code>make push</code> - Only install recipes with new changes in an existing Redox image</li>
<li><code>make mount</code> - Mounts the Redox image as a filesystem at <code>$(BUILD)/filesystem</code>. <strong>Do not use this if QEMU is running</strong>, and remember to use <code>make unmount</code> as soon as you are done. This is not recommended, but if you need to get a large file onto or off of your Redox image, this is available as a workaround.</li>
<li><code>make unmount</code> - Unmounts the Redox image filesystem. Use this as soon as you are done with <code>make mount</code>, and <strong>do not start QEMU</strong> until this is done.</li>
<li><code>make live</code> - Creates a bootable image, <code>build/livedisk.iso</code>. Recipes are not usually rebuilt.</li>
<li><code>make popsicle</code> - Flash the Redox bootable image on your USB device using the <a href="https://github.com/pop-os/popsicle">Popsicle</a> tool (the program executable must be present on your shell <code>$PATH</code> environment variable, you can get the executable by extracting the AppImage, installing from the package manager or building from source)</li>
<li><code>make mount_live</code> - Mount the live disk ISO</li>
<li><code>make env</code> - Creates a shell with a build environment configured to use the Redox toolchain. If you are using Podman Build it will change your current terminal shell to the container shell, you can use it to update crates of Rust programs or debug build issues such as missing packages (if you are using the Podman Build you can only use this command in one terminal shell, because it will block the build system directory access from other Podman shell)</li>
<li><code>make fstools_clean</code> - Clean the image builder, Cookbook and RedoxFS binaries.</li>
<li><code>make clean</code> - Clean all recipe binaries (Note that <code>make clean</code> may require some tools to be built).</li>
<li><code>make unfetch</code> - Clean all recipe sources.</li>
<li><code>make distclean</code> - Clean all recipe sources and binaries (<strong>please backup or submit your source changes before the execution of this command</strong>).</li>
</ul>
<h3 id="podman"><a class="header" href="#podman">Podman</a></h3>
<ul>
<li><code>make container_shell</code> - Open the GNU Bash shell of the Podman container as the active shell of your terminal, it's logged as the <code>podman</code> user without <code>root</code> privileges (don't use this command to replace the <code>make env</code> command because it don't setup the Redox toolchain in the Podman container shell)</li>
<li><code>make container_clean</code> - This will discard images and other files created by Podman.</li>
<li><code>make container_touch</code> - If you have removed the file <code>build/container.tag</code>, but the container image is still usable, this will recreate the <code>container.tag</code> file and avoid rebuilding the container image.</li>
<li><code>make container_kill</code> - If you have started a build using Podman Build, and you want to stop it, <code>Ctrl-C</code> may not be sufficient. Use this command to terminate the most recently created container.</li>
</ul>
<h3 id="recipe"><a class="header" href="#recipe">Recipe</a></h3>
<ul>
<li>
<p><code>make f.recipe-name</code> - Download the recipe source</p>
</li>
<li>
<p><code>make r.recipe-name</code> - Build a single recipe, checking if the recipe source has changed, and creating the executable, etc. e.g. <code>make r.games</code> (you can't use this command to replace the <code>make all</code>, <code>make fstools</code> and <code>make prefix</code> commands because it don't trigger them, make sure to run them before to avoid errors)</p>
<p>The package is built even if it is not in your filesystem configuration.</p>
<p>(This command will continue where you stopped the build process, it's useful to save time if you had a compilation error and patched a crate)</p>
</li>
<li>
<p><code>make p.recipe-name</code> - Install the recipe binaries to an existing Redox image</p>
</li>
<li>
<p><code>make c.recipe-name</code> - Clean the recipe binaries.</p>
</li>
<li>
<p><code>make u.recipe-name</code> - Clean the recipe source code and binaries (<strong>please backup or submit your source changes before the execution of this command</strong>).</p>
</li>
<li>
<p><code>make cr.recipe-name</code> - A shortcut for <code>make c.recipe r.recipe</code></p>
</li>
<li>
<p><code>make ur.recipe-name</code> - A shortcut for <code>make u.recipe r.recipe</code> (<strong>please backup or submit your source changes before the execution of this command</strong>).</p>
</li>
<li>
<p><code>make rp.recipe-name</code> - A shortcut for <code>make r.recipe p.recipe</code></p>
</li>
<li>
<p><code>make crp.recipe-name</code> - A shortcut for <code>make c.recipe r.recipe p.recipe</code></p>
</li>
<li>
<p><code>make static_clean</code> - Clean all statically linked recipe binaries</p>
</li>
<li>
<p><code>make repo_clean</code> - Clean all recipe binaries (alternative to <code>make c.--all</code>)</p>
</li>
<li>
<p><code>make fetch_clean</code> - Clean all recipe binaries and sources (alternative to <code>make u.--all</code>)</p>
</li>
<li>
<p><code>make x.--all</code> - Any recipe target (x) can be run in all recipes at <code>recipes</code> (like <code>make c.--all</code> which clean all recipe binaries, for example)</p>
</li>
<li>
<p><code>make x.--category-folder-name</code> - Any recipe target (x) can be run in all recipes of some category folder at <code>recipes</code> (like <code>make u.--category-wip</code> which clean all recipe sources and binaries from the <code>wip</code> folder, for example), if you need to use a sub-category use <code>--category-folder-name/subfolder</code></p>
</li>
</ul>
<p>All recipe targets also support multiple recipe entries by separating each recipe name with a comma. for example: <code>make f.recipe1,recipe2</code> will download the sources of <code>recipe1</code> and <code>recipe2</code></p>
<h3 id="qemuvirtualbox"><a class="header" href="#qemuvirtualbox">QEMU/VirtualBox</a></h3>
<ul>
<li><code>make qemu</code> - Boot Redox in QEMU, if a <code>build/harddrive.img</code> file exists QEMU will run using that image. If you want to force a rebuild first, run the <code>make rebuild qemu</code> command. Sometimes <code>make qemu</code> will detect changes and rebuild, but this is not typical. If you are interested in a particular combination of QEMU command line options, have a look through <code>mk/qemu.mk</code></li>
<li><code>make qemu gpu=no</code> - Start QEMU without a GUI (disables Orbital).</li>
<li><code>make qemu gpu=virtio</code> - Start QEMU with the VirtIO GPU driver.</li>
<li><code>make qemu audio=no</code> - Disable all sound drivers.</li>
<li><code>make qemu usb=no</code> - Disable all USB drivers.</li>
<li><code>make qemu uefi=yes</code> - Enable the UEFI boot loader (it supports more screen resolutions).</li>
<li><code>make qemu live=yes</code> - Fully load the Redox image to RAM.</li>
<li><code>make qemu disk=nvme</code> - Boot Redox from a NVMe interface (high-performance SSD emulation).</li>
<li><code>make qemu disk=usb</code> - Boot Redox from a virtual USB device.</li>
<li><code>make qemu disk=cdrom</code> - Boot Redox from a virtual CD-ROM disk.</li>
<li><code>make qemu kvm=no</code> - Start QEMU without the <a href="https://en.wikipedia.org/wiki/Kernel-based_Virtual_Machine">Linux KVM</a> acceleration if it's not supported.</li>
<li><code>make qemu iommu=yes</code> - Start QEMU with <a href="https://en.wikipedia.org/wiki/Input-output_memory_management_unit">IOMMU</a> enabled.</li>
<li><code>make qemu gdb=yes</code> - Start QEMU with the GDB configuration enabled, you need to run the <code>make rp.gdbserver</code> command before to install the GDB server in the Redox image (persist until the next image creation) or add the <code>gdbserver</code> recipe on your filesystem configuration (<code>gdbserver = {}</code>) to persist in new images, then run the <code>make gdb</code> command in another shell to connect the GDB processes.</li>
<li><code>make gdb</code> - Connects the host system GDB to the GDB server (<code>gdbserver</code> recipe) running inside of Redox in QEMU.</li>
<li><code>make qemu option1=value option2=value</code> - Cumulative QEMU options are supported.</li>
<li><code>make virtualbox</code> - Boot Redox in VirtualBox, it requires the VirtualBox service to be running, run <code>systemctl status vboxdrv.service</code> to verify or <code>akmods; systemctl restart vboxdrv.service</code> to enable on systems using systemd.</li>
</ul>
<h2 id="environment-variables-1"><a class="header" href="#environment-variables-1">Environment Variables</a></h2>
<ul>
<li><code>$(BUILD)</code> - Represents the <code>build</code> folder.</li>
<li><code>$(ARCH)</code> - Represents the CPU architecture folder at <code>build</code></li>
<li><code>${TARGET}</code> - Represents the CPU architecture folder at the <code>recipes/recipe-name/target</code> folder</li>
<li><code>$(CONFIG_NAME)</code> - Represents your filesystem configuration folder at <code>build/your-cpu-arch</code></li>
</ul>
<p>We recommend that you use these variables with the <code>"</code> symbol to clean any spaces on the path, spaces are interpreted as command separators and will break the commands.</p>
<p>Example:</p>
<pre><code>"${VARIABLE_NAME}"
</code></pre>
<p>If you have a folder inside the variable folder you can call it with:</p>
<pre><code>"${VARIABLE_NAME}"/folder-name
</code></pre>
<p>Or</p>
<pre><code>"${VARIABLE_NAME}/folder-name"
</code></pre>
<h2 id="scripts"><a class="header" href="#scripts">Scripts</a></h2>
<p>You can use these scripts to perform actions not implemented as <code>make</code> commands in the build system.</p>
<ul>
<li>To run a script use the following command:</li>
</ul>
<pre><code class="language-sh">scripts/script-name.sh input-text
</code></pre>
<p>The "input-text" is the word used by the script.</p>
<h3 id="changelog"><a class="header" href="#changelog">Changelog</a></h3>
<ul>
<li><code>scripts/changelog.sh</code> - Show the changelog of all Redox components.</li>
</ul>
<h3 id="recipe-files"><a class="header" href="#recipe-files">Recipe Files</a></h3>
<p>Show all files installed by a recipe.</p>
<pre><code class="language-sh">scripts/find-recipe.sh recipe-name
</code></pre>
<h3 id="recipe-categories"><a class="header" href="#recipe-categories">Recipe Categories</a></h3>
<p>Run <code>make</code> options on some recipe category.</p>
<pre><code class="language-sh">scripts/category.sh -x category-name
</code></pre>
<p>Where <code>x</code> is your <code>make</code> option, it can be <code>f</code>, <code>r</code>, <code>c</code>, <code>u</code>, <code>cr</code>, <code>ur</code> or <code>uf</code></p>
<h3 id="include-recipes"><a class="header" href="#include-recipes">Include Recipes</a></h3>
<p>Create a list with <code>recipe-name = {} #TODO</code> for quick testing of WIP recipes.</p>
<pre><code class="language-sh">scripts/include-recipes.sh "TODO.text"
</code></pre>
<p>You will insert the text after the <code>#TODO</code> in the <code>text</code> part, it can be found on the <code>recipe.toml</code> file of the recipe.</p>
<p>If you want to add recipes to the <code>ci.toml</code> filesystem configuration to be available on the package build server, the recipe names must be sorted in alphabetical order, to do this from the output of this script use the following command:</p>
<pre><code class="language-sh">scripts/include-recipes.sh "TODO.text" | sort
</code></pre>
<h3 id="recipe-analysis"><a class="header" href="#recipe-analysis">Recipe Analysis</a></h3>
<p>Show the folders and files on the <code>stage</code> and <code>sysroot</code> folders of some recipe (to identify packaging issues or violations).</p>
<pre><code class="language-sh">scripts/show-package.sh recipe-name
</code></pre>
<h3 id="recipe-commit-hash"><a class="header" href="#recipe-commit-hash">Recipe Commit Hash</a></h3>
<p>Show the current Git branch and commit of the recipe source.</p>
<pre><code class="language-sh">scripts/commit-hash.sh recipe-name
</code></pre>
<h3 id="package-size"><a class="header" href="#package-size">Package Size</a></h3>
<p>Show the package size of the recipes (<code>stage.pkgar</code> and <code>stage.tar.gz</code>), it must be used by package maintainers to enforce the <a href="https://gitlab.redox-os.org/redox-os/cookbook#library-linking">library linking size policy</a>.</p>
<pre><code class="language-sh">scripts/pkg-size.sh recipe-name
</code></pre>
<h3 id="recipe-location"><a class="header" href="#recipe-location">Recipe Location</a></h3>
<p>Show the location of the written recipe.</p>
<pre><code class="language-sh">scripts/recipe-path.sh recipe-name
</code></pre>
<h3 id="recipe-match"><a class="header" href="#recipe-match">Recipe Match</a></h3>
<p>Search some text inside the <code>recipe.toml</code> of all recipes and show their content.</p>
<p>(Require <code>bat</code> and <code>ripgrep</code> installed, run <code>cargo install bat ripgrep</code> to install)</p>
<pre><code class="language-sh">scripts/recipe-match.sh "text"
</code></pre>
<h3 id="print-recipe"><a class="header" href="#print-recipe">Print Recipe</a></h3>
<p>Show the content of the recipe configuration.</p>
<pre><code class="language-sh">scripts/print-recipe.sh recipe-name
</code></pre>
<h3 id="recipe-executables"><a class="header" href="#recipe-executables">Recipe Executables</a></h3>
<p>List the recipe executables to find duplicates and conflicts.</p>
<ul>
<li>By default the script will only verify duplicates, if the <code>-a</code> option is used it will print the executable names of all compiled recipes</li>
<li>The <code>-arm64</code> option will show the ARM64 recipe executables</li>
<li>The <code>-i586</code> option will show the i586 recipe executables</li>
</ul>
<pre><code class="language-sh">scripts/executables.sh
</code></pre>
<h3 id="cargo-update"><a class="header" href="#cargo-update">Cargo Update</a></h3>
<p>Download the recipe source and run <code>cargo update</code></p>
<pre><code class="language-sh">scripts/cargo-update.sh recipe-name
</code></pre>
<h3 id="dual-boot"><a class="header" href="#dual-boot">Dual Boot</a></h3>
<ul>
<li><code>scripts/dual-boot.sh</code> - Install Redox in the free space of your storage device and add a boot entry (if you are using the <a href="https://www.freedesktop.org/wiki/Software/systemd/systemd-boot/">systemd-boot</a> boot loader).</li>
</ul>
<h3 id="ventoy"><a class="header" href="#ventoy">Ventoy</a></h3>
<ul>
<li><code>scripts/ventoy.sh</code> - Create and copy the Redox bootable image to an <a href="https://www.ventoy.net/en/index.html">Ventoy</a>-formatted device.</li>
</ul>
<h3 id="recipe-debugging-rust"><a class="header" href="#recipe-debugging-rust">Recipe Debugging (Rust)</a></h3>
<ul>
<li><code>scripts/backtrace.sh</code> - Allow the user to copy a Rust backtrace from Redox and retrieve the symbols (use the <code>-h</code> option to show the "Usage" message).</li>
</ul>
<h2 id="git-auto-checkout"><a class="header" href="#git-auto-checkout">Git Auto-checkout</a></h2>
<p>The <code>make rebuild</code> and <code>make r.recipe</code> commands will Git checkout (change the active branch) of the recipe source to <code>master</code> (only recipes that fetch Git repositories are affected, thus all Redox components).</p>
<p>If you are working in a separated branch on the recipe source you can't build your changes, to avoid this comment out the <code>[source]</code> and <code>git =</code> fields from your <code>recipe.toml</code> :</p>
<pre><code>#[source]
#git = "some-repository-link"
</code></pre>
<h2 id="update-the-build-system"><a class="header" href="#update-the-build-system">Update The Build System</a></h2>
<p>This is the recommended way to update your build system/recipe sources and binaries.</p>
<pre><code class="language-sh">make pull rebuild
</code></pre>
<p>Sometimes you need to update the statically linked recipes manually with the <code>make static_clean rebuild</code> command or also rebuild all dynamically linked recipes with the <code>make repo_clean all</code> command.</p>
<p>(The Podman container is updated automatically if upstream add new packages to the Containerfile, but you can also force the container image to be updated with the <code>make container_clean</code> command)</p>
<h2 id="fix-breaking-changes"><a class="header" href="#fix-breaking-changes">Fix Breaking Changes</a></h2>
<p>To learn how to fix breaking changes before and after build system updates read <a href="./troubleshooting.html#fix-breaking-changes">this</a> section.</p>
<h3 id="all-recipes"><a class="header" href="#all-recipes">All recipes</a></h3>
<p>To pass the new relibc changes for all recipes (programs are the most common case) you will need to rebuild all recipes, unfortunately it's not possible to use <code>make rebuild</code> because it can't detect the relibc changes to trigger a complete rebuild.</p>
<p>To clean all recipe binaries and trigger a complete rebuild, run:</p>
<pre><code class="language-sh">make clean all
</code></pre>
<h3 id="one-recipe"><a class="header" href="#one-recipe">One Recipe</a></h3>
<p>To pass the new relibc changes to one recipe, run:</p>
<pre><code class="language-sh">make cr.recipe-name
</code></pre>
<h2 id="configuration"><a class="header" href="#configuration">Configuration</a></h2>
<p>You can find the global settings on the <a href="./configuration-settings.html">Configuration Settings</a> page.</p>
<h3 id="format-1"><a class="header" href="#format-1">Format</a></h3>
<p>The Redox configuration files use the <a href="https://toml.io/en/">TOML</a> format, it has a very easy syntax and is very flexbile.</p>
<p>You can see what the format supports on the <a href="https://toml.io/en/v1.0.0">TOML</a> website.</p>
<h3 id="filesystem-customization-1"><a class="header" href="#filesystem-customization-1">Filesystem Customization</a></h3>
<p>Read the <a href="./configuration-settings.html#filesystem-customization">Filesystem Customization</a> section.</p>
<h2 id="cross-compilation"><a class="header" href="#cross-compilation">Cross-Compilation</a></h2>
<p>The Redox build system is an example of <a href="https://en.wikipedia.org/wiki/Cross_compiler">cross-compilation</a>. The Redox <a href="https://static.redox-os.org/toolchain/">toolchain</a> runs on Linux, and produces Redox executables. Anything that is installed with your package manager is just part of the toolchain and does not go on Redox.</p>
<p>In the background, the <code>make all</code> command downloads the Redox toolchain to build all recipes (patched forks of rustc, GCC and LLVM).</p>
<p>If you are using Podman, the <code>podman_bootstrap.sh</code> script will download an Ubuntu container and <code>make all</code> will install the Redox toolchain, all recipes will be compiled in the container.</p>
<p>The recipes produce Redox-specific executables. At the end of the build process, these executables are installed inside the QEMU image.</p>
<p>The <code>relibc</code> (Redox C Library) provides the Redox <a href="https://docs.rs/redox_syscall/latest/syscall/">system calls</a> to any software.</p>
<ul>
<li><a href="https://wiki.osdev.org/Why_do_I_need_a_Cross_Compiler%3F">OSDev article about cross-compilation</a></li>
</ul>
<h2 id="build-phases"><a class="header" href="#build-phases">Build Phases</a></h2>
<p>Every build system command/script has phases, read this page to know them.</p>
<ul>
<li><a href="./build-phases.html">Build Phases</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advanced-podman-build"><a class="header" href="#advanced-podman-build">Advanced Podman Build</a></h1>
<p>To make the Redox build process more consistent across platforms, we are using <strong>Rootless Podman</strong> for major parts of the build.</p>
<p>Before reading through this section, make sure you have already read:</p>
<ul>
<li><a href="./podman-build.html">Podman Build</a></li>
<li><a href="./build-system-reference.html">Build System Reference</a></li>
</ul>
<p>This chapter provides a detailed discussion, including tips, tricks and troubleshooting, as well as some extra detail for those who might want to leverage or improve Redox's use of Podman.</p>
<h2 id="build-environment"><a class="header" href="#build-environment">Build Environment</a></h2>
<ul>
<li>
<p>Environment and command line Variables, other than <code>ARCH</code>, <code>CONFIG_NAME</code> and <code>FILESYSTEM_CONFIG</code>, are not passed to the part of <code>make</code> that is done in <strong>Podman</strong>. You must set any other configuration variables, e.g. <code>REPO_BINARY</code>, in <a href="./configuration-settings.html#config">.config</a> and not on the command line or on your environment.</p>
</li>
<li>
<p>If you are building your own software to add in Redox, and you need to install additional packages using <code>apt-get</code> for the build, follow the <a href="advanced-podman-build.html#adding-packages-to-the-build">Adding Packages to the Build</a> section.</p>
</li>
</ul>
<h2 id="installation"><a class="header" href="#installation">Installation</a></h2>
<p>Most of the packages required for the build are installed in the container as part of the build process. However, some packages need to be installed on the host operating system. You may also need to install an emulator such as <strong>QEMU</strong>. For most Linux distributions, this is done for you in the <code>podman_bootstrap.sh</code> script.</p>
<p>If you can't use the <code>podman_bootstrap.sh</code> script, you need to install at least:</p>
<ul>
<li>Podman 4.0 or later</li>
<li>Rust</li>
<li>libfuse 3.x (to build an image)</li>
<li>QEMU (to run the image)</li>
</ul>
<p>You can attempt to install the necessary packages below.</p>
<h3 id="pop_osubuntudebian"><a class="header" href="#pop_osubuntudebian">Pop!_OS/Ubuntu/Debian</a></h3>
<pre><code class="language-sh">sudo apt-get install git make curl podman fuse fuse-overlayfs slirp4netns qemu-system-x86 qemu-kvm qemu-system-arm qemu-system-riscv
</code></pre>
<blockquote>
<p>âš ï¸ <strong>Warning:</strong> Ubuntu 22.04 ships with old Podman (3.x version), which will have issues. The official <a href="https://podman.io/docs/installation#ubuntu">Podman installation guide</a> requires Ubuntu 20.10 and newer to operate. If you do use the 22.04 version or older, please read <a href="advanced-podman-build.html#gory-details">Gory Details</a>.</p>
</blockquote>
<h3 id="arch-linux"><a class="header" href="#arch-linux">Arch Linux</a></h3>
<pre><code class="language-sh">sudo pacman -S --needed git make curl podman fuse3 fuse-overlayfs slirp4netns qemu-system-x86 qemu-system-arm qemu-system-riscv
</code></pre>
<h3 id="fedora"><a class="header" href="#fedora">Fedora</a></h3>
<pre><code class="language-sh">sudo dnf install git-all make curl podman fuse3 fuse-overlayfs slirp4netns qemu-system-x86 qemu-kvm qemu-system-arm qemu-system-riscv
</code></pre>
<h3 id="opensuse"><a class="header" href="#opensuse">OpenSUSE</a></h3>
<pre><code class="language-sh">sudo zypper install git make curl podman fuse fuse-overlayfs slipr4netns
</code></pre>
<h3 id="freebsd"><a class="header" href="#freebsd">FreeBSD</a></h3>
<pre><code class="language-sh">sudo pkg install git gmake curl fusefs-libs3 podman
</code></pre>
<h3 id="macos"><a class="header" href="#macos">MacOS</a></h3>
<p>Building Redox using MacOS is experimental at the moment, even if using Podman you will experience <a href="https://github.com/containers/podman/issues/26185">clock skew</a> which breaks the Makefile caching mechanism.</p>
<p>We recommend you to install QEMU, VirtualBox or <a href="https://mac.getutm.app/">UTM</a> and create ARM64 or x86-64 Linux distribution virtual machine to build Redox and follow Podman or Native Build using the Linux distribution of your choice.</p>
<p>If you insist on using MacOS, please read <a href="advanced-podman-build.html#installing-without-fuse">Installing without FUSE</a>. Otherwise, you will have a problem installing FUSE which requires you to turn off <a href="https://en.wikipedia.org/wiki/System_Integrity_Protection">SIP</a> for Apple Silicon-based MacOS.</p>
<ul>
<li>Homebrew</li>
</ul>
<pre><code class="language-sh">sudo brew install git make curl osxfuse podman fuse-overlayfs slirp4netns
</code></pre>
<ul>
<li>MacPorts</li>
</ul>
<pre><code class="language-sh">sudo port install git gmake curl osxfuse podman
</code></pre>
<h3 id="nixos"><a class="header" href="#nixos">NixOS</a></h3>
<p>Before building Redox with NixOS, you must have configured Podman on your system. Just follow the instructions of the <a href="https://nixos.wiki/wiki/Podman">NixOS wiki</a>:</p>
<pre><code class="language-nix">{ pkgs, ... }:
{
  # Enable common container config files in /etc/containers
  virtualisation.containers.enable = true;
  virtualisation = {
    podman = {
      enable = true;

      # Create a `docker` alias for podman, to use it as a drop-in replacement
      dockerCompat = true;

      # Required for containers under podman-compose to be able to talk to each other.
      defaultNetwork.settings.dns_enabled = true;
    };
  };

  # Useful other development tools
  environment.systemPackages = with pkgs; [
    dive # look into docker image layers
    podman-tui # status of containers in the terminal
    docker-compose # start group of containers for dev
    podman-compose # start group of containers for dev
  ];
}
        
</code></pre>
<p>You will then have to configure your user to be able to use Podman:</p>
<pre><code class="language-nix">users.extraUsers.${user-name} = {
  subUidRanges = [{ startUid = 100000; count = 65536; }];
  subGidRanges = [{ startGid = 100000; count = 65536; }];
};
</code></pre>
<p>The last step is to activate the development shell:</p>
<pre><code class="language-sh">nix develop --no-warn-dirty --command $SHELL
</code></pre>
<h2 id="buildcontainertag"><a class="header" href="#buildcontainertag"><code>build/container.tag</code></a></h2>
<p>The building of the <strong>image</strong> is controlled by the <em>tag</em> file <code>build/container.tag</code>. If you run <code>make all</code> with <code>PODMAN_BUILD=1</code> in <code>.config</code>, the file <code>build/container.tag</code> will be created after the image is built. This file tells <code>make</code> that it can skip the image update after the first time.</p>
<p>Many targets in the Makefiles <code>mk/*.mk</code> include <code>build/container.tag</code> as a dependency. If the <em>tag</em> file is missing, building any of those targets may trigger an image to be created, which can take some time.</p>
<p>When you move to a new working directory, if you want to save a few minutes, and you are confident that your <strong>image</strong> is correct and your <code>poduser</code> home directory <code>build/podman/poduser</code> is valid, you can do</p>
<pre><code class="language-sh">make container_touch
</code></pre>
<p>This will create the file <code>build/container.tag</code> without rebuilding the image. However, it will fail if the image does not exist. If it fails, just do a normal <code>make</code>, it will create the container when needed.</p>
<h2 id="installing-without-fuse"><a class="header" href="#installing-without-fuse">Installing without FUSE</a></h2>
<p>If installing FUSE is difficult for your operating system, you can avoid installing it by adding <code>FSTOOLS_IN_PODMAN=1</code> in the <code>.config</code> file. It makes the installer run inside Podman. If you do set it, then you can avoid installing FUSE and Rust altogether in your host system.</p>
<p>An additional environment variable (<code>FSTOOLS_NO_MOUNT</code>) can also be set to not use FUSE during image creation, however image creation relies on correct files permission bit and ownership which means it only can be used within Podman. This configuration can be used as a last resort if FUSE is not working at all.</p>
<h2 id="cleaning-up"><a class="header" href="#cleaning-up">Cleaning Up</a></h2>
<p>To remove the <strong>base image</strong>, any lingering containers, <code>poduser</code>'s home directory, including the <strong>Rust</strong> installation, and <code>build/container.tag</code>, run:</p>
<pre><code class="language-sh">make container_clean
</code></pre>
<ul>
<li>To verify that everything has been removed</li>
</ul>
<pre><code class="language-sh">podman ps -a
</code></pre>
<ul>
<li>Show any remaining images or containers</li>
</ul>
<pre><code class="language-sh">podman images
</code></pre>
<ul>
<li>Remove <strong>all</strong> images and containers. You still may need to remove <code>build/container.tag</code> if you did not do <code>make container_clean</code>.</li>
</ul>
<pre><code class="language-sh">podman system reset
</code></pre>
<p><strong>Note:</strong></p>
<ul>
<li><code>make clean</code> does <strong>not</strong> run <code>make container_clean</code> and will <strong>not</strong> remove the container image.</li>
<li>If you already did <code>make container_clean</code>, doing <code>make clean</code> will not work.</li>
</ul>
<h2 id="debugging-your-build-process"><a class="header" href="#debugging-your-build-process">Debugging Your Build Process</a></h2>
<p>If you are developing your own components and wish to do one-time debugging to determine what library you are missing in the <strong>Podman Build</strong> environment, the following instructions can help. Note that your changes will not be persistent. After debugging, <strong>you must</strong> <a href="advanced-podman-build.html#adding-packages-to-the-build">Add your Libraries to the Build</a>. With <code>PODMAN_BUILD=1</code>, run the following command:</p>
<pre><code class="language-sh">make container_shell
</code></pre>
<ul>
<li>Within that environment, you can build the Redox components with:</li>
</ul>
<pre><code class="language-sh">make repo
</code></pre>
<ul>
<li>If you need to change <code>ARCH</code> or <code>CONFIG_NAME</code>, run:</li>
</ul>
<pre><code class="language-sh">./build.sh -a ARCH -c CONFIG_NAME repo
</code></pre>
<p><strong>Note</strong>: Your changes will not persist once both shells have been exited.</p>
<p>Type <code>exit</code> on both shells once you have determined how to solve your problem.</p>
<h2 id="adding-packages-to-the-build"><a class="header" href="#adding-packages-to-the-build">Adding Packages to the Build</a></h2>
<blockquote>
<p>ğŸ“ <strong>Note:</strong> This section is no longer being recommended as the primary way to do development on new recipes. Any new dependencies should be compiled in a Cookbook recipe using the <code>host:recipe-name</code> syntax.</p>
</blockquote>
<p>This method can be used if you want to make changes/testing inside the Debian container with <code>make env</code>.</p>
<p>The default <strong>Containerfile</strong>, <code>podman/redox-base-containerfile</code>, imports all required packages for a normal Redox build.</p>
<p>However, you cannot easily add packages after the <strong>base image</strong> is created. You must add them to your own Containerfile and rebuild the container image.</p>
<p>Copy <code>podman/redox-base-containerfile</code> and add to the list of packages in the initial <code>apt-get</code>.</p>
<pre><code class="language-sh">cp podman/redox-base-containerfile podman/my-containerfile
</code></pre>
<pre><code class="language-sh">nano podman/my-containerfile
</code></pre>
<pre><code>...
        xxd \
        rsync \
        MY_PACKAGE \
...
</code></pre>
<p>Make sure you include the continuation character <code>\</code> at the end of each line except after the last package.</p>
<p>Then, edit <a href="./configuration-settings.html#config">.config</a>, and change the variable <code>CONTAINERFILE</code> to point to your Containerfile, e.g.</p>
<pre><code>CONTAINERFILE?=podman/my-containerfile
</code></pre>
<p>If your Containerfile is newer than <code>build/container.tag</code>, a new <strong>image</strong> will be created. You can force the image to be rebuilt with <code>make container_clean</code>.</p>
<p>If you feel the need to have more than one image, you can change the variable <code>IMAGE_TAG</code> in <code>mk/podman.mk</code> to give the image a different name.</p>
<p>If you just want to install the packages temporarily, run <code>make env</code>, open a new terminal tab/windows, run <code>make container_shell</code> and use <code>apt install</code> on this tab/window.</p>
<h2 id="summary-of-podman-related-make-targets-variables-and-podman-commands"><a class="header" href="#summary-of-podman-related-make-targets-variables-and-podman-commands">Summary of Podman-related Make Targets, Variables and Podman Commands</a></h2>
<ul>
<li>
<p><code>PODMAN_BUILD</code> - If set to 1 in <a href="./configuration-settings.html#config">.config</a>, or in the environment, or on the <code>make</code> command line, much of the build process takes place in <strong>Podman</strong>.</p>
</li>
<li>
<p><code>CONTAINERFILE</code>-  The name of the containerfile used to build the image. This file includes the <code>apt-get</code> command that installs all the necessary packages into the image. If you need to add packages to the build, edit your own containerfile and change this variable to point to it.</p>
</li>
<li>
<p><code>make build/container.tag</code> - If no container image has been built, build one. It's not necessary to do this, it will be done when needed.</p>
</li>
<li>
<p><code>make container_touch</code> - If a container image already exists and <code>poduser</code>'s home directory is valid, but there is no <em>tag</em> file, create the <em>tag</em> file so a new image is not built.</p>
</li>
<li>
<p><code>make container_clean</code> - Remove the container image, <code>poduser</code>'s home directory and the <em>tag</em> file.</p>
</li>
<li>
<p><code>make container_shell</code> - Start an interactive Podman <code>bash</code> shell in the same environment used by <code>make</code>; for debugging the <code>apt-get</code> commands used during image build.</p>
</li>
<li>
<p><code>make env</code> - Start an interactive <code>bash</code> shell with the <code>prefix</code> tools in your PATH. Automatically determines if this should be a Podman shell or a host shell, depending on the value of <code>PODMAN_BUILD</code>.</p>
</li>
<li>
<p><code>make repo</code> or <code>./build.sh -a ARCH -c CONFIG repo</code> - Used while in a Podman shell to build all the Redox component packages. <code>make all</code> will not complete successfully, since part of the build process must take place on the host.</p>
</li>
<li>
<p><code>podman system reset</code> - Use this command when <code>make container_clean</code> is not sufficient to solve problems caused by errors in the container image. It will remove all images, use with caution. If you are using <strong>Podman</strong> for any other purpose, those images will be deleted as well.</p>
</li>
</ul>
<h2 id="gory-details"><a class="header" href="#gory-details">Gory Details</a></h2>
<p>If you are interested in how we are able to use your working directory for builds in <strong>Podman</strong>, the following configuration details may be interesting.</p>
<p>Historically, we've used <code>--userns keep-id</code> which the <em>container's</em> <code>root</code> user is actually mapped to your User ID on the host system. It was necessary in Podman 3.x and previous versions as Podman user mapping was not quite good and often broke with <a href="https://github.com/containers/podman/issues/14655">tar</a> and <a href="https://github.com/containers/buildah/issues/1818">buildah</a>. In Podman 4.x onwards that it no longer necessary and we can drop it.</p>
<p>For Ubuntu 22.04 there's a temporary fix to it by <a href="https://github.com/microsoft/vscode-remote-release/issues/11042#issuecomment-3044713731">manually updating crun</a>.</p>
<p>The working directory is made available in the container by <strong>mounting</strong> it as a <strong>volume</strong>. The <strong>Podman</strong> option:</p>
<pre><code class="language-sh">--volume "`pwd`":$(CONTAINER_WORKDIR):Z
</code></pre>
<p>takes the directory that <code>make</code> was started in as the host working directory, and <strong>mounts</strong> it at the location <code>$CONTAINER_WORKDIR</code>, normally set to <code>/mnt/redox</code>. The <code>:Z</code> at the end of the name indicates that the mounted directory should not be shared between simultaneous container instances. It is optional on some Linux distros, and not optional on others.</p>
<p>For our invocation of Podman, we set the PATH environment variable as an option to <code>podman run</code>. This is to avoid the need for our <code>make</code> command to run <code>.bashrc</code>, which would add extra complexity. The <code>ARCH</code>, <code>CONFIG_NAME</code> and <code>FILESYSTEM_CONFIG</code> variables are passed in the environment to allow you to override the values in <code>mk/config.mk</code> or <code>.config</code>, e.g. by setting them on your <code>make</code> command line or by using <code>build.sh</code>.</p>
<p>We also set <code>PODMAN_BUILD=0</code> in the environment, to ensure that the instance of <code>make</code> running in the container knows not to invoke <strong>Podman</strong>. This overrides the value set in <code>.config</code>.</p>
<p>In the <strong>Containerfile</strong>, we use as few <code>RUN</code> commands as possible, as <strong>Podman</strong> commits the image after each command. And we avoid using <code>ENTRYPOINT</code> to allow us to specify the <code>podman run</code> command as a list of arguments, rather than just a string to be processed by the entrypoint shell.</p>
<p>Containers in our build process are run with <code>--rm</code> to ensure the container is discarded after each use. This prevents a proliferation of used containers. However, when you use <code>make container_clean</code>, you may notice multiple items being deleted. These are the partial images created as each <code>RUN</code> command is executed while building.</p>
<p>Container images and container data is normally stored in the directory <code>$HOME/.local/share/containers/storage</code>. The following command removes that directory in its entirety. However, the contents of any <strong>volume</strong> are left alone:</p>
<pre><code class="language-sh">podman system reset
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advanced-build"><a class="header" href="#advanced-build">Advanced Build</a></h1>
<p>In this section, we provide the gory details that may be handy to know if you are contributing to or developing for <strong>Redox</strong>.</p>
<p>Before reading through this section, make sure you have already read:</p>
<ul>
<li><a href="./podman-build.html">Podman Build</a></li>
<li><a href="./building-redox.html">Native Build</a></li>
<li><a href="./build-system-reference.html">Build System Reference</a></li>
</ul>
<h2 id="setup-your-environment"><a class="header" href="#setup-your-environment">Setup Your Environment</a></h2>
<p>Advanced users may accomplish the same as the <a href="https://gitlab.redox-os.org/redox-os/redox/-/blob/master/native_bootstrap.sh"><strong>native_bootstrap.sh</strong></a> script with the following steps:</p>
<ul>
<li><a href="advanced-build.html#clone-the-repository">Clone The Repository</a></li>
<li><a href="advanced-build.html#install-the-necessary-packages-and-emulators">Install The Necessary Packages</a></li>
<li><a href="advanced-build.html#install-rust-stable-and-nightly">Install Rust</a></li>
<li><a href="./configuration-settings.html">Adjust Your Configuration Settings</a></li>
<li>Build the system</li>
</ul>
<h2 id="clone-the-repository"><a class="header" href="#clone-the-repository">Clone The Repository</a></h2>
<ul>
<li>Create a directory and clone the repository</li>
</ul>
<pre><code class="language-sh">mkdir -p ~/tryredox
</code></pre>
<pre><code class="language-sh">cd ~/tryredox
</code></pre>
<pre><code class="language-sh">git clone https://gitlab.redox-os.org/redox-os/redox.git --origin upstream
</code></pre>
<pre><code class="language-sh">cd redox
</code></pre>
<pre><code class="language-sh">make pull
</code></pre>
<p>Please be patient, this can take minutes to hours depending on the hardware and network you're using.</p>
<p>In addition to installing the various packages needed for building Redox, <strong>native_bootstrap.sh</strong> and <strong>podman_bootstrap.sh</strong> both clone the repository, so if you used either script, you have completed Step 1.</p>
<h2 id="install-the-necessary-packages-and-emulator"><a class="header" href="#install-the-necessary-packages-and-emulator">Install The Necessary Packages and Emulator</a></h2>
<p>If you cloned the sources <em>before</em> running <strong>native_bootstrap.sh</strong>, you can use:</p>
<pre><code class="language-sh">cd ~/tryredox/redox
</code></pre>
<pre><code class="language-sh">./native_bootstrap.sh -d
</code></pre>
<p>If you can't use the <code>native_bootstrap.sh</code> script, you need to install at least:</p>
<ul>
<li>Essential compilers: GCC, Rust and Nasm</li>
<li>GNU search, text, and build tools: <code>find</code>, <code>grep</code>, <code>make</code>, <code>patch</code>, <code>pkg-config</code>, and <code>sed</code></li>
<li>Other build tools: <code>autotools</code>, <code>cmake</code>, <code>meson</code>, <code>perl</code> and <code>python3</code></li>
<li>Other file tooling: <code>curl</code>, <code>rsync</code>, <code>tar</code> and <code>wget</code></li>
<li>Libraries to build GCC: <code>gmp</code>, <code>mpfr</code> and <code>mpc</code></li>
<li>Rust tooling: <code>cbindgen</code> and <code>just</code></li>
<li>FUSE (to build an image) and QEMU (to run the image)</li>
</ul>
<p>Additional programs or libraries might be needed to build more packages. You can attempt to install the necessary packages below.</p>
<blockquote>
<p>âš ï¸ <strong>Warning:</strong> The following commands may be outdated</p>
</blockquote>
<blockquote>
<p>ğŸ“ <strong>Note:</strong> Always use the latest stable version of the Linux or Unix-like distribution of your choice, as any outdated tools might result in unexpected build errors. Redox cross-compilation is guaranteed to work reliably only in the current Podman environment, which is Debian 13 (Trixie).</p>
</blockquote>
<h3 id="pop_osubuntudebian-users"><a class="header" href="#pop_osubuntudebian-users">Pop!_OS/Ubuntu/Debian Users</a></h3>
<p>Install the build system dependencies:</p>
<pre><code class="language-sh">sudo apt-get install ant autoconf automake autopoint bison \
build-essential clang cmake curl dos2unix doxygen file flex \
fuse3 g++ genisoimage git gperf intltool libexpat-dev libfuse-dev \
libgmp-dev libhtml-parser-perl libjpeg-dev libmpfr-dev libpng-dev \
libsdl1.2-dev libsdl2-ttf-dev libtool llvm lua5.4 m4 make meson nasm \
ninja-build patch perl pkg-config po4a protobuf-compiler python3 \
python3-mako rsync scons texinfo unzip wget xdg-utils xxd zip zstd
</code></pre>
<ul>
<li>If you want to use QEMU, run:</li>
</ul>
<pre><code class="language-sh">sudo apt-get install qemu-system-x86 qemu-kvm qemu-system-arm qemu-system-riscv
</code></pre>
<ul>
<li>If you want to use VirtualBox, run:</li>
</ul>
<pre><code class="language-sh">sudo apt-get install virtualbox
</code></pre>
<h3 id="fedora-users"><a class="header" href="#fedora-users">Fedora Users</a></h3>
<p>Install the build system dependencies:</p>
<pre><code class="language-sh">sudo dnf install autoconf vim bison flex genisoimage gperf \
glibc-devel.i686 expat expat-devel fuse-devel fuse3-devel gmp-devel \
libpng-devel perl perl-HTML-Parser libtool libjpeg-turbo-devel
SDL2_ttf-devel sdl12-compat-devel m4 nasm po4a syslinux \
texinfo ninja-build meson waf python3-mako make gcc gcc-c++ \
openssl patch automake perl-Pod-Html perl-FindBin gperf curl \
gettext-devel perl-Pod-Xhtml pkgconf-pkg-config cmake llvm zip \
unzip lua luajit make clang doxygen ant protobuf-compiler zstd
</code></pre>
<ul>
<li>If you want to use QEMU, run:</li>
</ul>
<pre><code class="language-sh">sudo dnf install qemu-system-x86 qemu-kvm qemu-system-arm qemu-system-riscv
</code></pre>
<ul>
<li>If you want to use VirtualBox, install from the VirtualBox <a href="https://www.virtualbox.org/wiki/Linux_Downloads">Linux Downloads</a> page.</li>
</ul>
<h3 id="arch-linux-users"><a class="header" href="#arch-linux-users">Arch Linux Users</a></h3>
<p>Install the build system dependencies:</p>
<pre><code class="language-sh">pacman -S --needed cmake fuse git gperf perl-html-parser nasm \
wget texinfo bison flex po4a autoconf curl file patch automake \
scons waf expat gmp libtool libpng libjpeg-turbo sdl12-compat \
m4 pkgconf po4a syslinux meson python python-mako make xdg-utils \
zip unzip llvm clang perl doxygen lua ant protobuf
</code></pre>
<ul>
<li>If you want to use QEMU, run:</li>
</ul>
<pre><code class="language-sh">sudo pacman -S qemu-system-x86 qemu-system-arm qemu-system-riscv
</code></pre>
<ul>
<li>If you want to use VirtualBox, run:</li>
</ul>
<pre><code class="language-sh">sudo pacman -S virtualbox
</code></pre>
<h3 id="opensuse-users"><a class="header" href="#opensuse-users">OpenSUSE Users</a></h3>
<p>Install the build system dependencies:</p>
<pre><code class="language-sh">sudo zypper install gcc gcc-c++ glibc-devel-32bit nasm make fuse-devel \
cmake openssl automake gettext-tools libtool po4a patch flex gperf autoconf \
bison curl wget file libexpat-devel gmp-devel libpng16-devel libjpeg8-devel \
perl perl-HTML-Parser m4 patch scons pkgconf syslinux-utils ninja meson python-Mako \
xdg-utils zip unzip llvm clang doxygen lua54 ant protobuf
</code></pre>
<ul>
<li>If you want to use QEMU, run:</li>
</ul>
<pre><code class="language-sh">sudo zypper install qemu-x86 qemu-kvm
</code></pre>
<h3 id="gentoo-users"><a class="header" href="#gentoo-users">Gentoo Users</a></h3>
<p>Install the build system dependencies:</p>
<pre><code class="language-sh">sudo emerge dev-lang/nasm dev-vcs/git sys-fs/fuse
</code></pre>
<ul>
<li>If you want to use QEMU, run:</li>
</ul>
<pre><code class="language-sh">sudo emerge app-emulation/qemu
</code></pre>
<ul>
<li>If you want to use VirtualBox, install from the VirtualBox <a href="https://www.virtualbox.org/wiki/Linux_Downloads">Linux Downloads</a> page.</li>
</ul>
<h3 id="gnu-guix-users"><a class="header" href="#gnu-guix-users">GNU Guix Users</a></h3>
<p>Rust nightly isn't packaged in Guix currently, so you need a FHS-enabled container to use rustup:</p>
<pre><code class="language-sh">guix shell --pure --container --emulate-fhs --network --share=$HOME \
  coreutils bash curl grep gcc-toolchain@14.3.0 nss-certs \
  -- bash -c 'curl --proto "=https" --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y --default-toolchain nightly'

guix shell --pure --container --emulate-fhs --network --share=$HOME \
  coreutils bash gcc-toolchain@14.3.0 nss-certs zlib glibc \
  -- bash -c 'export LD_LIBRARY_PATH=$(dirname $(gcc -print-file-name=libgcc_s.so.1)):$LD_LIBRARY_PATH &amp;&amp; source ~/.cargo/env &amp;&amp; cargo install cbindgen'
</code></pre>
<p>Then you will be able to run the actual build except for the part that uses FUSE to build the root filesystem. Modify <code>tryredox/redox</code> in the command below to match where your sources are:</p>
<pre><code class="language-sh">guix shell --pure --container --emulate-fhs --network --share=$HOME \
  coreutils bash curl wget gcc-toolchain@14.3.0 pkg-config fuse nss-certs zlib \
  grep make which findutils sed gawk diffutils tar gzip perl git git-lfs \
  binutils nasm just m4 patch autoconf automake help2man texinfo xz \
  bzip2 mpfr gmp file ncurses readline flex bison python ninja cmake \
  -- bash -c '
export LD_LIBRARY_PATH="/lib64:/lib:$LD_LIBRARY_PATH"
export CI=1
source ~/.cargo/env
cd ~/tryredox/redox
make all PODMAN_BUILD=0 REPO_BINARY=1
'
</code></pre>
<p>The FUSE portion needs to run outside of a Guix shell container. To do that, we will patch the Rust executables so they can find <code>libgcc_s.so.1</code> under <code>/gnu/store</code> instead of <code>/lib</code> :</p>
<pre><code class="language-sh">LIBGCC_DIR=$(guix shell --container --emulate-fhs gcc-toolchain bash coreutils \
  -- bash -c 'dirname $(readlink -f /lib64/libgcc_s.so.1)')
</code></pre>
<pre><code class="language-sh">guix shell patchelf -- patchelf --set-rpath "$LIBGCC_DIR" build/fstools/bin/redox_installer
</code></pre>
<pre><code class="language-sh">guix shell patchelf -- patchelf --set-rpath "$LIBGCC_DIR" build/fstools/bin/redoxfs
</code></pre>
<pre><code class="language-sh">guix shell patchelf -- patchelf --set-rpath "$LIBGCC_DIR" build/fstools/bin/redoxfs-mkfs
</code></pre>
<p>Finally, you can run the image building part outside of a container so that FUSE works and launch qemu:</p>
<pre><code class="language-sh">guix shell make just nasm qemu -- make qemu PODMAN_BUILD=0
</code></pre>
<h3 id="freebsd-users"><a class="header" href="#freebsd-users">FreeBSD Users</a></h3>
<p>Install the build system dependencies:</p>
<pre><code class="language-sh">sudo pkg install coreutils findutils gcc nasm pkgconf fusefs-libs3 \
cmake gmake wget openssl texinfo python automake gettext bison gperf \
autoconf curl file flex expat2 gmp png libjpeg-turbo sdl12 sdl2_ttf \
perl5.36 p5-HTML-Parser libtool m4 po4a syslinux ninja meson xdg-utils \
zip unzip llvm doxygen patch automake scons lua54 py-protobuf-compiler
</code></pre>
<ul>
<li>If you want to use QEMU, run:</li>
</ul>
<pre><code class="language-sh">sudo pkg install qemu qemu-system-x86_64
</code></pre>
<ul>
<li>If you want to use VirtualBox, run:</li>
</ul>
<pre><code class="language-sh">sudo pkg install virtualbox
</code></pre>
<h3 id="macos-users"><a class="header" href="#macos-users">MacOS Users</a></h3>
<p>Please read the MacOS warning in <a href="./advanced-podman-build.html#macos">Advanced Podman Build</a>. We recommend you to use the Podman Build if you insist on using MacOS.</p>
<h4 id="macports"><a class="header" href="#macports">MacPorts</a></h4>
<p>Install the build system dependencies:</p>
<pre><code class="language-sh">sudo port install coreutils findutils gcc49 gcc-4.9 nasm pkgconfig \
osxfuse x86_64-elf-gcc cmake ninja po4a findutils texinfo autoconf \
openssl3 openssl11 bison curl wget file flex gperf expat gmp libpng \
jpeg libsdl12 libsdl2_ttf libtool m4 ninja meson python311 py37-mako \
xdg-utils zip unzip llvm-16 clang-16 perl5.24 p5-html-parser doxygen \
gpatch automake scons gmake lua protobuf-c
</code></pre>
<ul>
<li>If you want to use QEMU, run:</li>
</ul>
<pre><code class="language-sh">sudo port install qemu qemu-system-x86_64
</code></pre>
<ul>
<li>If you want to use VirtualBox, run:</li>
</ul>
<pre><code class="language-sh">sudo port install virtualbox
</code></pre>
<p>If you have some problem, try to install this Perl module:</p>
<pre><code class="language-sh">cpan install HTML::Entities
</code></pre>
<h4 id="homebrew"><a class="header" href="#homebrew">Homebrew</a></h4>
<p>Install the build system dependencies:</p>
<pre><code class="language-sh">brew install automake bison gettext libtool make nasm gcc@7 \
gcc-7 pkg-config cmake ninja po4a macfuse findutils texinfo \
openssl@1.1 openssl@3.0 autoconf curl wget flex gperf expat \
gmp libpng jpeg sdl12-compat sdl2_ttf perl libtool m4 ninja \
meson python@3.11 zip unzip llvm doxygen gpatch automake scons \
lua ant protobuf redox-os/gcc_cross_compilers/x86_64-elf-gcc x86_64-elf-gcc
</code></pre>
<ul>
<li>If you want to use QEMU, run:</li>
</ul>
<pre><code class="language-sh">brew install qemu qemu-system-x86_64
</code></pre>
<ul>
<li>If you want to use VirtualBox, run:</li>
</ul>
<pre><code class="language-sh">brew install virtualbox
</code></pre>
<p>If you have some problem, try to install this Perl module:</p>
<pre><code class="language-sh">cpan install HTML::Entities
</code></pre>
<h2 id="install-rust-stable-and-nightly"><a class="header" href="#install-rust-stable-and-nightly">Install Rust Stable And Nightly</a></h2>
<p>Install Rust, make the nightly version your default toolchain, list the installed toolchains, then install more Rust tooling:</p>
<pre><code class="language-sh">curl https://sh.rustup.rs -sSf | sh
</code></pre>
<p>then</p>
<pre><code class="language-sh">source ~/.cargo/env
</code></pre>
<pre><code class="language-sh">rustup default nightly
</code></pre>
<pre><code class="language-sh">rustup toolchain list
</code></pre>
<pre><code class="language-sh">cargo install cbindgen just
</code></pre>
<p>The <code>. "$HOME/.cargo/env</code> command (equivalent to <code>source ~/.cargo/env</code>) have been added to your shell start-up file, <code>~/.bashrc</code>, but you may wish to add it elsewhere or modify it according to your own environment.</p>
<h2 id="customizing-c-compiler"><a class="header" href="#customizing-c-compiler">Customizing C compiler</a></h2>
<p>Redox requires a GCC-compatible compiler for the operating system to build additional host tools. GCC for the host system is searched automatically from <code>PATH</code> environment variable with a binary named as <code>$GNU_TARGET-gcc</code> (e.g. <code>x86_64-linux-gnu-gcc</code>).</p>
<p>If your operating system is not Linux or if you want to use a different compiler, you can export <a href="https://gitlab.redox-os.org/redox-os/redoxer#host-specific-customizations">more environment variables</a> in the <code>.config</code> file:</p>
<pre><code class="language-sh">export REDOXER_HOST_AR=ar
export REDOXER_HOST_AS=as
export REDOXER_HOST_CC=cc
export REDOXER_HOST_CXX=c++
export REDOXER_HOST_LD=ld
export REDOXER_HOST_NM=nm
export REDOXER_HOST_OBJCOPY=objcopy
export REDOXER_HOST_OBJDUMP=objdump
export REDOXER_HOST_PKG_CONFIG=pkg-config
export REDOXER_HOST_RANLIB=ranlib
export REDOXER_HOST_READELF=readelf
export REDOXER_HOST_STRIP=strip
</code></pre>
<blockquote>
<p>ğŸ“ <strong>Note:</strong> FreeBSD and MacOS default compiler is Clang, so their support is experimental as also using a GCC version other than 14.x (i.e. the GCC version in Debian 13). Try to set these environment variables if you find any issues in any recipe compilation.</p>
</blockquote>
<h2 id="prefix"><a class="header" href="#prefix">Prefix</a></h2>
<p>In addition to build tools from the system, building Redox requires additional compilers and tools bootstrapped from your host compilers:</p>
<ul>
<li>GCC</li>
<li>GNU Binutils</li>
<li>libtool</li>
<li>Rust</li>
<li>Relibc</li>
</ul>
<p>The tools that build Redox are specific to each CPU architecture. These tools are located in the directory <code>prefix</code>, in a subdirectory named for the architecture, e.g. <code>prefix/x86_64-unknown-redox</code>. If you have problems with these tools, you can remove the subdirectory or even the whole <code>prefix</code> directory, which will cause the tools to be re-downloaded or rebuilt. The variable <code>PREFIX_BINARY</code> in <code>mk/config.mk</code> controls whether they are downloaded or built.</p>
<h3 id="prebuilt-prefix"><a class="header" href="#prebuilt-prefix">Prebuilt Prefix</a></h3>
<p>Redox provides a <a href="https://static.redox-os.org/toolchain/">prebuilt prefix toolchain</a> to make building fast. The prebuilt prefix is only suitable for use inside Podman requiring glibc version 2.41 or newer (as the Podman Build container is based on Debian 13) and not all CPU compiler targets are available for ARM-based Linux.</p>
<p>If your Linux distribution is not using glibc or its version is older than 2.41, you need to set <code>PREFIX_BINARY=0</code> and build your own prefix toolchain.</p>
<h3 id="prefix-gcc"><a class="header" href="#prefix-gcc">Prefix: GCC</a></h3>
<p>Redox compiles its own GCC, GNU Binutils and Libtool to create a cross-compilation target to Redox. The whole build takes about a half hour or less if your hardware is relatively powerful. When it's completed it generates the <code>gcc-install</code> directory containing these cross-compilers.</p>
<h3 id="prefix-rust"><a class="header" href="#prefix-rust">Prefix: Rust</a></h3>
<p>Redox OS is listed as both Tier 2 and Tier 3 <a href="https://doc.rust-lang.org/nightly/rustc/platform-support/redox.html">platform support</a> on Rust. The x86_64 architecture is listed as Tier 2 target which means that Rust's libstd is available for this target.</p>
<p>Redox compiles its own Rust compiler to be able to build Tier 3 libstd. Fortunately, we can choose to download from rustup instead of building the Rust compiler using the environment variable: <code>PREFIX_USE_UPSTREAM_RUST_COMPILER</code> in <code>mk/config.mk</code>.</p>
<p>Building Rust takes about 2 hours or more (if your hardware is relatively powerful) as it's also needed to compile LLVM. If you are building for the x86_64 target, downloading Rust from rustup (the official Rust binaries) might be preferable. When it's completed it generates the <code>rust-install</code> directory containing both GCC and Rust compiler.</p>
<p>Note that there maybe some patches in <a href="https://gitlab.redox-os.org/redox-os/rust/">Redox Rust fork</a> that has not been upstreamed, so your experience with using Rust from rustup might be different than building it.</p>
<h3 id="prefix-relibc"><a class="header" href="#prefix-relibc">Prefix: Relibc</a></h3>
<p><a href="https://gitlab.redox-os.org/redox-os/relibc">Relibc</a> is the <a href="https://en.wikipedia.org/wiki/C_standard_library">C standard library</a> written for Redox. Relibc is needed for both GCC and Rust to compile programs.</p>
<p>Relibc is very active in development even with <code>PREFIX_BINARY=1</code> it will be compiled anyway so we always have the updated libc. Fortunately, compiling it is very quick. When it's completed it generates the <code>relibc-install</code> directory containing GCC and Rust bundled with updated relibc.</p>
<h2 id="cookbook-2"><a class="header" href="#cookbook-2">Cookbook</a></h2>
<p>The <strong>Cookbook</strong> system is an essential part of the Redox build system. Each Redox component package  is built and managed by the Cookbook toolset. The variable <code>REPO_BINARY</code> in <code>mk/config.mk</code> controls if the recipes are compiled from sources or use binary packages from Redox CI server, read the section <a href="./configuration-settings.html#repo_binary">REPO_BINARY</a> for more details. See the <a href="./including-programs.html">Including Programs in Redox</a> page for examples of using the Cookbook toolset. If you will be developing recipes to include in Redox.</p>
<h2 id="creating-a-build-environment-shell"><a class="header" href="#creating-a-build-environment-shell">Creating a Build Environment Shell</a></h2>
<p>If you are working on specific components of the system, and will be using some of the tools in the <code>redox</code> directory and bypassing <code>make</code>, you may wish to create a build environment shell. This shell includes the <code>prefix</code> tools in your <code>PATH</code>. You can do this with:</p>
<pre><code class="language-sh">make env
</code></pre>
<p>This command also works with a Podman Build, creating a shell in Podman and setting <code>PATH</code> to include the necessary build tools.</p>
<h2 id="updating-the-sources"><a class="header" href="#updating-the-sources">Updating The Sources</a></h2>
<p>If you want to update the build system or if some of the recipes have changed, you can update those parts of the system with <code>make pull</code>. However, this will not update the sources of the recipes.</p>
<pre><code class="language-sh">cd ~/tryredox/redox
</code></pre>
<pre><code class="language-sh">make pull
</code></pre>
<p>If you want to update the source for the recipes, use <code>make rebuild</code>, or remove the file <code>$(BUILD)/fetch.tag</code> and run <code>make fetch</code></p>
<h2 id="changing-the-filesystem-size-and-contents"><a class="header" href="#changing-the-filesystem-size-and-contents">Changing the Filesystem Size and Contents</a></h2>
<p>You can modify the size and contents of the filesystem for emulation and <em>livedisk</em> as described in the <a href="./configuration-settings.html">Configuration Settings</a> page.</p>
<h2 id="next-steps"><a class="header" href="#next-steps">Next Steps</a></h2>
<p>Once this is all set up, we can finally build! See the <a href="./building-redox.html#compiling-redox">Compiling Redox</a> section.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="working-with-i586"><a class="header" href="#working-with-i586">Working with i586</a></h1>
<p>The build system supports building for multiple CPU architectures in the same directory tree. Building for <code>i586</code> or <code>aarch64</code> only requires that you set the <code>ARCH</code> Make variable to the correct value. Normally, you would do this in the <a href="./configuration-settings.html#config">.config</a> section, but you can also do this temporarily with the <code>make ARCH=i586</code> command, in the shell environment (<code>export ARCH=i586</code>) or with the <a href="./configuration-settings.html#buildsh">build.sh</a> script.</p>
<h2 id="first-time-build"><a class="header" href="#first-time-build">First Time Build</a></h2>
<h3 id="bootstrap-pre-requisites-and-download-sources"><a class="header" href="#bootstrap-pre-requisites-and-download-sources">Bootstrap Pre-Requisites And Download Sources</a></h3>
<p>Follow the instructions for running <strong>bootstrap.sh</strong> to setup your environment on the <a href="./podman-build.html">Building Redox</a> or <a href="./building-redox.html">Native Build</a> pages.</p>
<h3 id="install-qemu"><a class="header" href="#install-qemu">Install QEMU</a></h3>
<p>The <strong>i386</strong> emulator is not installed by <code>bootstrap.sh</code>. You can add it like this:<br />
(Pop!_OS/Ubuntu/Debian)</p>
<pre><code class="language-sh">sudo apt-get install qemu-system-i386
</code></pre>
<h3 id="configuration-values"><a class="header" href="#configuration-values">Configuration Values</a></h3>
<p>Before your first build, be sure to set the <code>ARCH</code> variable in <a href="./configuration-settings.html#config">.config</a> to your architecture type, in this case <code>i586</code>. You can change several other configurable settings, such as the filesystem contents, etc. See <a href="./configuration-settings.html">Configuration Settings</a>.</p>
<h3 id="add-packages-to-the-filesystem"><a class="header" href="#add-packages-to-the-filesystem">Add packages to the filesystem.</a></h3>
<p>You can add programs to the filesystem by following the instructions <a href="./including-programs.html">here</a>.</p>
<h3 id="advanced-users"><a class="header" href="#advanced-users">Advanced Users</a></h3>
<p>For more details on the build process, please read <a href="./advanced-build.html">Advanced Build</a>.</p>
<h2 id="compiling-redox-1"><a class="header" href="#compiling-redox-1">Compiling Redox</a></h2>
<p>Now we have:</p>
<ul>
<li>Downloaded the sources</li>
<li>Set the <code>ARCH</code> environment variable to <code>i586</code></li>
<li>Selected a filesystem configuration, e.g. <code>desktop</code></li>
<li>Tweaked the settings to our liking</li>
<li>Probably added our recipes to the filesystem</li>
</ul>
<p>We are ready to build a Redox image.</p>
<h3 id="building-an-image-for-emulation"><a class="header" href="#building-an-image-for-emulation">Building an image for emulation</a></h3>
<pre><code class="language-sh">cd ~/tryredox/redox
</code></pre>
<p>This command will create the image, e.g. <code>build/i586/desktop/harddrive.img</code>, which you can run with an emulator. See <a href="i686.html#running-redox">Running Redox</a>.</p>
<pre><code class="language-sh">time make all
</code></pre>
<h3 id="building-a-bootable-redox-image"><a class="header" href="#building-a-bootable-redox-image">Building A Bootable Redox Image</a></h3>
<pre><code class="language-sh">cd ~/tryredox/redox
</code></pre>
<ul>
<li>The following command will create the file <code>build/i586/desktop/livedisk.iso</code>, which can be copied to a USB device or CD for testing or installation. See <a href="./real-hardware.html">Running Redox on real hardware</a>.</li>
</ul>
<pre><code class="language-sh">time make live
</code></pre>
<p>Give it a while. Redox is big.</p>
<h3 id="cleaning-previous-build-cycles"><a class="header" href="#cleaning-previous-build-cycles">Cleaning Previous Build Cycles</a></h3>
<h4 id="cleaning-intended-for-rebuilding-core-packages-and-entire-system"><a class="header" href="#cleaning-intended-for-rebuilding-core-packages-and-entire-system">Cleaning Intended For Rebuilding Core Packages And Entire System</a></h4>
<p>When you need to rebuild core-packages like relibc, gcc and related tools, clean the entire previous build cycle with:</p>
<pre><code class="language-sh">cd ~/tryredox/redox/
</code></pre>
<pre><code class="language-sh">rm -rf prefix/i586-unknown-redox/relibc-install/ cookbook/recipes/gcc/{build,sysroot,stage*} build/i586/*/{harddrive.img,livedisk.iso}
</code></pre>
<h4 id="cleaning-intended-for-only-rebuilding-non-core-packages"><a class="header" href="#cleaning-intended-for-only-rebuilding-non-core-packages">Cleaning Intended For Only Rebuilding Non-Core Package(s)</a></h4>
<p>If you're only rebuilding a non-core package, you can partially clean the previous build cycle just enough to force the rebuilding of the Non-Core Package:</p>
<pre><code class="language-sh">cd ~/tryredox/redox/
</code></pre>
<pre><code class="language-sh">rm build/i586/*/{fetch.tag,harddrive.img}
</code></pre>
<h2 id="running-redox"><a class="header" href="#running-redox">Running Redox</a></h2>
<h3 id="running-the-redox-desktop"><a class="header" href="#running-the-redox-desktop">Running The Redox Desktop</a></h3>
<p>To open QEMU, run:</p>
<pre><code class="language-sh">make qemu
</code></pre>
<p>This should open up a QEMU window, booting to Redox.</p>
<p>If it does not work, disable KVM with:</p>
<pre><code class="language-sh">make qemu kvm=no
</code></pre>
<p>or:</p>
<pre><code class="language-sh">make qemu iommu=no
</code></pre>
<p>If this doesn't work either, you should go open an issue.</p>
<h3 id="running-the-redox-console-only"><a class="header" href="#running-the-redox-console-only">Running The Redox Console Only</a></h3>
<p>We disable to GUI desktop by passing the <code>gpu=no</code> option.  The following disables the graphics support and welcomes you with the Redox console:</p>
<pre><code class="language-sh">make qemu gpu=no 
</code></pre>
<p>It's useful to run the console in order to capture the output from the non-GUI programs.</p>
<p>It helps to debug applications and share the console captured logs with other developers in the Redox community.</p>
<h3 id="qemu-tap-for-network-testing-1"><a class="header" href="#qemu-tap-for-network-testing-1">QEMU Tap For Network Testing</a></h3>
<p>Expose Redox to other computers within a LAN. Configure QEMU with a "TAP" which will allow other computers to test Redox client/server/networking capabilities.</p>
<p>Join the <a href="./chat.html">chat</a> if this is something you are interested in pursuing.</p>
<h3 id="note"><a class="header" href="#note">Note</a></h3>
<p>If you encounter any bugs, errors, obstructions, or other annoying things, please send a message in the <a href="./chat.html">chat</a> or <a href="./creating-proper-bug-reports.html">report the issue on GitLab</a>. Thanks!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="arm64"><a class="header" href="#arm64">ARM64</a></h1>
<p>The build system supports building for multiple CPU architectures in the same directory tree. Building for <code>aarch64</code> only requires that you set the <code>ARCH</code> environment variable to the correct value. Normally, you would do this in <a href="./configuration-settings.html#config">.config</a>, but you can also do this temporarily with the <code>make ARCH=aarch64</code> command, in the shell environment (<code>export ARCH=aarch64</code>) or with the <a href="./configuration-settings.html#buildsh">build.sh</a> script.</p>
<p>(ARM64 has limited support)</p>
<h2 id="first-time-build-1"><a class="header" href="#first-time-build-1">First Time Build</a></h2>
<h3 id="bootstrap-pre-requisites-and-download-sources-1"><a class="header" href="#bootstrap-pre-requisites-and-download-sources-1">Bootstrap Pre-Requisites and Download Sources</a></h3>
<p>Follow the instructions for running <strong>bootstrap.sh</strong> to setup your environment, read the <a href="./building-redox.html">Building Redox</a> page or the <a href="./podman-build.html">Podman Build</a> page.</p>
<h3 id="install-qemu-1"><a class="header" href="#install-qemu-1">Install QEMU</a></h3>
<p>The <strong>ARM64</strong> emulator is not installed by <code>bootstrap.sh</code>. You can add it like this:</p>
<p>(Pop!_OS/Ubuntu/Debian)</p>
<pre><code class="language-sh">sudo apt-get install qemu-system-aarch64
</code></pre>
<h3 id="install-additional-tools-to-build-and-run-arm-64-bit-redox-os-image"><a class="header" href="#install-additional-tools-to-build-and-run-arm-64-bit-redox-os-image">Install Additional Tools To Build And Run ARM 64-bit Redox OS Image</a></h3>
<pre><code class="language-sh">sudo apt-get install u-boot-tools qemu-system-arm qemu-efi
</code></pre>
<h3 id="configuration-values-1"><a class="header" href="#configuration-values-1">Configuration Values</a></h3>
<p>Before your first build, be sure to set the <code>ARCH</code> variable in <a href="./configuration-settings.html#config">.config</a> to your CPU architecture type, in this case <code>aarch64</code>. You can change several other configurable settings, such as the filesystem contents, etc. See <a href="./configuration-settings.html">Configuration Settings</a>.</p>
<h3 id="add-packages-to-the-filesystem-1"><a class="header" href="#add-packages-to-the-filesystem-1">Add packages to the filesystem.</a></h3>
<p>You can add programs to the filesystem by following the instructions on the <a href="./including-programs.html">Including Programs in Redox</a> page.</p>
<h3 id="advanced-users-1"><a class="header" href="#advanced-users-1">Advanced Users</a></h3>
<p>For more details on the build process, please read the <a href="./advanced-build.html">Advanced Build</a> page.</p>
<h2 id="compiling-redox-2"><a class="header" href="#compiling-redox-2">Compiling Redox</a></h2>
<p>Now we have:</p>
<ul>
<li>Downloaded the sources</li>
<li>Set the <code>ARCH</code> to <code>aarch64</code></li>
<li>Selected a filesystem config, e.g. <code>desktop</code></li>
<li>Tweaked the settings to our liking</li>
<li>Probably added our recipe to the filesystem</li>
</ul>
<p>We are ready to build the a Redox image.</p>
<h3 id="building-an-image-for-emulation-1"><a class="header" href="#building-an-image-for-emulation-1">Building an image for emulation</a></h3>
<pre><code class="language-sh">cd ~/tryredox/redox
</code></pre>
<p>This command will create the image, e.g. <code>build/aarch64/desktop/harddrive.img</code>, which you can run with an emulator. See the <a href="aarch64.html#running-redox">Running Redox</a> page.</p>
<pre><code class="language-sh">time make all
</code></pre>
<p>Give it a while. Redox is big.</p>
<p>Read the <a href="./build-phases.html#make-all-first-run">make all (first run)</a> section to know what the command above does.</p>
<h3 id="cleaning-previous-build-cycles-1"><a class="header" href="#cleaning-previous-build-cycles-1">Cleaning Previous Build Cycles</a></h3>
<h4 id="cleaning-intended-for-rebuilding-core-packages-and-entire-system-1"><a class="header" href="#cleaning-intended-for-rebuilding-core-packages-and-entire-system-1">Cleaning Intended For Rebuilding Core Packages And Entire System</a></h4>
<p>When you need to rebuild core-packages like relibc, gcc and related tools, clean the entire previous build cycle with:</p>
<pre><code class="language-sh">cd ~/tryredox/redox/
</code></pre>
<pre><code class="language-sh">rm -rf prefix/aarch64-unknown-redox/relibc-install/ cookbook/recipes/gcc/{build,sysroot,stage*} build/aarch64/*/{harddrive.img,livedisk.iso}
</code></pre>
<h4 id="cleaning-intended-for-only-rebuilding-non-core-packages-1"><a class="header" href="#cleaning-intended-for-only-rebuilding-non-core-packages-1">Cleaning Intended For Only Rebuilding Non-Core Package(s)</a></h4>
<p>If you're only rebuilding a non-core package, you can partially clean the previous build cycle just enough to force the rebuilding of the Non-Core Package:</p>
<pre><code class="language-sh">cd ~/tryredox/redox/
</code></pre>
<pre><code class="language-sh">rm build/aarch64/*/{fetch.tag,harddrive.img}
</code></pre>
<h2 id="running-redox-1"><a class="header" href="#running-redox-1">Running Redox</a></h2>
<p>To open QEMU, run:</p>
<pre><code class="language-sh">make qemu kvm=no gpu=no
</code></pre>
<p>This should boot to Redox. The desktop GUI will be disabled, but you will be prompted to login to the Redox console.</p>
<h3 id="qemu-tap-for-network-testing-2"><a class="header" href="#qemu-tap-for-network-testing-2">QEMU Tap For Network Testing</a></h3>
<p>Expose Redox to other computers within a LAN. Configure QEMU with a "TAP" which will allow other computers to test Redox client/server/networking capabilities.</p>
<p>Join the <a href="./chat.html">Chat</a> if this is something you are interested in pursuing.</p>
<h3 id="note-1"><a class="header" href="#note-1">Note</a></h3>
<p>If you encounter any bugs, errors, obstructions, or other annoying things, please send a message in the <a href="./chat.html">Chat</a> or <a href="./creating-proper-bug-reports.html">report the issue on GitLab</a>. Thanks!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="raspberry-pi"><a class="header" href="#raspberry-pi">Raspberry Pi</a></h1>
<h2 id="build-and-run-device-specific-images"><a class="header" href="#build-and-run-device-specific-images">Build and run device-specific images</a></h2>
<p>Most ARM motherboards do not use the default image for booting, which requires us to do some extra steps with building images.</p>
<h2 id="raspberry-pi-3-model-b"><a class="header" href="#raspberry-pi-3-model-b">Raspberry Pi 3 Model B+</a></h2>
<p>It is easy to port Raspberry Pi 3 Model B+ (raspi3b+) since the bootloader of Raspberry Pi family uses the similar filesystem (FAT32) for booting.</p>
<p>In order to build a RasPi3B+ image:</p>
<ul>
<li>Add <code>BOARD?=raspi3bp</code> and <code>CONFIG_NAME?=minimal</code>to <code>.config</code></li>
<li>Run <code>make all</code></li>
<li>Download the firmware</li>
</ul>
<pre><code class="language-sh">cd ~/tryredox
</code></pre>
<pre><code class="language-sh">git clone https://gitlab.redox-os.org/Ivan/redox_firmware.git
</code></pre>
<h3 id="run-in-qemu"><a class="header" href="#run-in-qemu">Run in QEMU</a></h3>
<p>Assume that we are using the <code>server-minimal</code> configuration and built the image successfully, run:</p>
<ul>
<li>Add two additional dtb files to EFI system partition:</li>
</ul>
<pre><code>DISK=build/aarch64/server-minimal/harddrive.img
MOUNT_DIR=/mnt/efi_boot
DTB_DIR=$MOUNT_DIR/dtb/broadcom
WORKPLACE=/home/redox/tryredox
DTS=$WORKPLACE/redox_firmware/platform/raspberry_pi/rpi3/bcm2837-rpi-3-b-plus.dts
</code></pre>
<pre><code class="language-sh">mkdir -p $MOUNT_DIR
</code></pre>
<pre><code class="language-sh">mount -o loop,offset=$((2048*512)) $DISK $MOUNT_DIR
</code></pre>
<pre><code class="language-sh">mkdir -p $DTB_DIR
</code></pre>
<pre><code class="language-sh">dtc -I dts -O dtb $DTS &gt; $DTB_DIR/bcm2837-rpi-3-b.dtb
</code></pre>
<pre><code class="language-sh">cp $DTB_DIR/bcm2837-rpi-3-b.dtb $DTB_DIR/bcm2837-rpi-3-b-plus.dtb
</code></pre>
<pre><code class="language-sh">sync
</code></pre>
<pre><code class="language-sh">umount $MOUNT_DIR
</code></pre>
<ul>
<li>Run <code>make qemu_raspi live=no</code></li>
</ul>
<h3 id="booting-from-usb"><a class="header" href="#booting-from-usb">Booting from USB</a></h3>
<p>Assume that we are using the <code>server-minimal</code> configuration and access serial console using GPIOs 14 and 15 (pins 8 and 10 on the 40-pin header). Do the following:</p>
<ul>
<li>Run <code>make live</code></li>
<li>Download the firmware from <a href="https://github.com/raspberrypi/firmware/tree/master/boot">official repository</a></li>
</ul>
<pre><code class="language-sh">cd ~/tryredox
</code></pre>
<pre><code class="language-sh">git clone --depth=1 https://github.com/raspberrypi/firmware.git
</code></pre>
<ul>
<li>Copy all required firmware to EFI system partition</li>
</ul>
<pre><code>DISK=build/aarch64/server-minimal/livedisk.iso
MOUNT_DIR=/mnt/efi_boot
DTB_DIR=$MOUNT_DIR/dtb/broadcom
WORKPLACE=/home/redox/tryredox
DTS=$WORKPLACE/redox_firmware/platform/raspberry_pi/rpi3/bcm2837-rpi-3-b-plus.dts
UBOOT=$WORKPLACE/redox_firmware/platform/raspberry_pi/rpi3/u-boot-rpi-3-b-plus.bin
CONFIG_TXT=$WORKPLACE/redox_firmware/platform/raspberry_pi/rpi3/config.txt
FW_DIR=$WORKPLACE/firmware/boot
</code></pre>
<pre><code class="language-sh">mkdir -p $MOUNT_DIR
</code></pre>
<pre><code class="language-sh">mount -o loop,offset=$((2048*512)) $DISK $MOUNT_DIR
</code></pre>
<pre><code class="language-sh">cp -rf $FW_DIR/* $MOUNT_DIR
</code></pre>
<pre><code class="language-sh">mkdir -p $DTB_DIR
</code></pre>
<pre><code class="language-sh">dtc -I dts -O dtb $DTS &gt; $DTB_DIR/bcm2837-rpi-3-b.dtb
</code></pre>
<pre><code class="language-sh">cp $DTB_DIR/bcm2837-rpi-3-b.dtb $DTB_DIR/bcm2837-rpi-3-b-plus.dtb
</code></pre>
<pre><code class="language-sh">cp $UBOOT $MOUNT_DIR/u-boot.bin
</code></pre>
<pre><code class="language-sh">cp $CONFIG_TXT $MOUNT_DIR
</code></pre>
<pre><code class="language-sh">sync
</code></pre>
<pre><code class="language-sh">umount $MOUNT_DIR
</code></pre>
<ul>
<li>Run:</li>
</ul>
<pre><code class="language-sh">dd if=build/aarch64/server-minimal/livedisk.iso of=/dev/sdX
</code></pre>
<p>(<code>/dev/sdX</code> is your USB device.)</p>
<h3 id="booting-from-sd-card"><a class="header" href="#booting-from-sd-card">Booting from SD Card</a></h3>
<p>This process is similar to that of "Booting from USB", but has some differences:</p>
<ul>
<li>Use <code>harddrive.img</code> instead of <code>livedisk.iso</code></li>
<li>After <code>dd</code> command, try to make the EFI system partition of the SD card become a hybrid MBR. See <a href="https://www.eisfunke.com/posts/2023/uefi-boot-on-raspberry-pi-3.html">this post</a> for more details</li>
</ul>
<pre><code>root@dev-pc:/home/ivan/code/os/redox# gdisk /dev/sdc
GPT fdisk (gdisk) version 1.0.8

Partition table scan:
  MBR: protective
  BSD: not present
  APM: not present
  GPT: present

Found valid GPT with protective MBR; using GPT.

Command (? for help): r

Recovery/transformation command (? for help): p
Disk /dev/sdc: 61067264 sectors, 29.1 GiB
Model: MassStorageClass
Sector size (logical/physical): 512/512 bytes
Disk identifier (GUID): B37FD04D-B67D-48AA-900B-884F0E3B2EAD
Partition table holds up to 128 entries
Main partition table begins at sector 2 and ends at sector 33
First usable sector is 34, last usable sector is 524254
Partitions will be aligned on 2-sector boundaries
Total free space is 2015 sectors (1007.5 KiB)

Number  Start (sector)    End (sector)  Size       Code  Name
   1              34            2047   1007.0 KiB  EF02  BIOS
   2            2048          264191   128.0 MiB   EF00  EFI
   3          264192          522239   126.0 MiB   8300  REDOX

Recovery/transformation command (? for help): h

WARNING! Hybrid MBRs are flaky and dangerous! If you decide not to use one,
just hit the Enter key at the below prompt and your MBR partition table will
be untouched.

Type from one to three GPT partition numbers, separated by spaces, to be
added to the hybrid MBR, in sequence: 2
Place EFI GPT (0xEE) partition first in MBR (good for GRUB)? (Y/N): n

Creating entry for GPT partition #2 (MBR partition #1)
Enter an MBR hex code (default EF): 0c
Set the bootable flag? (Y/N): n

Unused partition space(s) found. Use one to protect more partitions? (Y/N): n

Recovery/transformation command (? for help): o

Disk size is 61067264 sectors (29.1 GiB)
MBR disk identifier: 0x00000000
MBR partitions:

Number  Boot  Start Sector   End Sector   Status      Code
   1                  2048       264191   primary     0x0C
   2                     1         2047   primary     0xEE

Recovery/transformation command (? for help): w
Warning! Secondary header is placed too early on the disk! Do you want to
correct this problem? (Y/N): y
Have moved second header and partition table to correct location.

Final checks complete. About to write GPT data. THIS WILL OVERWRITE EXISTING
PARTITIONS!!

Do you want to proceed? (Y/N): y
OK; writing new GUID partition table (GPT) to /dev/sdc.
The operation has completed successfully.
root@dev-pc:/home/ivan/code/os/redox#
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="troubleshooting-the-build"><a class="header" href="#troubleshooting-the-build">Troubleshooting the Build</a></h1>
<p>This page covers all troubleshooting methods and tips for our build system.</p>
<p>(You must read the <a href="./build-system-reference.html">Build System</a> page before)</p>
<ul>
<li><a href="troubleshooting.html#notes">Notes</a></li>
<li><a href="troubleshooting.html#setup">Setup</a>
<ul>
<li><a href="troubleshooting.html#podman">Podman</a>
<ul>
<li><a href="troubleshooting.html#manual-configuration">Manual Configuration</a></li>
</ul>
</li>
<li><a href="troubleshooting.html#native-build">Native Build</a></li>
<li><a href="troubleshooting.html#git">Git</a></li>
</ul>
</li>
<li><a href="troubleshooting.html#building-the-system">Building the System</a>
<ul>
<li><a href="troubleshooting.html#config-and-mkconfigmk">.config and mk/config.mk</a></li>
<li><a href="troubleshooting.html#prefix">Prefix</a></li>
<li><a href="troubleshooting.html#filesystem-configuration">æª”æ¡ˆç³»çµ±çµ„æ…‹</a></li>
<li><a href="troubleshooting.html#fetch">Fetch</a></li>
<li><a href="troubleshooting.html#cookbook">Cookbook</a></li>
<li><a href="troubleshooting.html#create-the-image-with-fuse">Create the Image with FUSE</a></li>
</ul>
</li>
<li><a href="troubleshooting.html#solving-compilation-problems">Solving Compilation Problems</a>
<ul>
<li><a href="troubleshooting.html#environment-leakage">Environment Leakage</a></li>
<li><a href="troubleshooting.html#update-your-build-system">Update Your Build System</a></li>
<li><a href="troubleshooting.html#prevent-and-fix-breaking-changes">Prevent and Fix Breaking Changes</a></li>
<li><a href="troubleshooting.html#update-your-branch">Update Your Branch</a></li>
<li><a href="troubleshooting.html#update-crates">Update Crates</a></li>
<li><a href="troubleshooting.html#verify-the-dependency-tree">Verify The Dependency Tree</a></li>
</ul>
</li>
<li><a href="troubleshooting.html#debug-methods">Debug Methods</a>
<ul>
<li><a href="troubleshooting.html#boot">Boot</a></li>
</ul>
</li>
<li><a href="troubleshooting.html#kill-a-frozen-redox-vm">Kill A Frozen Redox VM</a></li>
<li><a href="troubleshooting.html#kernel-panic">Kernel Panic</a>
<ul>
<li><a href="troubleshooting.html#qemu">QEMU</a></li>
<li><a href="troubleshooting.html#real-hardware">Real Hardware</a></li>
</ul>
</li>
</ul>
<h2 id="notes"><a class="header" href="#notes">Notes</a></h2>
<p>This section contain details which apply to Redox problems on virtual machines and real hardware.</p>
<h3 id="general"><a class="header" href="#general">General</a></h3>
<ul>
<li>If you aren't doing development and has a compilation or runtime problem be sure to verify if your build system/recipes sources and binaries are up-to-date or holding breaking changes, a build system update, single or complete recipe binary cleanup may fix your problems in most cases</li>
</ul>
<p>Read the <a href="troubleshooting.html#debug-methods">Debug Methods</a> and <a href="troubleshooting.html#boot">Boot</a> sections for more details.</p>
<h3 id="real-hardware"><a class="header" href="#real-hardware">Real Hardware</a></h3>
<ul>
<li>Test if your boot problem happens with live mode enabled and disabled, press the <code>L</code> key in the boot screen resolution menu to toggle</li>
<li>If possible verify if your boot problem happens in UEFI and BIOS (UEFI has BIOS emulation which is called "CSM mode" and can be enabled in the UEFI settings)</li>
<li>Photos are safer and faster to send boot logs than boot log text written by hand, which is error-prone and time consuming</li>
<li>Verify if your computer has enough RAM to load the whole Redox image because data streaming from USB is not supported yet, if it has 1GB or less of RAM we recommend the <code>server</code>, <code>desktop-minimal</code> or <code>desktop</code> image variants to avoid OOM panics</li>
<li>If you have a very weak 64 bits Intel or AMD CPU (single core and L cache smaller than 1MB, like Intel Atom CPUs released before 2010) and 1GB or less of RAM we recommended the <a href="https://static.redox-os.org/img/i586/">Intel/AMD 32 bits Redox images</a> and the <code>server</code>, <code>desktop-minimal</code> or <code>desktop</code> variants to avoid OOM panics and have better performance</li>
</ul>
<p>Read the <a href="troubleshooting.html#debug-methods">Debug Methods</a> and <a href="troubleshooting.html#boot">Boot</a> sections for more details.</p>
<h3 id="reporting"><a class="header" href="#reporting">Reporting</a></h3>
<ul>
<li>Use Markdown code blocks to send logs, avoiding syntax breakage on Matrix clients or GitLab</li>
<li>Use the "fresh build" or "clean build" terms to easily/quickly explain that you rebuilt all build system and recipe binaries from scratch (<code>make clean all</code> command)</li>
<li>Use the "fresh clone" or "fresh copy" terms to easily/quickly explain that you downloaded a new build system copy from Git or bootstrap scripts</li>
</ul>
<h2 id="setup-1"><a class="header" href="#setup-1">Setup</a></h2>
<p>When you run <code>podman_bootstrap.sh</code> or <code>native_bootstrap.sh</code>, the Linux tools and libraries required to support the toolchain and build all recipes are installed. Then the <code>redox</code> project is downloaded from the Redox GitLab server. The <code>redox</code> project does not contain the system sources, it only contains the build system.</p>
<h3 id="podman-1"><a class="header" href="#podman-1">Podman</a></h3>
<p>If your build appears to be missing libraries, have a look at the <a href="./advanced-podman-build.html#debugging-your-build-process">Debugging Your Podman Build Process</a> section. If your Podman environment becomes broken, you can use <code>podman system reset</code> and <code>rm -rf build/podman</code>. In some cases, you may need to run the <code>sudo rm -rf build/podman</code> command.</p>
<p>If any command ask your to choose an image repository (after the <code>make container_clean</code> command execution) select the first item, it will give an error and you need to run the <code>time make all</code> command again</p>
<h4 id="manual-configuration"><a class="header" href="#manual-configuration">Manual Configuration</a></h4>
<p>If you have problems setting Podman to rootless mode, do the following steps:</p>
<p>(These commands were taken from the official <a href="https://github.com/containers/podman/blob/main/docs/tutorials/rootless_tutorial.md">Podman rootless wiki</a> and <a href="https://github.com/containers/podman/blob/main/rootless.md">Shortcomings of Rootless Podman</a>, thus it could be broken/wrong in the future, read the wiki to see if the commands match, we will try to update the method to work with everyone)</p>
<ul>
<li>Install the <code>podman</code>, <code>crun</code>, <code>slirp4netns</code> and <code>fuse-overlayfs</code> packages on your system.</li>
<li><code>podman ps -a</code> - This command will show all your Podman containers, if you want to remove all of them, run <code>podman system reset</code></li>
<li>Follow <a href="https://github.com/containers/podman/blob/main/docs/tutorials/rootless_tutorial.md#cgroup-v2-support">this step</a> if necessary (if the Podman of your distribution use cgroups V2), you will need to edit the <code>containers.conf</code> file at <code>/etc/containers</code> or your user folder at <code>~/.config/containers</code>, change the line <code>runtime = "runc"</code> to <code>runtime = "crun"</code></li>
<li>Execute the <code>cat /etc/subuid</code> and <code>cat /etc/subgid</code> commands to see user/group IDs (UIDs/GIDs) available for Podman.</li>
</ul>
<p>If you don't want to edit the file, you can use this command:</p>
<pre><code class="language-sh">sudo usermod --add-subuids 100000-165535 --add-subgids 100000-165535 your-user
</code></pre>
<p>You can use the values <code>100000-165535</code> for your user, just edit the two text files, we recommend <code>sudo nano /etc/subuid</code> and <code>sudo nano /etc/subgid</code>, when you finish, press Ctrl+X to save the changes.</p>
<ul>
<li>After the change on the UID/GID values, execute this command:</li>
</ul>
<pre><code class="language-sh">podman system migrate
</code></pre>
<ul>
<li>If you have a network problem on the container, this command will allow connections on the port 443 (without root):</li>
</ul>
<pre><code class="language-sh">sudo sysctl net.ipv4.ip_unprivileged_port_start=443
</code></pre>
<ul>
<li>Hopefully, you have a working Podman build now.</li>
</ul>
<p>(If you still have problems with Podman, read the <a href="./troubleshooting.html">Troubleshooting</a> chapter or join us on the <a href="./chat.html">chat</a>)</p>
<p>Let us know if you have improvements for Podman troubleshooting on the <a href="./chat.html">chat</a>.</p>
<h3 id="native-build-1"><a class="header" href="#native-build-1">Native Build</a></h3>
<p>Not all Linux distributions are supported by <code>native_bootstrap.sh</code>, so if you have frequent compilation problems try the <code>podman_bootstrap.sh</code> script for <a href="https://podman.io/">Podman</a> builds.</p>
<p>If you want to support your Unix-like system without Podman, you can try to install the Debian/Ubuntu package equivalents for your system from your package manager/software store, you can see them on the <code>ubuntu()</code> function of the <a href="https://gitlab.redox-os.org/redox-os/redox/-/blob/master/native_bootstrap.sh">native_bootstrap.sh</a> script.</p>
<p>The <code>native_bootstrap.sh</code> script and <code>redox-base-containerfile</code> covers the build system packages needed by the recipes at the <a href="https://gitlab.redox-os.org/redox-os/redox/-/blob/master/config/x86_64/demo.toml">demo.toml</a> filesystem configuration.</p>
<p>(Note that some systems may have build environment problems hard and time consuming to fix, on these systems Podman will fix most headaches)</p>
<h3 id="git-1"><a class="header" href="#git-1">Git</a></h3>
<p>If you did not use <code>podman_bootstrap.sh</code> or <code>native_bootstrap.sh</code> to setup your environment, you can download the sources with:</p>
<pre><code class="language-sh">git clone https://gitlab.redox-os.org/redox-os/redox.git --origin upstream
</code></pre>
<ul>
<li>Ensure that all the libraries and packages required by Redox are installed by running <code>./podman_bootstrap.sh -d</code> or, if you will be using the Podman build run the <code>./podman_bootstrap.sh -d</code> command.</li>
</ul>
<h2 id="building-the-system"><a class="header" href="#building-the-system">Building The System</a></h2>
<p>When you run <code>make all</code>, the following steps occur.</p>
<h3 id="config-and-mkconfigmk"><a class="header" href="#config-and-mkconfigmk">.config and mk/config.mk</a></h3>
<ul>
<li><code>make</code> scans <a href="./configuration-settings.html#config">.config</a> and <a href="./configuration-settings.html#mkconfigmk">mk/config.mk</a> for settings, such as the CPU architecture, configuration name, and whether to use <strong>Podman</strong> during the build process. Read through the <a href="./configuration-settings.html">Configuration Settings</a> page to make sure you have the settings that are best for you.</li>
</ul>
<h3 id="prefix-1"><a class="header" href="#prefix-1">Prefix</a></h3>
<p>The Redox toolchain, referred to as <strong>prefix</strong> because it is prefixed with the CPU architecture name, is downloaded and/or built. Modified versions of <code>cargo</code>, <code>rustc</code>, <code>gcc</code> and many other tools are created. They are placed in the <code>prefix</code> directory.</p>
<p>If you have a problem with the toolchain, try the <code>rm -rf prefix</code> and <code>make prefix</code> or <code>make clean all</code> (if <code>make prefix</code> is not enough) commands.</p>
<h3 id="æª”æ¡ˆç³»çµ±çµ„æ…‹-2"><a class="header" href="#æª”æ¡ˆç³»çµ±çµ„æ…‹-2">æª”æ¡ˆç³»çµ±çµ„æ…‹</a></h3>
<p>The list of Redox recipes to be built is read from the <a href="./configuration-settings.html#filesystem-configuration">filesystem configuration</a> file, which is specified in <a href="./configuration-settings.html#config">.config</a> or <code>mk/config.mk</code>. If your recipe is not being included in the build, verify if you have set the <code>CONFIG_NAME</code> or <code>FILESYSTEM_CONFIG</code> in the <code>.config</code> file.</p>
<h3 id="fetch"><a class="header" href="#fetch">Fetch</a></h3>
<p>Each recipe source is downloaded using <code>git</code> or <code>curl</code>, according to the <code>[source]</code> section of the <code>recipe.toml</code> file. Source is placed at <code>recipes/recipe-name/source</code></p>
<p>(Some recipes still use the old <code>recipe.sh</code> format, they need to be converted to TOML)</p>
<p>If you are doing work on a recipe, you may want to comment out the <code>[source]</code> section of the recipe. To discard your changes to the source for a recipe, or to update to the latest version, uncomment the <code>[source]</code> section of the recipe, and use <code>make uc.recipe-name</code> in the recipe directory to remove both the source and any compiled code.</p>
<p>After all recipes are fetched, a tag file is created as <code>build/$ARCH/$CONFIG_NAME/fetch.tag</code>, e.g. <code>build/x86_64/desktop/fetch.tag</code>. If this file is present, fetching is skipped. You can remove it manually, or use <code>make rebuild</code>, if you want to force refetching.</p>
<h3 id="cookbook-3"><a class="header" href="#cookbook-3">Cookbook</a></h3>
<p>Each recipe is built according to the <code>recipe.toml</code> file. The recipe binaries or library objects are placed in the <code>target</code> directory, in a subdirectory named based on the CPU architecture.</p>
<p>If you have a problem with a recipe you are building, try the <code>make c.recipe-name</code> command. A common problem when building on unsupported systems is that certain recipes will fail to build due to missing dependencies. Try using the <a href="./podman-build.html">Podman Build</a> or manually installing the recipe dependencies.</p>
<p>After all recipes are cooked, a tag file is created as <code>build/$ARCH/$CONFIG_NAME/repo.tag</code>. If this file is present, cooking is skipped. You can remove it manually, or use <code>make rebuild</code>, which will force refetching and rebuilding.</p>
<h3 id="create-the-image-with-fuse"><a class="header" href="#create-the-image-with-fuse">Create the Image with FUSE</a></h3>
<p>To build the final Redox image, <code>redox_installer</code> uses <a href="https://github.com/libfuse/libfuse">FUSE</a>, creating a virtual filesystem and copying the recipe packages into it. This is done outside of Podman, even if you are using Podman Build.</p>
<p>On some Linux distributions, FUSE may not be permitted for some users, or <code>podman_bootstrap.sh</code> and <code>native_bootstrap.sh</code> might not install it correctly. Investigate whether you can address your FUSE issues, or join the <a href="./chat.html">chat</a> if you need advice.</p>
<h2 id="solving-compilation-problems"><a class="header" href="#solving-compilation-problems">Solving Compilation Problems</a></h2>
<ul>
<li>
<p>Verify your Rust version (run <code>make env</code> and <code>cargo --version</code>, then <code>exit</code>), make sure you have <strong>the latest version of Rust nightly!</strong>.</p>
<ul>
<li><a href="https://www.rustup.rs">rustup.rs</a> is recommended for managing Rust versions. If you already have it, run the <code>rustup</code> command.</li>
</ul>
</li>
<li>
<p>Verify if your <code>make</code> and <code>nasm</code> are up-to-date.</p>
</li>
<li>
<p>Verify if the build system is using the latest commit by running the <code>git branch -v</code> command.</p>
</li>
<li>
<p>Verify if the submodules are using the latest pinned commit, to do this run:</p>
</li>
</ul>
<pre><code class="language-sh">cd submodule-name
</code></pre>
<pre><code class="language-sh">git branch -v
</code></pre>
<ul>
<li>Verify if the recipe source is using the latest commit of the default branch, to do this run:</li>
</ul>
<pre><code class="language-sh">cd recipes/some-category/recipe-name/source
</code></pre>
<pre><code class="language-sh">git branch -v
</code></pre>
<ul>
<li>Run <code>make clean pull fetch</code> to remove all your compiled binaries and update all sources.</li>
<li>Sometimes there are merge requests that briefly break the build, so check the <a href="./chat.html">Chat</a> if anyone else is experiencing your problems.</li>
<li>Sometimes both the source and the binary of some recipe is wrong, run <code>make ur.recipe-name</code> and verify if it fix the problem.</li>
</ul>
<h4 id="environment-leakage"><a class="header" href="#environment-leakage">Environment Leakage</a></h4>
<p>Environment leakage is when some program or library is not fully cross-compiled to Redox, thus its dependency chain has Linux references that don't work on Redox.</p>
<p>It usually happens when the program or library get objects from outside the Redox build system PATH.</p>
<ul>
<li>The Redox build system PATH only read at <code>/usr/bin</code> and <code>/bin</code> to use the host system build tools</li>
<li>The program build system must use the host system build tools and the Cookbook recipe dependencies, not the host system libraries.</li>
<li>The most common way to detect this is to install the <code>*-dev</code> dependency package equivalent to the program recipe dependency, for example:</li>
</ul>
<p>The program named "my-program" needs to use the OpenSSL library, thus you add the <code>openssl</code> recipe on the <code>recipe.toml</code> of the program, but the program don't detect the OpenSSL source code.</p>
<p>Then you install the <code>libssl-dev</code> package on your Ubuntu system and rebuild the program with the <code>make cr.my-program</code> command, then it finish the build process successfully.</p>
<p>But when you try to open the executable of the program inside of Redox, it doesn't work. Because it contain Linux references.</p>
<p>To fix this problem you need to find where the program build system get the OpenSSL source code and patch it with <code>${COOKBOOK_SYSROOT}</code> environment variable (where the <code>openssl</code> recipe contents were copied)</p>
<h3 id="update-your-build-system"><a class="header" href="#update-your-build-system">Update Your Build System</a></h3>
<p>Sometimes your build system can be outdated because you forgot to run <code>make pull</code> before other commands, read <a href="./build-system-reference.html#update-the-build-system">this</a> section to learn the complete way to update the build system.</p>
<h3 id="prevent-and-fix-breaking-changes"><a class="header" href="#prevent-and-fix-breaking-changes">Prevent and Fix Breaking Changes</a></h3>
<p>Sometimes build system or recipe breaking changes are merged (you need to monitor the Dev room in our <a href="./chat.html">chat</a> to know if some commit or MR containing breaking changes were merged) and you need to cleanup your recipe or build system tooling binaries before the recipe or build system source updates to avoid conflicts with the new configuration.</p>
<h4 id="build-system-breakage-prevention"><a class="header" href="#build-system-breakage-prevention">Build System Breakage Prevention</a></h4>
<p>The following methods can prevent a build system breakage after updates that change file configuration behavior.</p>
<ul>
<li>Wipe all recipe binaries, update build system source and rebuild the system (most common prevention)</li>
</ul>
<pre><code class="language-sh">make clean pull all
</code></pre>
<ul>
<li>Wipe all recipe binaries and Podman container, update build system source and rebuild the system</li>
</ul>
<pre><code class="language-sh">make clean container_clean pull all
</code></pre>
<ul>
<li>Wipe all recipe binaries/sources, update build system source and rebuild the system (least common prevention)</li>
</ul>
<pre><code class="language-sh">make distclean pull all
</code></pre>
<h4 id="build-system-fixing"><a class="header" href="#build-system-fixing">Build System Fixing</a></h4>
<p>If the breaking change affect multiple recipes or any recipe can't be built, read the following instructions:</p>
<ul>
<li>Wipe the build system binaries and build the system (most common fix)</li>
</ul>
<pre><code class="language-sh">make clean all
</code></pre>
<p>Check if the compilation or runtime error continues after this command, if the error continues run the command below:</p>
<ul>
<li>Wipe and rebuild the filesystem tooling</li>
</ul>
<pre><code class="language-sh">make fstools_clean fstools
</code></pre>
<p>Check if the compilation or runtime error continues after this command, if the error continues run the command below:</p>
<ul>
<li>Wipe the Podman container (not common fix)</li>
</ul>
<pre><code class="language-sh">make container_clean
</code></pre>
<p>Check if the compilation or runtime error continues after this command, if the error continues it doesn't happen because of breaking changes on the build system.</p>
<h4 id="recipe-fixing"><a class="header" href="#recipe-fixing">Recipe Fixing</a></h4>
<p>Some types of recipe errors can be backwards-incompatible build system, system component or relibc changes after the <code>make pull rebuild</code> command execution. Run the following tests to verify if the recipe error is an isolated problem or a breaking change:</p>
<ul>
<li>Rebuild the recipe binaries</li>
</ul>
<pre><code class="language-sh">make cr.recipe-name
</code></pre>
<p>Check if the compilation or runtime error continues after this command, if the error continues run the following command:</p>
<ul>
<li>Wipe the recipe sources and binaries and rebuild</li>
</ul>
<pre><code class="language-sh">make ur.recipe-name
</code></pre>
<p>Check if the compilation or runtime error continues after this command, if the error continues run the following command:</p>
<ul>
<li>Update relibc and rebuild the recipe</li>
</ul>
<pre><code class="language-sh">touch relibc
</code></pre>
<pre><code class="language-sh">make prefix cr.recipe-name
</code></pre>
<p>Check if the compilation or runtime error continues after this command, if the error continues run the following command:</p>
<ul>
<li>Reconfigure the Redox toolchain and rebuild the recipe</li>
</ul>
<pre><code class="language-sh">rm -rf prefix
</code></pre>
<pre><code class="language-sh">make prefix cr.recipe-name
</code></pre>
<p>Check if the compilation or runtime error continues after this command, if the error continues run the following command:</p>
<ul>
<li>Wipe all statically linked recipe binaries and rebuild the system (run this command if the binaries of multiple recipes are broken)</li>
</ul>
<pre><code class="language-sh">make static_clean rebuild
</code></pre>
<p>Check if the compilation or runtime error continues after this command, if the error continues run the following command:</p>
<ul>
<li>Wipe all recipe binaries and rebuild the system (run this command if the binaries of multiple recipes are broken)</li>
</ul>
<pre><code class="language-sh">make repo_clean all
</code></pre>
<p>Check if the compilation or runtime error continues after this command, if the error continues run the following command:</p>
<ul>
<li>Wipe all recipe sources and binaries and rebuild the system (run this command if the sources and binaries of multiple recipes are broken)</li>
</ul>
<pre><code class="language-sh">make fetch_clean all
</code></pre>
<p>Check if the compilation or runtime error continues after this command, if the error continues read the section below.</p>
<h4 id="new-build-system-copy"><a class="header" href="#new-build-system-copy">New Build System Copy</a></h4>
<p>If the methods above doesn't work you need to download a new copy of the build system by running the <code>podman_bootstrap.sh</code> or <code>native_bootstrap.sh</code> scripts or using the following commands:</p>
<pre><code class="language-sh">git clone https://gitlab.redox-os.org/redox-os/redox.git --origin upstream
</code></pre>
<pre><code class="language-sh">cd redox
</code></pre>
<pre><code class="language-sh">make all
</code></pre>
<h3 id="update-your-branch"><a class="header" href="#update-your-branch">Update Your Branch</a></h3>
<p>If you are doing local changes on the build system, probably you left your branch active on the folder (instead of <code>master</code> branch).</p>
<p>New branches don't sync automatically with <code>master</code>, thus if the <code>master</code> branch receive new commits, you wouldn't use them because your branch is outdated.</p>
<p>To fix this, run:</p>
<pre><code class="language-sh">git checkout master
</code></pre>
<pre><code class="language-sh">git pull
</code></pre>
<pre><code class="language-sh">git checkout your-branch
</code></pre>
<pre><code class="language-sh">git merge master
</code></pre>
<p>Or</p>
<pre><code class="language-sh">git checkout master
</code></pre>
<pre><code class="language-sh">git pull
</code></pre>
<pre><code class="language-sh">git merge your-branch master
</code></pre>
<p>If you want an anonymous merge, read the <a href="./coding-and-building.html#anonymous-commits">Anonymous Commits</a> section.</p>
<h3 id="update-crates"><a class="header" href="#update-crates">Update Crates</a></h3>
<p>Sometimes a Rust program use an old crate version lacking Redox support, read <a href="./porting-applications.html#update-crates">this</a> section to learn how to update them.</p>
<h3 id="verify-the-dependency-tree"><a class="header" href="#verify-the-dependency-tree">Verify The Dependency Tree</a></h3>
<p>Some crates take a long time to do a new release (years in some cases), thus these releases will hold old versions of other crates, versions where the Redox support is not available (causing errors during the program compilation).</p>
<p>The <code>redox_syscall</code> crate is the most affected by this, some crates hold a very old version of it and will require patches (<code>cargo update -p</code> alone doesn't work).</p>
<p>To identify which crates are using old versions of Redox crates you will need to verify the dependency tree of the program, inside the program source directory, run:</p>
<pre><code class="language-sh">cargo tree --target=x86_64-unknown-redox
</code></pre>
<p>(If you aren't building Redox to x86_64 change <code>x86_64</code> in <code>x86_64-unknown-redox</code> to the CPU code that you are using)</p>
<p>This command will draw the dependency tree and you will need to find the crate name on the tree.</p>
<p>If you don't want to find it, you can use the <code>grep</code> tool with a pipe to see all crate versions used in the tree, sadly <code>grep</code> don't preserve the tree hierarchy, thus it's only useful to see versions and if some patched crate works (if the patched crate works all crate matches will report the most recent version).</p>
<p>To do this, run:</p>
<pre><code class="language-sh">cargo tree --target=x86_64-unknown-redox | grep crate-name
</code></pre>
<h2 id="debug-methods"><a class="header" href="#debug-methods">Debug Methods</a></h2>
<ul>
<li>
<p>Read <a href="https://en.wikipedia.org/wiki/Debugging#Techniques">this</a> Wikipedia section to learn about debugging techniques</p>
</li>
<li>
<p>Use the <code>dmesg</code> command to read the kernel and userspace daemons log</p>
</li>
<li>
<p>If Orbital hangs you need to verify if the system also freezed by pressing Super+F1 to see the boot log or Super+F2 to switch to other <code>tty</code>, login as <code>root</code> and run <code>dmesg</code> to read the system log ("Super" is the key with Windows logo)</p>
</li>
<li>
<p>You can start the QEMU with the <code>make qemu gpu=no</code> command to easily copy the terminal text</p>
</li>
<li>
<p>You can write to the <code>debug:</code> scheme, which will output on the console, but you must be the <code>root</code> user. This is useful if you are debugging an program where you need to use Orbital but still want to capture messages</p>
</li>
<li>
<p>Currently, the build system strips function names and other symbols from programs, as support for symbols is not implemented yet</p>
</li>
<li>
<p>To use GDB add the <code>gdbserver</code> recipe in your filesystem configuration, run the <code>make qemu gdb=yes</code> command in one shell, start the <code>gdbserver</code> program on QEMU and run the <code>make gdb</code> command in another shell</p>
</li>
<li>
<p>Use the following command for advanced logging:</p>
</li>
</ul>
<pre><code class="language-sh">make some-command 2&gt;&amp;1 | tee file-name.log
</code></pre>
<h3 id="recipes-1"><a class="header" href="#recipes-1">Recipes</a></h3>
<p>You will see the available debug methods for recipes on this section.</p>
<ul>
<li>If you change the recipe build mode (<code>release</code> to <code>debug</code> or the opposite) while debugging, don't forget to rebuild with <code>make cr.recipe-name</code> because the build system may not detect the changes.</li>
</ul>
<h4 id="rust"><a class="header" href="#rust">Rust</a></h4>
<p>Rust programs can carry assertions, checking and symbols, but they are disabled by default.</p>
<ul>
<li><code>REPO_DEBUG</code> - This environment variable will build the Rust program with assertions, checking and symbols.</li>
</ul>
<p>(Debugging with symbols inside of Redox is not supported yet)</p>
<p>To enable them you can use the following commands or scripts:</p>
<ul>
<li>Permanently enable <code>REPO_DEBUG</code> for all recipes by adding the following text to your <code>.config</code> file:</li>
</ul>
<pre><code>REPO_DEBUG?=1
</code></pre>
<ul>
<li>Enable the <code>REPO_DEBUG</code> environment variable for one command, rebuild/package a recipe and add to the Redox image:</li>
</ul>
<pre><code class="language-sh">REPO_DEBUG=1 make cr.recipe-name image
</code></pre>
<ul>
<li>Enable the <code>REPO_DEBUG</code> environment variable for multiple commands, rebuild/package a recipe and add to the Redox image:</li>
</ul>
<pre><code class="language-sh">export REPO_DEBUG=1
</code></pre>
<pre><code class="language-sh">make cr.recipe-name image
</code></pre>
<ul>
<li>Enable the <code>COOKBOOK_DEBUG</code> and <code>COOKBOOK_NOSTRIP</code> (they are equivalent to <code>REPO_DEBUG</code> environment variable) inside the <code>recipe.toml</code> :</li>
</ul>
<pre><code class="language-toml">template = "custom"
script = """
COOKBOOK_DEBUG=true
COOKBOOK_NOSTRIP=true
cookbook_cargo
"""
</code></pre>
<ul>
<li>Backtrace</li>
</ul>
<p>A backtrace helps you to detect bugs that happen with not expected input parameters, you can trace back through the callers to see where the bad data is coming from.</p>
<p>You can see how to use it below:</p>
<ul>
<li>Start QEMU with logging:</li>
</ul>
<pre><code class="language-sh">make qemu 2&gt;&amp;1 | tee file-name.log
</code></pre>
<ul>
<li>Enable this environment variable globally (on Redox):</li>
</ul>
<pre><code class="language-sh">export RUST_BACKTRACE=full
</code></pre>
<ul>
<li>
<p>Run the program and repeat the bug (capturing a backtrace in the log file)</p>
</li>
<li>
<p>Close QEMU</p>
</li>
<li>
<p>Open the log file, copy the backtrace and paste in an empty text file</p>
</li>
<li>
<p>Run the <code>backtrace.sh</code> script in the <code>redox</code> directory (on Linux):</p>
</li>
</ul>
<pre><code class="language-sh">scripts/backtrace.sh -r recipe-name -b your-backtrace.txt
</code></pre>
<p>It will print the file and line number for each entry in the backtrace.</p>
<p>(This is the most simple example command, use the <code>-h</code> option of the <code>backtrace.sh</code> script to see more combinations)</p>
<h4 id="gdb-on-qemu"><a class="header" href="#gdb-on-qemu">GDB On QEMU</a></h4>
<p>Use the following instructions to debug a recipe with GDB:</p>
<ul>
<li>Build or rebuild the recipe with assertions/checking/symbols and install into the Redox image:</li>
</ul>
<pre><code class="language-sh">make crp.recipe-name REPO_DEBUG=1
</code></pre>
<p>If you want to permanently enable debug binaries add the following environment variable to your <code>.config</code> file:</p>
<pre><code>REPO_DEBUG?=1
</code></pre>
<ul>
<li>Build and install the GDB server into the Redox image</li>
</ul>
<pre><code class="language-sh">make rp.gdbserver
</code></pre>
<ul>
<li>Start QEMU with the GDB configuration enabled:</li>
</ul>
<pre><code class="language-sh">make qemu kvm=no QEMU_SMP=1 gdb=yes
</code></pre>
<p>If the recipe has one executable, run the following command:</p>
<pre><code class="language-sh">make debug.recipe-name
</code></pre>
<p>If the recipe has multiple executables use the following command:</p>
<pre><code class="language-sh">make debug.recipe-name DEBUG_BIN=executable-name
</code></pre>
<h3 id="boot"><a class="header" href="#boot">Boot</a></h3>
<p>If your boot hangs and the log don't show the reason, you can use the following environment variables to help:</p>
<ul>
<li><code>BOOTSTRAP_LOG_LEVEL=value</code> : Bootstrap and process manager logging verbosity level</li>
<li><code>INIT_LOG_LEVEL=value</code> : Init logging verbosity level</li>
<li><code>DRIVER_LOG_LEVEL=value</code> : Logging verbosity level of all drivers</li>
<li><code>DRIVER_*_LOG_LEVEL=value</code> : Driver-specific logging verbosity level, for example: <code>DRIVER_PS2_LOG_LEVEL=value</code> for PS/2 logging and <code>DRIVER_USB_LOG_LEVEL=value</code> for USB logging</li>
<li><code>RELIBC_LOG_LEVEL=value</code> : Relibc logging verbosity level, you need to disable the <code>no_trace</code> feature flag by removing it from the <a href="https://gitlab.redox-os.org/redox-os/relibc/-/blob/7b9402783d6de31d3c749472027ce345aaff70fc/Cargo.toml#L82">default</a> feature group and run the <code>make static_clean rebuild</code> command to use it</li>
<li><code>INIT_SKIP=executable-name</code> : Skip the execution of executables with hangs or errors, commas are supported if you want to skip multiple executables</li>
</ul>
<p>They accept the following values:</p>
<ul>
<li><code>ERROR</code> value: Known event that is a fatal error but recoverable.</li>
<li><code>WARN</code> value: Unexpected event coming from unexpected condition.</li>
<li><code>INFO</code> value: Significant event mostly useful for developer.</li>
<li><code>DEBUG</code> value: Detailed event monitoring to show how the service is being used.</li>
<li><code>TRACE</code> value: Very verbose information which is only useful when debugging.</li>
</ul>
<p>Once you determine what you need press the <code>E</code> key to open the boot environment editor and add in the last lines and boot, for example:</p>
<pre><code>default environment variables here
INIT_LOG_LEVEL=DEBUG
DRIVER_LOG_LEVEL=DEBUG
</code></pre>
<p>You can see an example output below:</p>
<pre><code>2026-01-12T22-27-51.758Z [@ps2d::controller:468 WARN] ps2d: post-test unexpected value: 9C
2026-01-12T22-27-51.760Z [@ps2d::controller:337 ERROR] ps2d: keyboard failed to reset: 55
</code></pre>
<p>To disable the environment variables after boot run the <code>export *_LOG_LEVEL=OFF</code> command, for example: the <code>export RELIBC_LOG_LEVEL=OFF</code> command will disable relibc logging.</p>
<h2 id="kill-a-frozen-redox-vm"><a class="header" href="#kill-a-frozen-redox-vm">Kill A Frozen Redox VM</a></h2>
<p>Sometimes Redox can freeze or rarely get a kernel panic, to kill the QEMU process run this command:</p>
<pre><code class="language-sh">pkill qemu-system
</code></pre>
<h2 id="kernel-panic"><a class="header" href="#kernel-panic">Kernel Panic</a></h2>
<p>A kernel panic is when some bug avoid the safe execution of the kernel code, thus the system needs to be restarted to avoid memory corruption.</p>
<p>We use the following kernel panic message format:</p>
<pre><code>KERNEL PANIC: panicked at some-path/file-name.rs:line-number:character-position:
the panic description goes here
</code></pre>
<ul>
<li>You can use the following command to search it in a big log:</li>
</ul>
<pre><code class="language-sh">grep -nw "KERNEL PANIC" --include "file-name.log"
</code></pre>
<h3 id="qemu"><a class="header" href="#qemu">QEMU</a></h3>
<p>If you get a kernel panic in QEMU, copy the terminal text or capture a screenshot and send to us on <a href="./chat.html">Matrix</a> or create an issue on <a href="https://gitlab.redox-os.org/redox-os/kernel/-/issues">GitLab</a>.</p>
<h3 id="real-hardware-1"><a class="header" href="#real-hardware-1">Real Hardware</a></h3>
<p>If you get a kernel panic in real hardware, capture a photo and send to us on <a href="./chat.html">Matrix</a> or create an issue on <a href="https://gitlab.redox-os.org/redox-os/kernel/-/issues">GitLab</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="build-process"><a class="header" href="#build-process">Build Process</a></h1>
<p>This page explain what each build system command does in detail.</p>
<p>(Read the <a href="./build-system-reference.html">Build System</a> to know the context of each command)</p>
<ul>
<li><a href="build-phases.html#bootstrap-scripts">Bootstrap Scripts</a></li>
<li><a href="build-phases.html#toolchain">Toolchain</a></li>
<li><a href="build-phases.html#build-system">Build System</a></li>
<li><a href="build-phases.html#recipes">Recipes</a></li>
<li><a href="build-phases.html#qemu">QEMU</a></li>
</ul>
<h2 id="bootstrap-scripts"><a class="header" href="#bootstrap-scripts">Bootstrap Scripts</a></h2>
<h3 id="podman_bootstrapsh"><a class="header" href="#podman_bootstrapsh">podman_bootstrap.sh</a></h3>
<ul>
<li>Install Podman, GNU Make, Rust, FUSE and QEMU if it's not installed in the host system.</li>
<li>Download the build system sources (if you run without the <code>-d</code> option: <code>./podman_bootstrap.sh -d</code>)</li>
<li>Show a message with the commands to build the Redox system.</li>
</ul>
<h3 id="native_bootstrapsh"><a class="header" href="#native_bootstrapsh">native_bootstrap.sh</a></h3>
<ul>
<li>Install the Rust toolchain (using <a href="https://rustup.rs/">rustup.rs</a>).</li>
<li>Install the recipe build tools from your Linux or Unix-like distribution.</li>
<li>Download the build system sources (if you run without the <code>-d</code> option: <code>./native_bootstrap.sh -d</code>)</li>
<li>Show a message with the commands to build the Redox system.</li>
</ul>
<h2 id="toolchain"><a class="header" href="#toolchain">Toolchain</a></h2>
<h3 id="make-prefix"><a class="header" href="#make-prefix">make prefix</a></h3>
<ul>
<li>Download our Rust and GCC forks from the <a href="https://static.redox-os.org/toolchain/">Redox build server</a> (if it's not present or you if you executed <code>rm -rf prefix</code> to fix issues).</li>
<li>Build the <code>relibc</code> submodule.</li>
</ul>
<h3 id="make-prefix-after-touch-relibc-command"><a class="header" href="#make-prefix-after-touch-relibc-command">make prefix (after "touch relibc" command)</a></h3>
<ul>
<li>Build the new relibc changes</li>
</ul>
<h2 id="build-system-1"><a class="header" href="#build-system-1">Build System</a></h2>
<h3 id="make-pull"><a class="header" href="#make-pull">make pull</a></h3>
<ul>
<li>Update the build system source and submodules</li>
<li>Checkout submodules to the latest pinned commit</li>
</ul>
<h3 id="make-all-first-execution"><a class="header" href="#make-all-first-execution">make all (first execution)</a></h3>
<ul>
<li>Download the binaries of the Redox toolchain from the build server (if <code>make prefix</code> was not executed before).</li>
<li>Download the sources of the recipes specified on your filesystem configuration.</li>
<li>Cross-compile recipes to Redox.</li>
<li>Package recipe binaries as <code>pkgar</code> files.</li>
<li>Install packages in the QEMU virtual disk formatted with RedoxFS.</li>
</ul>
<h3 id="make-all-second-execution-and-next"><a class="header" href="#make-all-second-execution-and-next">make all (second execution and next)</a></h3>
<p>If the <code>build/$ARCH/$CONFIG/repo.tag</code> file is up to date, it won't do anything. If the <code>repo.tag</code> file is missing it will work like the <code>make rebuild</code> command.</p>
<h3 id="make-all-podman-environment-first-execution"><a class="header" href="#make-all-podman-environment-first-execution">make all (Podman environment, first execution)</a></h3>
<ul>
<li>Download the Redox container image.</li>
<li>Install the Rust and Redox toolchains (inside the container).</li>
<li>Install the recipe build tools (inside the container).</li>
<li>Download the sources of the recipes specified on your filesystem configuration.</li>
<li>Cross-compile recipes to Redox (inside the container).</li>
<li>Package recipe binaries as <code>pkgar</code> files.</li>
<li>Install recipe packages in the QEMU virtual disk formatted with RedoxFS.</li>
</ul>
<h3 id="make-rebuild"><a class="header" href="#make-rebuild">make rebuild</a></h3>
<ul>
<li>Verify source changes on recipes (if available, download them) or if a new recipe was added to the filesystem configuration.</li>
<li>Cross-compile recipes with changes to Redox.</li>
<li>Package recipe binaries with changes as <code>pkgar</code> files.</li>
<li>Install recipe packages with changes in the QEMU virtual disk formatted with RedoxFS.</li>
</ul>
<h3 id="make-image"><a class="header" href="#make-image">make image</a></h3>
<ul>
<li>Verify source changes on recipes (if the build system was updated or has changes)</li>
<li>Create a new Redox image with new recipe changes or recipes</li>
</ul>
<h2 id="recipes-2"><a class="header" href="#recipes-2">Recipes</a></h2>
<h3 id="make-rrecipe"><a class="header" href="#make-rrecipe">make r.recipe</a></h3>
<ul>
<li>Search the recipe location.</li>
<li>Verify if the <code>source</code> folder is present, if not, download the source from the method specified inside the <code>recipe.toml</code> (this step will be ignored if the <code>[source]</code> section and its data types aren't present or were commented out).</li>
<li>Build the recipe library dependencies as shared or static objects.</li>
<li>Start the compilation based on the template of the <code>recipe.toml</code></li>
<li>If the recipe is using Cargo, it will download the crates, build them, link them/relibc to the program binary.</li>
<li>If the recipe is using GNU Autotools, CMake or Meson, they will check the build environment and dependencies presence/versions for compatibility, build the libraries or the program and link them/relibc to the final binary.</li>
<li>Package the recipe binaries.</li>
</ul>
<h2 id="qemu-1"><a class="header" href="#qemu-1">QEMU</a></h2>
<h3 id="make-qemu"><a class="header" href="#make-qemu">make qemu</a></h3>
<ul>
<li>It checks for pending changes, if found, it will trigger <code>make rebuild</code>.</li>
<li>It checks the existence of the QEMU image, if not available, it will works like <code>make image</code>.</li>
<li>A command with custom arguments is passed to QEMU to boot Redox without problems.</li>
<li>The QEMU window is shown with a menu to choose the resolution.</li>
<li>The bootloader does a bootstrap of the kernel, the kernel starts the init, the init starts the user-space daemons and Orbital.</li>
<li>The Orbital login screen appear.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="developing-for-redox"><a class="header" href="#developing-for-redox">Developing for Redox</a></h1>
<p>Currently Redox does not have a complete set of development tools that run natively. You must do your development on Linux or other Unix-like system, then include or copy your program to your Redox filesystem. This chapter outlines some of the things you can do as a developer.</p>
<p>(Before reading this chapter you <strong>must</strong> read the <a href="./build-system-reference.html">Build System</a> page)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="developer-faq"><a class="header" href="#developer-faq">Developer FAQ</a></h1>
<p>The <a href="https://www.redox-os.org/faq/">General FAQ</a> have questions and answers of/for newcomers and end-users, while this FAQ contain organization, technical questions and answers of/for developers and testers, feel free to suggest new questions and answers.</p>
<p>(If the following questions aren't enough, ask us in the <a href="./chat.html">Chat</a>)</p>
<ul>
<li><a href="developer-faq.html#general-questions">General Questions</a>
<ul>
<li><a href="developer-faq.html#why-does-redox-have-unsafe-rust-code">Why does Redox have unsafe Rust code?</a></li>
<li><a href="developer-faq.html#why-does-redox-have-assembly-code">Why does Redox have Assembly code?</a></li>
<li><a href="developer-faq.html#why-does-redox-do-cross-compilation">Why does Redox do cross-compilation?</a></li>
<li><a href="developer-faq.html#does-redox-support-opengl-and-vulkan">Does Redox support OpenGL and Vulkan?</a></li>
<li><a href="developer-faq.html#how-can-i-port-a-program">How can I port a program?</a></li>
<li><a href="developer-faq.html#how-can-i-write-a-driver">How can I write a driver?</a></li>
<li><a href="developer-faq.html#how-can-i-debug">How can I debug?</a></li>
<li><a href="developer-faq.html#what-is-the-software-and-hardware-requirements-for-development">What is the software and hardware requirements for development?</a></li>
</ul>
</li>
<li><a href="developer-faq.html#build-system-questions">Build System Questions</a>
<ul>
<li><a href="developer-faq.html#what-is-the-correct-way-to-update-the-build-system">What is the correct way to update the build system?</a></li>
<li><a href="developer-faq.html#how-can-i-verify-if-my-build-system-is-up-to-date">How can I verify if my build system is up-to-date?</a></li>
<li><a href="developer-faq.html#what-is-a-recipe">What is a recipe?</a></li>
<li><a href="developer-faq.html#when-i-should-rebuild-the-build-system-or-recipes-from-scratch">When I should rebuild the build system or recipes from scratch?</a></li>
<li><a href="developer-faq.html#how-can-i-test-my-changes-on-real-hardware">How can I test my changes on real hardware?</a></li>
<li><a href="developer-faq.html#how-can-i-insert-files-to-the-redox-image">How can I insert files to the Redox image?</a></li>
<li><a href="developer-faq.html#how-can-i-change-my-redox-variant">How can I change my Redox variant?</a></li>
<li><a href="developer-faq.html#how-can-i-increase-the-filesystem-size-of-my-qemu-image">How can I increase the filesystem size of my QEMU image?</a></li>
<li><a href="developer-faq.html#how-can-i-change-the-cpu-architecture-of-my-build-system">How can I change the CPU architecture of my build system?</a></li>
<li><a href="developer-faq.html#how-can-i-cross-compile-to-arm64-from-a-x86-64-computer">How can I cross-compile to ARM64 from a x86-64 computer?</a></li>
<li><a href="developer-faq.html#how-can-i-use-a-recipe-in-my-redox-image">How can I use a recipe in my Redox image?</a></li>
<li><a href="developer-faq.html#how-to-update-initfs">How to update initfs?</a></li>
<li><a href="developer-faq.html#i-made-changes-to-my-recipe-what-is-the-quickest-way-to-test-it-in-qemu">I made changes to my recipe. What is the quickest way to test it in QEMU?</a></li>
<li><a href="developer-faq.html#i-made-changes-to-multiple-recipes-what-is-the-quickest-way-to-test-it-in-qemu">I made changes to multiple recipes. What is the quickest way to test it in QEMU?</a></li>
<li><a href="developer-faq.html#how-can-i-disable-recipe-compilation">How can I disable recipe compilation?</a></li>
<li><a href="developer-faq.html#how-can-i-disable-recipe-compilation-except-for-a-specific-recipe">How can I disable recipe compilation except for a specific recipe?</a></li>
<li><a href="developer-faq.html#how-to-disable-the-automatic-recipe-source-update">How to disable the automatic recipe source update?</a></li>
<li><a href="developer-faq.html#how-can-i-install-the-packages-needed-by-recipes-native-build-or-podman-without-a-new-download-of-the-build-system">How can I install the packages needed by recipes (Native Build) or Podman without a new download of the build system?</a></li>
<li><a href="developer-faq.html#how-can-i-build-the-toolchain-from-source">How can I build the toolchain from source?</a></li>
</ul>
</li>
<li><a href="developer-faq.html#porting-questions">Porting Questions</a>
<ul>
<li><a href="developer-faq.html#how-to-determine-if-some-program-is-portable-to-redox">How to determine if some program is portable to Redox?</a></li>
<li><a href="developer-faq.html#how-to-determine-the-dependencies-of-some-program">How to determine the dependencies of some program?</a></li>
<li><a href="developer-faq.html#how-can-i-configure-the-build-system-of-the-recipe">How can I configure the build system of the recipe?</a></li>
<li><a href="developer-faq.html#how-can-i-search-for-functions-on-relibc">How can I search for functions on relibc?</a></li>
<li><a href="developer-faq.html#which-are-the-upstream-requirements-to-accept-my-recipe">Which are the upstream requirements to accept my recipe?</a></li>
<li><a href="developer-faq.html#what-are-the-possible-problems-when-porting-programs-and-libraries">What are the possible problems when porting programs and libraries?</a></li>
<li><a href="developer-faq.html#why-cc-programs-and-libraries-are-hard-and-time-consuming-to-port">Why C/C++ programs and libraries are hard and time consuming to port?</a></li>
</ul>
</li>
<li><a href="developer-faq.html#scheme-questions">Scheme Questions</a>
<ul>
<li><a href="developer-faq.html#what-is-a-scheme">What is a scheme?</a></li>
<li><a href="developer-faq.html#when-does-a-regular-program-need-to-use-a-scheme">When does a regular program need to use a scheme?</a></li>
<li><a href="developer-faq.html#when-would-i-write-a-program-to-implement-a-scheme">When would I write a program to implement a scheme?</a></li>
<li><a href="developer-faq.html#how-do-i-use-a-scheme-for-sandboxing-a-program">How do I use a scheme for sandboxing a program?</a></li>
<li><a href="developer-faq.html#how-can-i-see-all-userspace-schemes">How can I see all userspace schemes?</a></li>
<li><a href="developer-faq.html#how-can-i-see-all-kernel-schemes">How can I see all kernel schemes?</a></li>
<li><a href="developer-faq.html#what-is-the-difference-between-kernel-and-userspace-schemes">What is the difference between kernel and userspace schemes?</a></li>
<li><a href="developer-faq.html#how-does-a-userspace-daemon-provide-file-like-services">How does a userspace daemon provide file-like services?</a></li>
<li><a href="developer-faq.html#how-the-system-calls-are-used-by-userspace-daemons">How the system calls are used by userspace daemons?</a></li>
</ul>
</li>
<li><a href="developer-faq.html#gitlab-questions">GitLab Questions</a>
<ul>
<li><a href="developer-faq.html#how-to-properly-request-a-review-or-review-mrs">How to properly request a review or review MRs?</a></li>
<li><a href="developer-faq.html#i-have-a-merge-request-with-many-commits-should-i-squash-them-after-merge">I have a merge request with many commits, should I squash them after merge?</a></li>
<li><a href="developer-faq.html#should-i-delete-my-branch-after-merge">Should I delete my branch after merge?</a></li>
<li><a href="developer-faq.html#how-can-i-have-an-anonymous-account">How can I have an anonymous account?</a></li>
</ul>
</li>
<li><a href="developer-faq.html#documentation-questions">Documentation Questions</a>
<ul>
<li><a href="developer-faq.html#how-can-i-write-code-documentation-properly">How can I write code documentation properly?</a></li>
<li><a href="developer-faq.html#how-can-i-write-book-documentation-properly">How can I write book documentation properly?</a></li>
<li><a href="developer-faq.html#how-can-i-insert-commands-or-code-correctly">How can I insert commands or code correctly?</a></li>
<li><a href="developer-faq.html#how-can-i-create-diagrams">How can I create diagrams?</a></li>
</ul>
</li>
<li><a href="developer-faq.html#troubleshooting-questions">Troubleshooting Questions</a>
<ul>
<li><a href="developer-faq.html#scripts">è…³æœ¬</a>
<ul>
<li><a href="developer-faq.html#i-cant-download-the-build-system-bootstrap-scripts-how-can-i-fix-this">I can't download the build system bootstrap scripts, how can I fix this?</a></li>
<li><a href="developer-faq.html#i-tried-to-run-the-podman_bootstrapsh-and-native_bootstrapsh-scripts-but-got-an-error-how-to-fix-this">I tried to run the "podman_bootstrap.sh" and "native_bootstrap.sh" scripts but got an error, how to fix this?</a></li>
</ul>
</li>
<li><a href="developer-faq.html#build-system">Build System</a>
<ul>
<li><a href="developer-faq.html#i-ran-make-all-but-it-show-a-rustup-cant-be-found-message-how-can-i-fix-this">I ran "make all" but it show a "rustup can't be found" message, how can I fix this?</a></li>
<li><a href="developer-faq.html#i-tried-all-troubleshooting-methods-but-my-build-system-is-still-broken-how-can-i-fix-that">I tried all troubleshooting methods but my build system is still broken, how can I fix that?</a></li>
</ul>
</li>
<li><a href="developer-faq.html#recipes">Recipes</a>
<ul>
<li><a href="developer-faq.html#i-had-an-error-with-a-recipe-how-can-i-fix-that">I had an error with a recipe, how can I fix that?</a></li>
<li><a href="developer-faq.html#i-tried-all-methods-of-the-troubleshooting-the-build-page-and-my-recipe-still-doesnt-build-what-can-i-do">I tried all methods of the "Troubleshooting the Build" page and my recipe still doesn't build, what can I do?</a></li>
<li><a href="developer-faq.html#when-i-run-make-rrecipe-i-get-a-syntax-error-how-can-i-fix-that">When I run "make r.recipe" I get a syntax error, how can I fix that?</a></li>
<li><a href="developer-faq.html#when-i-run-cargo-update-on-some-recipe-source-it-call-rustup-to-install-other-rust-toolchain-version-how-can-i-fix-that">When I run "cargo update" on some recipe source it call Rustup to install other Rust toolchain version, how can I fix that?</a></li>
<li><a href="developer-faq.html#i-added-the-dependency-of-my-program-in-the-recipetoml-file-but-the-program-build-system-doesnt-detect-it-then-i-installed-the-program-dependency-on-my-linux-distribution-and-it-detected-why">I added the dependency of my program in the "recipe.toml" file but the program build system doesn't detect it, then I installed the program dependency on my Linux distribution and it detected, why?</a></li>
<li><a href="developer-faq.html#i-made-changes-to-system-daemons-drivers-and-redoxfs-but-they-arent-applied-in-the-redox-image-how-can-i-fix-that">I made changes to system daemons, drivers and RedoxFS but they aren't applied in the Redox image, how can I fix that?</a></li>
</ul>
</li>
<li><a href="developer-faq.html#qemu">QEMU</a>
<ul>
<li><a href="developer-faq.html#how-can-i-kill-the-qemu-process-if-redox-freezes-or-get-a-kernel-panic">How can I kill the QEMU process if Redox freezes or get a kernel panic?</a></li>
</ul>
</li>
<li><a href="developer-faq.html#real-hardware">Real Hardware</a>
<ul>
<li><a href="developer-faq.html#i-got-a-kernel-panic-what-can-i-do">I got a kernel panic, what can I do?</a></li>
<li><a href="developer-faq.html#some-driver-is-not-working-with-my-hardware-what-can-i-do">Some driver is not working with my hardware, what can I do?</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="general-questions"><a class="header" href="#general-questions">General Questions</a></h2>
<h3 id="why-does-redox-have-unsafe-rust-code"><a class="header" href="#why-does-redox-have-unsafe-rust-code">Why does Redox have unsafe Rust code?</a></h3>
<p>In some cases we must use <code>unsafe</code> declarations to allow some low-level tasks, for example at certain parts in the kernel and drivers, these unsafe parts are generally wrapped with a safe interface.</p>
<p>These are the cases where unsafe Rust is mandatory:</p>
<ul>
<li>Implementing a foreign function interface (FFI) (for example the relibc API)</li>
<li>Working with system calls directly (you should use <code>libredox</code>, <code>relibc</code> or Rust <code>libstd</code> library instead of <code>redox_syscall</code>)</li>
<li>Creating or managing processes and threads</li>
<li>Working with memory mapping and stack allocation</li>
<li>Working with hardware devices</li>
</ul>
<p>It is an important goal for Redox to minimize the amount of <code>unsafe</code> declared Rust code. If you want to use unsafe Rust code on Redox anywhere other than interfacing with system calls, ask for Jeremy Soller's approval before.</p>
<p>Unsafe Rust still has most of the compiler verification and allow some safe Rust syntax usage, thus still more safe than C and C++.</p>
<p>Read the following pages to learn more about Unsafe Rust:</p>
<ul>
<li>https://doc.rust-lang.org/book/ch20-01-unsafe-rust.html</li>
<li>https://doc.rust-lang.org/nomicon/meet-safe-and-unsafe.html</li>
</ul>
<h3 id="why-does-redox-have-assembly-code"><a class="header" href="#why-does-redox-have-assembly-code">Why does Redox have Assembly code?</a></h3>
<p><a href="https://en.wikipedia.org/wiki/Assembly_language">Assembly</a> is the core of low-level because it's a CPU-specific programming language and deal with things that aren't possible or feasible to do in high-level languages like Rust.</p>
<p>Sometimes required or preferred for accessing hardware, or for carefully optimized hot spots.</p>
<p>Reasons to use Assembly instead of Rust:</p>
<ul>
<li>Deal with low-level things (those that can't be handled by Rust)</li>
<li>Writing constant time algorithms for cryptography</li>
<li>Optimizations</li>
</ul>
<p>Places where Assembly is used:</p>
<ul>
<li><code>kernel</code> - Interrupt and system call entry routines, context switching, special CPU instructions and registers</li>
<li><code>drivers</code> - Port IO need special instructions (x86_64)</li>
<li><code>relibc</code> - Some parts of the C runtime</li>
</ul>
<h3 id="why-does-redox-do-cross-compilation"><a class="header" href="#why-does-redox-do-cross-compilation">Why does Redox do cross-compilation?</a></h3>
<p><a href="https://en.wikipedia.org/wiki/Cross_compiler">Cross-compilation</a> is when you build a program or library from one CPU architecture to another CPU architecture or one operating system to another operating system, but it require more configuration than native compilation.</p>
<p>Read some of the reasons below:</p>
<ul>
<li>When developing a new operating system you can't build programs inside of it because the system interfaces are premature. Thus you need to build the programs from your host system to the new OS and transfer the binaries to the filesystem of the new OS.</li>
<li>Cross-compilation reduces the porting requirements because you don't need to support the compiler of the program's programming language, the program's build system and build tools. You just need to port the programming language standard library (if used), program libraries or the program source code (dependency-free).</li>
<li>Some developers prefer to develop from other operating systems like Linux, MacOS, FreeBSD or Windows, the same applies for Linux where some developers write code on MacOS and test their kernel builds in a virtual machine (mostly QEMU) or real hardware.</li>
</ul>
<p>(Interpreted programs and scripts don't need cross-compilation but the programming language's interpreter or possible compiled dependencies needs to be ported and cross-compiled to Redox)</p>
<h3 id="does-redox-support-opengl-and-vulkan"><a class="header" href="#does-redox-support-opengl-and-vulkan">Does Redox support OpenGL and Vulkan?</a></h3>
<p>Read the <a href="./graphics-windowing.html#software-rendering">Software Rendering</a> section.</p>
<h3 id="how-can-i-port-a-program"><a class="header" href="#how-can-i-port-a-program">How can I port a program?</a></h3>
<p>Read the <a href="./porting-applications.html">Application Porting</a> page.</p>
<h3 id="how-can-i-write-a-driver"><a class="header" href="#how-can-i-write-a-driver">How can I write a driver?</a></h3>
<p>Read the <a href="https://gitlab.redox-os.org/redox-os/drivers/-/blob/master/README.md">drivers repository README</a>.</p>
<h3 id="how-can-i-debug"><a class="header" href="#how-can-i-debug">How can I debug?</a></h3>
<p>Read the <a href="./troubleshooting.html#debug-methods">Debug Methods</a> section.</p>
<h3 id="what-is-the-software-and-hardware-requirements-for-development"><a class="header" href="#what-is-the-software-and-hardware-requirements-for-development">What is the software and hardware requirements for development?</a></h3>
<ul>
<li>If you are using the Podman Build you need any Linux or Unix-like distribution supporting Podman 4.0 or newer and FUSE 3.x (if you have problems with FUSE in the host system there's <a href="./advanced-podman-build.html#installing-without-fuse">this</a> workaround to run FUSE inside the Podman container instead of host system)</li>
<li>If you are using the Native Build a recent Ubuntu, PopOS or Fedora version is recommended</li>
</ul>
<p>The following hardware requirements are enough for fast compilation of the system and most programs, but some heavy programs may require more.</p>
<ul>
<li>An Intel or AMD CPU newer than 10 years with 4 cores/threads or more</li>
<li>4GB DDR4 or more (8GB or 16GB for heavy programs)</li>
<li>50GB of storage space or more (a high-performance HDD, SSD, and NVMe is recommended)</li>
<li>An Internet connection good enough to not cause timeouts</li>
</ul>
<h2 id="build-system-questions"><a class="header" href="#build-system-questions">Build System Questions</a></h2>
<h3 id="what-is-the-correct-way-to-update-the-build-system"><a class="header" href="#what-is-the-correct-way-to-update-the-build-system">What is the correct way to update the build system?</a></h3>
<p>Read the <a href="./build-system-reference.html#update-the-build-system">Update The Build System</a> section.</p>
<h3 id="how-can-i-verify-if-my-build-system-is-up-to-date"><a class="header" href="#how-can-i-verify-if-my-build-system-is-up-to-date">How can I verify if my build system is up-to-date?</a></h3>
<p>After the <code>make pull</code> command, run the <code>git rev-parse HEAD</code> command to verify if it match the latest commit hash on <a href="https://gitlab.redox-os.org/redox-os/redox/-/commits/master?ref_type=HEADS">GitLab</a>.</p>
<h3 id="what-is-a-recipe"><a class="header" href="#what-is-a-recipe">What is a recipe?</a></h3>
<p>A software port to Redox</p>
<h3 id="when-i-should-rebuild-the-build-system-or-recipes-from-scratch"><a class="header" href="#when-i-should-rebuild-the-build-system-or-recipes-from-scratch">When I should rebuild the build system or recipes from scratch?</a></h3>
<p>Sometimes the execution of the <code>make pull rebuild</code> command is not enough to update the build system and recipes because of breaking changes, learn what to do on the following changes:</p>
<ul>
<li>New relibc functions and fixes: to allow a recipe to use the new relibc functions you need to rebuilt it with the <code>make cr.recipe-name</code> command, sometimes relibc fixes require a complete system rebuild by running the <code>make c.--all all</code> command</li>
<li>Dependency changes on recipes: if the shared objects had symbol changes or the recipe is statically linked, run the <code>make cr.recipe-name</code> command</li>
<li>Configuration changes on recipes: run the <code>make cr.recipe-name</code> command</li>
<li>Source code changes on recipes: if the shared objects had symbol changes or the recipe is statically linked, run the <code>make ucr.recipe-name</code> command</li>
<li>Changes on the location of the build system artifacts: run the <code>make clean pull all</code> command to not cause breakage with the previous artifacts locations, if the previous location of the build artifacts had contents you can try to fix manually or download the build system again to avoid confusion or fix difficult breakage</li>
</ul>
<h3 id="how-can-i-test-my-changes-on-real-hardware"><a class="header" href="#how-can-i-test-my-changes-on-real-hardware">How can I test my changes on real hardware?</a></h3>
<p>Read the <a href="./coding-and-building.html#testing-on-real-hardware">Testing on Real Hardware</a> section.</p>
<h3 id="how-can-i-insert-files-to-the-redox-image"><a class="header" href="#how-can-i-insert-files-to-the-redox-image">How can I insert files to the Redox image?</a></h3>
<p>If you use a <a href="./coding-and-building.html#insert-files-on-the-qemu-image-using-a-recipe">recipe</a> your changes will persist after the <code>make image</code> command, but you can also <a href="./coding-and-building.html#insert-files-on-the-qemu-image">mount</a> the Redox filesystem to insert them directly.</p>
<h3 id="how-can-i-change-my-redox-variant"><a class="header" href="#how-can-i-change-my-redox-variant">How can I change my Redox variant?</a></h3>
<p>Insert the <code>CONFIG_NAME?=your-config-name</code> environment variable to your <code>.config</code> file, read the <a href="./configuration-settings.html#config">config</a> section for more details.</p>
<h3 id="how-can-i-increase-the-filesystem-size-of-my-qemu-image"><a class="header" href="#how-can-i-increase-the-filesystem-size-of-my-qemu-image">How can I increase the filesystem size of my QEMU image?</a></h3>
<p>Change the <code>filesystem_size</code> data type of your filesystem configuration at: <code>config/your-cpu-arch/your-config.toml</code> and run the <code>make image</code> command, read the <a href="./configuration-settings.html#filesystem-size">Filesystem Size</a> section for more details.</p>
<h3 id="how-can-i-change-the-cpu-architecture-of-my-build-system"><a class="header" href="#how-can-i-change-the-cpu-architecture-of-my-build-system">How can I change the CPU architecture of my build system?</a></h3>
<p>Insert the <code>ARCH?=your-cpu-arch</code> environment variable on your <code>.config</code> file and run the <code>make all</code> command, read the <a href="./configuration-settings.html#config">config</a> section for more details.</p>
<p>If you want to do it temporarily run the <code>make all ARCH=your-cpu-arch</code> command.</p>
<p>If you want to clean the binaries of the previous CPU architecture run the following command:</p>
<pre><code class="language-sh">make c.--all ARCH=previous-cpu-arch
</code></pre>
<h3 id="how-can-i-cross-compile-to-arm64-from-a-x86-64-computer"><a class="header" href="#how-can-i-cross-compile-to-arm64-from-a-x86-64-computer">How can I cross-compile to ARM64 from a x86-64 computer?</a></h3>
<p>Insert the <code>ARCH?=aarch64</code> environment variable on your <code>.config</code> file and run the <code>make all</code> command.</p>
<p>If you want to do it temporarily run the <code>make all ARCH=aarch64</code> command.</p>
<h3 id="how-can-i-use-a-recipe-in-my-redox-image"><a class="header" href="#how-can-i-use-a-recipe-in-my-redox-image">How can I use a recipe in my Redox image?</a></h3>
<p>If you want to quickly install the recipe package until the next image creation, run the following command:</p>
<pre><code class="language-sh">make rp.recipe-name
</code></pre>
<p>Or (if you want to use a remote package if you want to use it more quickly)</p>
<pre><code class="language-sh">make rp.recipe-name REPO_BINARY=1
</code></pre>
<p>If you want to permanently install the recipe on your image, read the following steps.</p>
<ul>
<li>Go to your filesystem configuration and add the recipe:</li>
</ul>
<pre><code class="language-sh">nano config/your-cpu-arch/your-config.toml
</code></pre>
<pre><code class="language-toml">[packages]
...
recipe-name = {}
...
</code></pre>
<p>Or (for a remote package)</p>
<pre><code class="language-toml">[packages]
...
recipe-name = "binary"
...
</code></pre>
<ul>
<li>Build the recipe and install in a existing image</li>
</ul>
<pre><code class="language-sh">make rp.recipe-name
</code></pre>
<p>Or (for a remote package)</p>
<pre><code class="language-sh">make rp.recipe-name REPO_BINARY=1
</code></pre>
<h2 id="how-to-update-initfs"><a class="header" href="#how-to-update-initfs">How to update initfs?</a></h2>
<p>initfs don't automatically add your changes to system daemons, drivers or RedoxFS and need manual rebuild.</p>
<p>Read <a href="./coding-and-building.html#how-to-update-initfs">this</a> section to learn how to do it.</p>
<h3 id="i-made-changes-to-my-recipe-what-is-the-quickest-way-to-test-it-in-qemu"><a class="header" href="#i-made-changes-to-my-recipe-what-is-the-quickest-way-to-test-it-in-qemu">I made changes to my recipe. What is the quickest way to test it in QEMU?</a></h3>
<p>If you did incremental changes (which don't change the binary symbols), run the following command:</p>
<ul>
<li>Rebuild the recipe, install to an existing image and launch QEMU</li>
</ul>
<pre><code class="language-sh">make rp.recipe-name qemu
</code></pre>
<p>If you did breaking changes (which changed the binary symbols) run the following command:</p>
<ul>
<li>Rebuild the recipe, install to an existing image and launch QEMU</li>
</ul>
<pre><code class="language-sh">make crp.recipe-name qemu
</code></pre>
<h3 id="i-made-changes-to-multiple-recipes-what-is-the-quickest-way-to-test-it-in-qemu"><a class="header" href="#i-made-changes-to-multiple-recipes-what-is-the-quickest-way-to-test-it-in-qemu">I made changes to multiple recipes. What is the quickest way to test it in QEMU?</a></h3>
<ul>
<li>Rebuild the modified recipes, install to an existing image and launch QEMU:</li>
</ul>
<pre><code class="language-sh">make rp.recipe1,recipe2 qemu
</code></pre>
<p>If you don't want to specify all modified recipes run the following command:</p>
<ul>
<li>Rebuild the modified recipes, install to an existing image and launch QEMU:</li>
</ul>
<pre><code class="language-sh">make repo push qemu
</code></pre>
<h3 id="how-can-i-disable-the-recipe-compilation"><a class="header" href="#how-can-i-disable-the-recipe-compilation">How can I disable the recipe compilation?</a></h3>
<p>Insert the <code>REPO_BINARY?=1</code> environment variable to your <code>.config</code> file, it will download pre-compiled recipe packages from the <a href="https://static.redox-os.org/pkg/">build server</a> if available.</p>
<h3 id="how-can-i-disable-recipe-compilation-except-for-a-specific-recipe"><a class="header" href="#how-can-i-disable-recipe-compilation-except-for-a-specific-recipe">How can I disable recipe compilation except for a specific recipe?</a></h3>
<p>After inserting the <code>REPO_BINARY?=1</code> environment variable to your <code>.config</code> file, go to your filesystem configuration and add the source-based variant of the recipe:</p>
<pre><code class="language-sh">nano config/your-cpu-arch/your-config.toml
</code></pre>
<pre><code class="language-toml">[packages]
...
recipe-name = "source"
...
</code></pre>
<ul>
<li>Install the recipe package in the Redox image</li>
</ul>
<pre><code class="language-sh">make rp.recipe-name
</code></pre>
<p>Or (if the above doesn't work)</p>
<pre><code class="language-sh">make rebuild
</code></pre>
<h3 id="how-to-disable-the-automatic-recipe-source-update"><a class="header" href="#how-to-disable-the-automatic-recipe-source-update">How to disable the automatic recipe source update?</a></h3>
<p>The build system automatically update recipe sources if new upstream commits exist, which can break your local changes.</p>
<p>To learn how to disable it for one or multiple recipes read <a href="./configuration-settings.html#local-recipe-changes">this</a> section.</p>
<p>To learn how to disable it for all recipes read <a href="./configuration-settings.html#cookbook-offline-mode">this</a> section.</p>
<h3 id="how-can-i-install-the-packages-needed-by-recipes-native-build-or-podman-without-a-new-download-of-the-build-system"><a class="header" href="#how-can-i-install-the-packages-needed-by-recipes-native-build-or-podman-without-a-new-download-of-the-build-system">How can I install the packages needed by recipes (Native Build) or Podman without a new download of the build system?</a></h3>
<ul>
<li>Run the following command from your build system:</li>
</ul>
<pre><code class="language-sh">./native_bootstrap.sh -d
</code></pre>
<p>(If you are using Podman this process is automatic)</p>
<p>Or (for Podman dependencies)</p>
<ul>
<li>Run the following command from your build system:</li>
</ul>
<pre><code class="language-sh">./podman_bootstrap.sh -d
</code></pre>
<h3 id="how-can-i-build-the-toolchain-from-source"><a class="header" href="#how-can-i-build-the-toolchain-from-source">How can I build the toolchain from source?</a></h3>
<ul>
<li>Disable the <code>PREFIX_BINARY</code> environment variable inside of your <code>.config</code> file:</li>
</ul>
<pre><code class="language-sh">nano .config
</code></pre>
<pre><code>PREFIX_BINARY?=0
</code></pre>
<ul>
<li>Clean the previous toolchain binaries and build new ones:</li>
</ul>
<pre><code class="language-sh">rm -rf prefix
</code></pre>
<pre><code class="language-sh">make prefix
</code></pre>
<ul>
<li>Clean the previous recipe binaries and build again with the new toolchain:</li>
</ul>
<pre><code class="language-sh">make c.--all all
</code></pre>
<h2 id="porting-questions"><a class="header" href="#porting-questions">Porting Questions</a></h2>
<h3 id="how-to-determine-if-some-program-is-portable-to-redox"><a class="header" href="#how-to-determine-if-some-program-is-portable-to-redox">How to determine if some program is portable to Redox?</a></h3>
<ul>
<li>The source code of the program must be available</li>
<li>The program should use cross-platform libraries (if not, more porting effort is required)</li>
<li>The program's build system should support cross-compilation (if not, more porting effort is required)</li>
<li>The program shouldn't directly use the Linux kernel API on its code (if not, more porting effort is required)</li>
</ul>
<p>Some APIs of the Linux kernel can be ported while others not, because they require a complete Linux kernel.</p>
<h3 id="how-to-determine-the-dependencies-of-some-program"><a class="header" href="#how-to-determine-the-dependencies-of-some-program">How to determine the dependencies of some program?</a></h3>
<p>Read the <a href="./porting-applications.html#dependencies">Dependencies</a> section.</p>
<h3 id="how-can-i-configure-the-build-system-of-the-recipe"><a class="header" href="#how-can-i-configure-the-build-system-of-the-recipe">How can I configure the build system of the recipe?</a></h3>
<p>Read the <a href="./porting-applications.html#templates">Templates</a> section.</p>
<h3 id="how-can-i-search-for-functions-on-relibc"><a class="header" href="#how-can-i-search-for-functions-on-relibc">How can I search for functions on relibc?</a></h3>
<p>Read the <a href="./porting-applications.html#search-for-functions-on-relibc">Search For Functions on Relibc</a> section.</p>
<h3 id="which-are-the-upstream-requirements-to-accept-my-recipe"><a class="header" href="#which-are-the-upstream-requirements-to-accept-my-recipe">Which are the upstream requirements to accept my recipe?</a></h3>
<p>Read the <a href="./porting-applications.html#package-policy">Package Policy</a> section.</p>
<h3 id="what-are-the-possible-problems-when-porting-programs-and-libraries"><a class="header" href="#what-are-the-possible-problems-when-porting-programs-and-libraries">What are the possible problems when porting programs and libraries?</a></h3>
<ul>
<li>Missing build tools</li>
<li>Cross-compilation configuration problems</li>
<li>Lack of Redox patches</li>
<li>Missing C, POSIX or Linux library functions in relibc</li>
<li>Runtime crashes or errors</li>
</ul>
<h3 id="why-cc-programs-and-libraries-are-hard-and-time-consuming-to-port"><a class="header" href="#why-cc-programs-and-libraries-are-hard-and-time-consuming-to-port">Why C/C++ programs and libraries are hard and time consuming to port?</a></h3>
<ul>
<li>C/C++ don't have an official, advanced and automatic dependency manager and build system which force programs and libraries to select competing build systems with different configurations (GNU Make, GNU Autotools, CMake, Meson and others), projects like <a href="https://conan.io/">Conan</a> and <a href="https://vcpkg.io/">vcpkg</a> tried to solve this problem but weren't adopted by most programs/libraries and lack many libraries</li>
<li>Programs and libraries need to manually manage the library versions, to workaround this some programs use bundled libraries which can difficult patching when needed</li>
<li>Some build systems lack a good cross-compilation support which require more tweaks and sometimes hacks</li>
<li>As libraries are manually managed programs with many dependencies can take hours to port depending on available library documentation/configuration and developer experience</li>
<li>Some programs and libraries have bad or lacking documentation about build instructions and configuration</li>
</ul>
<h2 id="scheme-questions"><a class="header" href="#scheme-questions">Scheme Questions</a></h2>
<h3 id="what-is-a-scheme-1"><a class="header" href="#what-is-a-scheme-1">What is a scheme?</a></h3>
<p>Read the <a href="./schemes-resources.html">Schemes and Resources</a> page.</p>
<h3 id="when-does-a-regular-program-need-to-use-a-scheme"><a class="header" href="#when-does-a-regular-program-need-to-use-a-scheme">When does a regular program need to use a scheme?</a></h3>
<p>Most schemes are used internally by system components or relibc, you don't need to access them directly. One exception is the pseudoterminal for your command window, which is accessed using the value of <code>$TTY</code>, which might have a value of e.g. <code>pty:18</code>. Some low-level graphics programming might require you to access your display, which might have a value of e.g. <code>display:3</code></p>
<h3 id="when-would-i-write-a-program-to-implement-a-scheme"><a class="header" href="#when-would-i-write-a-program-to-implement-a-scheme">When would I write a program to implement a scheme?</a></h3>
<p>If you are implementing a kernel service, userspace service or a device driver.</p>
<h3 id="how-do-i-use-a-scheme-for-sandboxing-a-program"><a class="header" href="#how-do-i-use-a-scheme-for-sandboxing-a-program">How do I use a scheme for sandboxing a program?</a></h3>
<p>The <a href="https://gitlab.redox-os.org/redox-os/contain">contain</a> program provides a partial implementation of sandboxing using schemes and namespaces.</p>
<h3 id="how-can-i-see-all-userspace-schemes"><a class="header" href="#how-can-i-see-all-userspace-schemes">How can I see all userspace schemes?</a></h3>
<p>Read the <a href="./schemes.html#userspace-schemes">Userspace Schemes</a> section.</p>
<h3 id="how-can-i-see-all-kernel-schemes"><a class="header" href="#how-can-i-see-all-kernel-schemes">How can I see all kernel schemes?</a></h3>
<p>Read the <a href="./schemes.html#kernel-schemes">Kernel Schemes</a> section.</p>
<h3 id="what-is-the-difference-between-kernel-and-userspace-schemes"><a class="header" href="#what-is-the-difference-between-kernel-and-userspace-schemes">What is the difference between kernel and userspace schemes?</a></h3>
<p>Read the <a href="./schemes.html#kernel-vs-userspace-schemes">Kernel vs Userspace Schemes</a> section.</p>
<h3 id="how-does-a-userspace-daemon-provide-file-like-services"><a class="header" href="#how-does-a-userspace-daemon-provide-file-like-services">How does a userspace daemon provide file-like services?</a></h3>
<p>When a regular program calls <code>open</code>, <code>read</code>, <code>write</code>, etc. on a file-like resource, the kernel translates that to a message of type <code>syscall::data::Packet</code>, describing the file operation, and makes it available for reading on the appropriate daemon's scheme file descriptor. See the <a href="./scheme-operation.html#providing-a-scheme">Providing A Scheme</a> section for more information.</p>
<h3 id="how-the-system-calls-are-used-by-userspace-daemons"><a class="header" href="#how-the-system-calls-are-used-by-userspace-daemons">How the system calls are used by userspace daemons?</a></h3>
<p>All userspace daemons use the system calls through <a href="https://gitlab.redox-os.org/redox-os/relibc">relibc</a> like any normal program.</p>
<h2 id="gitlab-questions"><a class="header" href="#gitlab-questions">GitLab Questions</a></h2>
<h3 id="how-to-properly-request-a-review-or-review-mrs"><a class="header" href="#how-to-properly-request-a-review-or-review-mrs">How to properly request a review or review MRs?</a></h3>
<p>These rules prevent you from wasting time and stress.</p>
<ul>
<li><strong>Don't edit your code suggestions without a warning before to prevent merge errors and review disorganization</strong></li>
<li>If you are requesting a review it's recommended that it's done by one reviewer per time to avoid extra coordination effort with multiple reviewers to confirm when each reviewer finished their review, but if you accept multiple reviewers at once <strong>each reviewer should warn when started and finished its review to prevent code suggestion conflicts between reviewers due to possible different file states while you apply the code suggestions</strong></li>
<li>If you are requesting a review where code suggestions will not be used, you can accept multiple reviewers without coordination of when they started and finished their reviews</li>
<li>Once you finish your review warn to avoid conflicts with other reviewers</li>
<li>It's recommended to use code suggestions for normal text and code to help and save time for developers, that way they can quickly improve or apply the text or code.</li>
</ul>
<p>You can start a code suggestion by clicking on the file icon with the + symbol when you click to comment in some line of a file.</p>
<h3 id="i-have-a-merge-request-with-many-commits-should-i-squash-them-after-merge"><a class="header" href="#i-have-a-merge-request-with-many-commits-should-i-squash-them-after-merge">I have a merge request with many commits, should I squash them after merge?</a></h3>
<p>If they don't have relevant informaiton on titles, yes.</p>
<h3 id="should-i-delete-my-branch-after-merge"><a class="header" href="#should-i-delete-my-branch-after-merge">Should I delete my branch after merge?</a></h3>
<p>Yes.</p>
<h3 id="how-can-i-have-an-anonymous-account"><a class="header" href="#how-can-i-have-an-anonymous-account">How can I have an anonymous account?</a></h3>
<p>During the account creation process you can add a fake name on the "First Name" and "Last Name" fields and change it later after your account approval (single name field is supported).</p>
<p>Read the <a href="./coding-and-building.html#anonymous-commits">Anonymous Commits</a> section if you need more anonymity.</p>
<h2 id="documentation-questions"><a class="header" href="#documentation-questions">Documentation Questions</a></h2>
<h3 id="how-can-i-write-code-documentation-properly"><a class="header" href="#how-can-i-write-code-documentation-properly">How can I write code documentation properly?</a></h3>
<p>Read the following pages:</p>
<ul>
<li><a href="./literate-programming.html">Literate programming</a></li>
<li><a href="./writing-docs-correctly.html">Writting Documentation Correctly</a></li>
</ul>
<h3 id="how-can-i-write-book-documentation-properly"><a class="header" href="#how-can-i-write-book-documentation-properly">How can I write book documentation properly?</a></h3>
<p><strong>Read the entire book before writing new documentation and submiting MRs to avoid information duplication</strong></p>
<ul>
<li>Only add work-in-progress information if really necessary, as it may unnecessarily increases maintenance cost</li>
<li>Don't use informal grammar abbreviations such as "config" (except technical terms such as "CPU")</li>
<li>Use spaces instead of tabs to avoid formatting breakage with different text editor tab configurations</li>
<li>Use <a href="https://en.wikipedia.org/wiki/Serial_comma">Oxford commas</a></li>
<li>The documentation grammar is not strictly formal to allow better understanding and readability, the grammar is a mix of American, British and International English</li>
</ul>
<h3 id="how-can-i-insert-commands-or-code-correctly"><a class="header" href="#how-can-i-insert-commands-or-code-correctly">How can I insert commands or code correctly?</a></h3>
<p>Commands or code should be inserted inside Markdown code blocks (using 3 backticks above and below the line of the command), for example:</p>
<pre><code>your-command-or-code
</code></pre>
<ul>
<li>Multiple commands should use an unique code block for each command to allow them to be copied with one cursor click</li>
<li>If you can't use a code block due to incompatible wording in the explanation, you can use the simple code highlighting using 1 backtick before and after the command on the same line</li>
</ul>
<h3 id="how-can-i-create-diagrams"><a class="header" href="#how-can-i-create-diagrams">How can I create diagrams?</a></h3>
<p>For diagrams to this book read <a href="https://gohugo.io/content-management/diagrams/">this</a> article.</p>
<p>For diagrams to the GitLab web interface the GitLab Markdown has support for some diagram syntaxes, read <a href="https://docs.gitlab.com/user/markdown/#diagrams-and-flowcharts">this</a> article to learn how to use them.</p>
<h2 id="troubleshooting-questions"><a class="header" href="#troubleshooting-questions">Troubleshooting Questions</a></h2>
<h3 id="scripts-1"><a class="header" href="#scripts-1">Scripts</a></h3>
<h4 id="i-cant-download-the-build-system-bootstrap-scripts-how-can-i-fix-this"><a class="header" href="#i-cant-download-the-build-system-bootstrap-scripts-how-can-i-fix-this">I can't download the build system bootstrap scripts, how can I fix this?</a></h4>
<p>Verify if you have <code>curl</code> installed or download the script from your web browser.</p>
<h4 id="i-tried-to-run-the-podman_bootstrapsh-and-native_bootstrapsh-scripts-but-got-an-error-how-to-fix-this"><a class="header" href="#i-tried-to-run-the-podman_bootstrapsh-and-native_bootstrapsh-scripts-but-got-an-error-how-to-fix-this">I tried to run the "podman_bootstrap.sh" and "native_bootstrap.sh" scripts but got an error, how to fix this?</a></h4>
<ul>
<li>Verify if you have the GNU Bash shell installed on your system.</li>
<li>Verify if Podman is supported on your operating system.</li>
<li>Verify if your operating system is <a href="./building-redox.html#supported-unix-like-distributions-and-podman-build">supported</a> on the <code>native_bootstrap.sh</code> script</li>
</ul>
<h3 id="build-system-2"><a class="header" href="#build-system-2">Build System</a></h3>
<h4 id="i-ran-make-all-but-it-show-a-rustup-cant-be-found-message-how-can-i-fix-this"><a class="header" href="#i-ran-make-all-but-it-show-a-rustup-cant-be-found-message-how-can-i-fix-this">I ran "make all" but it show a "rustup can't be found" message, how can I fix this?</a></h4>
<p>Run the following command:</p>
<pre><code class="language-sh">source ~/.cargo/env
</code></pre>
<p>(If you installed rustup before the first <code>podman_bootstrap.sh</code> or <code>native_bootstrap.sh</code> execution, this error doesn't happen)</p>
<h4 id="i-tried-all-troubleshooting-methods-but-my-build-system-is-still-broken-how-can-i-fix-that"><a class="header" href="#i-tried-all-troubleshooting-methods-but-my-build-system-is-still-broken-how-can-i-fix-that">I tried all troubleshooting methods but my build system is still broken, how can I fix that?</a></h4>
<p>If the <code>make clean pull container_clean all</code> command doesn't work download a new build system copy or wait for an upstream fix.</p>
<h3 id="recipes-3"><a class="header" href="#recipes-3">Recipes</a></h3>
<h4 id="i-had-an-error-with-a-recipe-how-can-i-fix-that"><a class="header" href="#i-had-an-error-with-a-recipe-how-can-i-fix-that">I had an error with a recipe, how can I fix that?</a></h4>
<p>Read the <a href="./troubleshooting.html#solving-compilation-problems">Solving Compilation Problems</a> section.</p>
<h4 id="i-tried-all-methods-of-the-troubleshooting-the-build-page-and-my-recipe-still-doesnt-build-what-it-can-be"><a class="header" href="#i-tried-all-methods-of-the-troubleshooting-the-build-page-and-my-recipe-still-doesnt-build-what-it-can-be">I tried all methods of the "Troubleshooting the Build" page and my recipe still doesn't build, what it can be?</a></h4>
<ul>
<li>Missing dependencies</li>
<li>Environment leakage: when some part of the recipe build system does native Linux compilation instead of cross-compilation to Redox</li>
<li>Misconfigured cross-compilation</li>
<li>The recipe needs to be ported to Redox</li>
</ul>
<h4 id="when-i-run-make-rrecipe-i-get-a-syntax-error-how-can-i-fix-that"><a class="header" href="#when-i-run-make-rrecipe-i-get-a-syntax-error-how-can-i-fix-that">When I run "make r.recipe" I get a syntax error, how can I fix that?</a></h4>
<p>Verify if your <code>recipe.toml</code> file has some typo, missing data type or value.</p>
<h4 id="when-i-run-cargo-update-on-some-recipe-source-it-call-rustup-to-install-other-rust-toolchain-version-how-can-i-fix-that"><a class="header" href="#when-i-run-cargo-update-on-some-recipe-source-it-call-rustup-to-install-other-rust-toolchain-version-how-can-i-fix-that">When I run "cargo update" on some recipe source it call rustup to install other Rust toolchain version, how can I fix that?</a></h4>
<p>It happens because Cargo is not using the Redox fork of the Rust compiler, to fix that run <code>make env</code> from the Redox build system root.</p>
<p>It will import the Redox Makefile environment variables to your active shell (it already does that when you run other <code>make</code> commands from the Redox build system root).</p>
<h4 id="i-added-the-dependency-of-my-program-in-the-recipetoml-file-but-the-program-build-system-doesnt-detect-it-then-i-installed-the-program-dependency-on-my-linux-distribution-and-it-detected-why"><a class="header" href="#i-added-the-dependency-of-my-program-in-the-recipetoml-file-but-the-program-build-system-doesnt-detect-it-then-i-installed-the-program-dependency-on-my-linux-distribution-and-it-detected-why">I added the dependency of my program in the "recipe.toml" file but the program build system doesn't detect it, then I installed the program dependency on my Linux distribution and it detected, why?</a></h4>
<p>Read the <a href="./troubleshooting.html#environment-leakage">Environment Leakage</a> section.</p>
<h4 id="i-made-changes-to-system-daemons-drivers-and-redoxfs-but-they-arent-applied-in-the-redox-image-how-can-i-fix-that"><a class="header" href="#i-made-changes-to-system-daemons-drivers-and-redoxfs-but-they-arent-applied-in-the-redox-image-how-can-i-fix-that">I made changes to system daemons, drivers and RedoxFS but they aren't applied in the Redox image, how can I fix that?</a></h4>
<p>You forgot to update initfs which is manual, read <a href="./coding-and-building.html#how-to-update-initfs">this</a> section to learn how to do this.</p>
<h3 id="qemu-2"><a class="header" href="#qemu-2">QEMU</a></h3>
<h4 id="how-can-i-kill-the-qemu-process-if-redox-freezes-or-get-a-kernel-panic"><a class="header" href="#how-can-i-kill-the-qemu-process-if-redox-freezes-or-get-a-kernel-panic">How can I kill the QEMU process if Redox freezes or get a kernel panic?</a></h4>
<p>Read the <a href="./troubleshooting.html#kill-a-frozen-redox-vm">Kill A Frozen Redox VM</a> section.</p>
<h3 id="real-hardware-2"><a class="header" href="#real-hardware-2">Real Hardware</a></h3>
<h4 id="i-got-a-kernel-panic-what-can-i-do"><a class="header" href="#i-got-a-kernel-panic-what-can-i-do">I got a kernel panic, what can I do?</a></h4>
<p>Read the <a href="./troubleshooting.html#kernel-panic">Kernel Panic</a> section.</p>
<h4 id="some-driver-is-not-working-with-my-hardware-what-can-i-do"><a class="header" href="#some-driver-is-not-working-with-my-hardware-what-can-i-do">Some driver is not working with my hardware, what can I do?</a></h4>
<p>Read the <a href="./troubleshooting.html#debug-methods">Debug Methods</a> section and ask us for instructions in the <a href="./chat.html">Matrix chat</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="references"><a class="header" href="#references">References</a></h1>
<p>This page contain a list of references for Rust programming, OS development, ideas, porting and computer science to help developers.</p>
<p>The sections are ordered by knowledge importance.</p>
<h3 id="è¨ˆç®—æ©Ÿç§‘å­¸"><a class="header" href="#è¨ˆç®—æ©Ÿç§‘å­¸">è¨ˆç®—æ©Ÿç§‘å­¸</a></h3>
<ul>
<li><a href="https://cpu.land/">Putting the "You" in CPU</a> - This website explains how a program works, from a Linux system call until the CPU.</li>
<li><a href="https://www.geeksforgeeks.org/">GeeksforGeeks</a> - A computer science portal with many articles for several areas and tasks.</li>
<li><a href="https://github.com/ossu/computer-science">computer-science</a> - A list for computer science education.</li>
<li><a href="https://www.youtube.com/watch?v=8mAITcNt710">freeCodeCamp: Harvard CS50</a></li>
<li><a href="https://roadmap.sh/computer-science">Developer Roadmaps - Computer Science</a> - A guide to learn computer science.</li>
<li><a href="https://minix3.org/">Minix</a> - You can find great papers and articles about the microkernel architecture and reliable systems.</li>
<li><a href="https://plan9.io/plan9/">Plan 9</a> - You can find papers and documentation about distributed systems.</li>
<li><a href="https://sel4.systems/">seL4</a> - You can find papers and documentation about a secure and fast microkernel design.</li>
<li><a href="https://www.thecodedmessage.com/tags/computers">The Coded Message - Computing/Programming articles</a></li>
</ul>
<h3 id="ä½œæ¥­ç³»çµ±é–‹ç™¼"><a class="header" href="#ä½œæ¥­ç³»çµ±é–‹ç™¼">ä½œæ¥­ç³»çµ±é–‹ç™¼</a></h3>
<ul>
<li><a href="https://wiki.osdev.org/Expanded_Main_Page">OSDev Wiki</a> - The best wiki about OS development of the world.</li>
<li><a href="https://os.phil-opp.com/">Writing an OS in Rust</a> - Blog series to write an operating system in Rust.</li>
<li><a href="https://rust-osdev.com/">Rust OSDev</a> - Monthly reports with updates on the Rust low-level ecosystem libraries and operating systems.</li>
</ul>
<h3 id="rust-1"><a class="header" href="#rust-1">Rust</a></h3>
<ul>
<li><a href="https://doc.rust-lang.org/stable/book/">Rust Book</a> - The most important source of information on the Rust programming language.</li>
<li><a href="https://doc.rust-lang.org/stable/rust-by-example/">Rust By Example</a> - Learn Rust with examples.</li>
<li><a href="https://github.com/rust-lang/rustlings">Rustlings</a> - Learn Rust with exercises.</li>
<li><a href="https://github.com/rust-unofficial/awesome-rust">Awesome Rust</a> - Curated list of Rust programs, libraries and resources.</li>
<li><a href="https://www.youtube.com/playlist?list=PLZaoyhMXgBzoM9bfb5pyUOT3zjnaDdSEP">No Boilerplate - Rust playlist</a> - Amazing short documentaries about special things on Rust.</li>
<li><a href="https://roadmap.sh/rust">Developer Roadmaps - Rust</a> - A guide to learn Rust.</li>
<li><a href="https://github.com/ctjhoa/rust-learning">rust-learning</a> - A list with articles and videos to learn Rust.</li>
<li><a href="https://play.rust-lang.org/">Rust Playground</a> - Test your Rust code on the web browser.</li>
<li><a href="https://this-week-in-rust.org/">This Week in Rust</a> - Weekly updates on the Rust ecosystem, it covers language improvements, organization updates, community updates and articles.</li>
<li><a href="https://www.thecodedmessage.com/tags/rust/">The Coded Message - Rust articles</a></li>
<li><a href="https://fasterthanli.me/tags/rust">fasterthanlime - Rust articles</a></li>
<li><a href="https://rust-unofficial.github.io/too-many-lists/">Learn Rust With Entirely Too Many Linked Lists</a> - How to implement a linked list in Rust.</li>
<li><a href="https://rust-unofficial.github.io/patterns/intro.html">Rust Design Patterns</a> - About idioms, design patterns, and anti-pattern in Rust.</li>
<li><a href="https://doc.rust-lang.org/reference/index.html">Rust Reference Book</a> - References for people with background familiarity with Rust.</li>
<li><a href="https://doc.rust-lang.org/nomicon/">Rustonomicon</a> - To learn about unsafe Rust.</li>
<li><a href="https://101-rs.tweede.golf/">Rust 101 - Exercises</a> - A Rust university course (but lacking answers for exercises).</li>
<li><a href="https://teach-rs.tweede.golf/">teach-rs</a> - An university course to learn Rust.</li>
<li><a href="https://yevh.github.io/rust-security-handbook/">Rust Security Handbook</a> - Helpful security related practices when coding in Rust.</li>
</ul>
<h3 id="porting-1"><a class="header" href="#porting-1">Porting</a></h3>
<p>If you don't know how to port some program or library, you can see the build system documentation or software ports of other operating systems.</p>
<ul>
<li><a href="https://doc.rust-lang.org/cargo/">Cargo</a> - The project and dependency manager of the Rust programming language.</li>
<li><a href="https://www.gnu.org/software/automake/">GNU Autotools</a> - The GNU build system, used by most old POSIX programs.</li>
<li><a href="https://mesonbuild.com/">Meson</a> - A build system used by many Linux/POSIX programs.</li>
<li><a href="https://www.gnu.org/software/make/">GNU Make</a> - The GNU's command runner, used to build projects with many source code files.</li>
<li><a href="https://cgit.freebsd.org/ports/">FreeBSD - Software Ports (cgit)</a> - The official web interface for the software ports of FreeBSD.</li>
<li><a href="https://github.com/freebsd/freebsd-ports">FreeBSD - Software Ports (GitHub mirror)</a> - GitHub mirror for the software ports of FreeBSD.</li>
<li><a href="https://github.com/NetBSD/pkgsrc">NetBSD - Software Ports (GitHub mirror)</a> - GitHub mirror for the software ports of NetBSD.</li>
<li><a href="https://packages.gentoo.org/">Gentoo Packages</a> - It contains advanced information about the port configuration.</li>
<li><a href="https://github.com/NixOS/nixpkgs">Nix Packages</a></li>
<li><a href="https://git.savannah.gnu.org/cgit/guix.git">Guix Packages</a></li>
</ul>
<h3 id="manual-pages"><a class="header" href="#manual-pages">Manual Pages</a></h3>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Man_page#Manual_sections">Unix Manual Sections</a></li>
<li><a href="https://man.freebsd.org/cgi/man.cgi">FreeBSD Manual Pages</a> - Powerful source for Unix/BSD documentation.</li>
<li><a href="https://www.man7.org/linux/man-pages/">Linux Manual Pages (man7)</a> - Very popular source for Linux documentation.</li>
<li><a href="https://linux.die.net/man/">Linux Manual Pages (die.net)</a> - Another popular source for Linux documentation.</li>
<li><a href="https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/contents.html">OpenGroup Specification (POSIX and C Standard Library)</a> - This is important to improve the support for Linux/BSD programs written in C/C++.</li>
<li><a href="https://en.wikipedia.org/wiki/Errno.h#POSIX_errors">POSIX errors</a></li>
<li><a href="https://en.wikipedia.org/wiki/Filesystem_Hierarchy_Standard#Directory_structure">Linux FHS Directory Structure</a></li>
</ul>
<h3 id="source-code"><a class="header" href="#source-code">Source Code</a></h3>
<p>If you want to implement something (drivers, hardware interfaces, fix bugs, etc) but the documentation is not good or not available, you can verify the implementation of other operating systems.</p>
<ul>
<li><a href="https://git.kernel.org/">Linux - cgit</a> - Official web interface for the Linux kernel source code.</li>
<li><a href="https://github.com/torvalds/linux">Linux - GitHub mirror</a> - GitHub mirror for the Linux kernel source code, it contain more features to read the files.</li>
<li><a href="https://cgit.freebsd.org/">FreeBSD - cgit</a> - Official web interface for the FreeBSD source code.</li>
<li><a href="https://github.com/freebsd/freebsd-src">FreeBSD - GitHub mirror</a></li>
<li><a href="http://cvsweb.netbsd.org/">NetBSD - CVSWeb</a> - Official web interface for the NetBSD source code.</li>
<li><a href="https://github.com/NetBSD/src">NetBSD - GitHub mirror</a></li>
<li><a href="https://cvsweb.openbsd.org/">OpenBSD - CVSWeb</a> - Official web interface for the OpenBSD source code.</li>
<li><a href="https://github.com/openbsd/src">OpenBSD - GitHub mirror</a></li>
<li><a href="https://git.minix3.org/index.cgi?p=minix.git">Minix</a> - Official web interface for the Minix source code.</li>
<li><a href="https://github.com/seL4/seL4">seL4</a></li>
</ul>
<h3 id="ideas"><a class="header" href="#ideas">Ideas</a></h3>
<ul>
<li><a href="https://www.kernel.org/">Linux</a> - The Linux kernel contain lots of ideas that improved the Unix design (POSIX) and system engineering.</li>
<li><a href="https://developer.android.com/">Android</a> - Android created many ideas to improve the system security and power efficiency.</li>
<li><a href="https://wiki.freebsd.org/IdeasPage">FreeBSD - Ideas</a> - The future ideas of FreeBSD.</li>
<li><a href="https://docs.freebsd.org/en/">FreeBSD - Documentation</a></li>
<li><a href="https://fedoraproject.org/wiki/Changes">Fedora - Change Proposals</a> - For years the Fedora Linux distribution tested and implemented new technologies for the Linux ecosystem.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="libraries-and-apis"><a class="header" href="#libraries-and-apis">Libraries and APIs</a></h1>
<p>This page covers the context of the libraries and APIs on Redox.</p>
<ul>
<li><a href="libraries-apis.html#versions">Versions</a>
<ul>
<li><a href="libraries-apis.html#redox">Redox</a></li>
<li><a href="libraries-apis.html#providing-a-stable-abi">Providing a Stable ABI</a></li>
</ul>
</li>
<li><a href="libraries-apis.html#interfaces">Interfaces</a>
<ul>
<li><a href="libraries-apis.html#relibc">relibc</a></li>
<li><a href="libraries-apis.html#libredox">libredox</a></li>
<li><a href="libraries-apis.html#redox_syscall">redox_syscall</a></li>
</ul>
</li>
<li><a href="libraries-apis.html#crates">Crates</a></li>
<li><a href="libraries-apis.html#code-porting">Code Porting</a>
<ul>
<li><a href="libraries-apis.html#rust-std-crate">Rust std crate</a></li>
</ul>
</li>
<li><a href="libraries-apis.html#compiling-for-redox">Compiling for Redox</a>
<ul>
<li><a href="libraries-apis.html#porting-method">Porting Method</a></li>
</ul>
</li>
</ul>
<h2 id="terms"><a class="header" href="#terms">Terms</a></h2>
<div class="table-wrapper"><table><thead><tr><th><strong>Interface</strong></th><th><strong>Explanation</strong></th></tr></thead><tbody>
<tr><td><a href="https://en.wikipedia.org/wiki/API">API</a></td><td>The interface of the library <strong>source code</strong> (the programs use the API to obtain the library functions)</td></tr>
<tr><td><a href="https://en.wikipedia.org/wiki/Application_binary_interface">ABI</a></td><td>The interface of the program <strong>binary</strong> and system services (normally the system call interface)</td></tr>
</tbody></table>
</div>
<h2 id="versions"><a class="header" href="#versions">Versions</a></h2>
<p>The Redox crates follow the SemVer model from Cargo for version numbers (except <code>redox_syscall</code>), you can read more about it below:</p>
<ul>
<li><a href="https://semver.org/">SemVer</a></li>
<li><a href="https://doc.rust-lang.org/cargo/reference/resolver.html">Cargo SemVer</a></li>
<li><a href="https://doc.rust-lang.org/cargo/reference/semver.html">Cargo SemVer compatibility</a></li>
</ul>
<h3 id="redox"><a class="header" href="#redox">Redox</a></h3>
<p>This section covers the versioning system of Redox and important components.</p>
<ul>
<li>Redox OS: <code>x.y.z</code></li>
</ul>
<p><code>x</code> is ABI version, <code>y</code> is API updates with backward compatibility and <code>z</code> is fixes with backward compatiblity.</p>
<ul>
<li>
<p>libredox: Currently it don't follow the SemVer model but will in the future</p>
</li>
<li>
<p>redox_syscall: <code>x.y.z</code></p>
</li>
</ul>
<p><code>x</code> is the ABI version (it will remain 0 for a while), <code>y</code> is the API updates and <code>z</code> is fixes (no backward compatibility).</p>
<h3 id="providing-a-stable-abi"><a class="header" href="#providing-a-stable-abi">Providing a Stable ABI</a></h3>
<p>The implementation of a stable ABI is important to avoid frequent recompilation when an operating system is under heavy development, thus improving the development speed.</p>
<p>A stable ABI typically <strong>reduces</strong> development speed for the ABI <strong>provider</strong> (because it needs to uphold backward compatibility), whereas it <strong>improves</strong> development speed for the ABI <strong>user</strong>. Because relibc will be smaller than the rest of Redox, this is a good tradeoff, and improves development speed in general</p>
<p>It also offer backward compatibility for binaries compiled with old API versions.</p>
<p>Currently only libredox will have a stable ABI, relibc will be unstable only as long as it's under heavy development and redox_syscall will remain unstable even after the 1.0 version of Redox.</p>
<p>Our final goal is to keep the Redox ABI stable in all <code>1.x</code> versions, if an ABI break happens, the next versions will be <code>2.x</code></p>
<p>A program compiled with an old API <strong>version</strong> will continue to work with a new API version, in most cases statically linked library updates or program updates will require recompilation, while in others a new ABI version will add performance and security improvements that would recommend a recompilation of the program.</p>
<p>If the dynamic linker can't resolve the references of the program binary, a recompilation is required.</p>
<h2 id="interfaces"><a class="header" href="#interfaces">Interfaces</a></h2>
<p>Redox uses different mechanisms, compared to Linux, to implement system capabilities.</p>
<h3 id="relibc"><a class="header" href="#relibc">relibc</a></h3>
<p><a href="https://gitlab.redox-os.org/redox-os/relibc">relibc</a> is an implementation of the <a href="https://en.wikipedia.org/wiki/C_standard_library">C Standard Library</a> (libc) and POSIX in Rust.</p>
<p>relibc knows if it's compiled for Linux or Redox ahead-of-time (if the target is Redox relibc calls functions in libredox), the goal is to organize platform-specific functionality into clean modules.</p>
<p>Since Redox and Linux executables look so similar and can accidentally be executed on the other platform, it checks that it's running on the same platform it was compiled for, at runtime.</p>
<h3 id="libredox"><a class="header" href="#libredox">libredox</a></h3>
<p><a href="https://gitlab.redox-os.org/redox-os/libredox">libredox</a> is a system library for Redox components and Rust programs/libraries, it will allow Rust programs to limit their need to use C-style APIs (the relibc API and ABI).</p>
<p>It's both a crate (calling the ABI functions) and an ABI, the ABI is provided from relibc while the crate (library) is a wrapper above the libredox ABI.</p>
<p>(Redox components, Rust programs and libraries use this library)</p>
<p>You can see Rust crates using it on the <a href="https://crates.io/crates/libredox/reverse_dependencies">Reverse Dependencies</a> category.</p>
<h3 id="redox_syscall"><a class="header" href="#redox_syscall">redox_syscall</a></h3>
<p><a href="https://gitlab.redox-os.org/redox-os/syscall">redox_syscall</a> contain the system call numbers and Rust API wrappers for the inline Assembly code of system calls to be used with low-level components and libraries.</p>
<p>(redox_syscall should not be used directly by programs, use libredox instead)</p>
<h2 id="crates-1"><a class="header" href="#crates-1">Crates</a></h2>
<p>Some Redox projects have crates on <code>crates.io</code> thus they use a version-based SemVer development, if some change is sent to their repository they need to release a new version on <code>crates.io</code></p>
<ul>
<li><a href="https://crates.io/crates/libredox">libredox</a></li>
<li><a href="https://crates.io/crates/redox_syscall">redox_syscall</a></li>
<li><a href="https://crates.io/crates/redox-path">redox-path</a></li>
<li><a href="https://crates.io/crates/redox-scheme">redox-scheme</a></li>
<li><a href="https://crates.io/crates/redoxfs">redoxfs</a></li>
<li><a href="https://crates.io/crates/redoxer">redoxer</a></li>
<li><a href="https://crates.io/crates/redox_installer">redox_installer</a></li>
<li><a href="https://crates.io/crates/redox-kprofiling">redox-kprofiling</a></li>
<li><a href="https://crates.io/crates/redox_users">redox-users</a></li>
<li><a href="https://crates.io/crates/redox-buffer-pool">redox-buffer-pool</a></li>
<li><a href="https://crates.io/crates/redox-log">redox_log</a></li>
<li><a href="https://crates.io/crates/redox_termios">redox_termios</a></li>
<li><a href="https://crates.io/crates/redox-daemon">redox-daemon</a></li>
<li><a href="https://crates.io/crates/redox_event">redox_event</a></li>
<li><a href="https://crates.io/crates/redox_event_update">redox_event_update</a></li>
<li><a href="https://crates.io/crates/redox_pkgutils">redox_pkgutils</a></li>
<li><a href="https://crates.io/crates/redox_uefi">redox_uefi</a></li>
<li><a href="https://crates.io/crates/redox_uefi_alloc">redox_uefi_alloc</a></li>
<li><a href="https://crates.io/crates/redox_dmi">redox_dmi</a></li>
<li><a href="https://crates.io/crates/redox_hwio">redox_hwio</a></li>
<li><a href="https://crates.io/crates/redox_intelflash">redox_intelflash</a></li>
<li><a href="https://crates.io/crates/redox_liner">redox_liner</a></li>
<li><a href="https://crates.io/crates/redox_uefi_std">redox_uefi_std</a></li>
<li><a href="https://crates.io/crates/ralloc">ralloc</a></li>
<li><a href="https://crates.io/crates/orbclient">orbclient</a></li>
<li><a href="https://crates.io/crates/orbclient_window_shortcuts">orbclient_window_shortcuts</a></li>
<li><a href="https://crates.io/crates/orbfont">orbfont</a></li>
<li><a href="https://crates.io/crates/orbimage">orbimage</a></li>
<li><a href="https://crates.io/crates/orbterm">orbterm</a></li>
<li><a href="https://crates.io/crates/orbutils">orbutils</a></li>
<li><a href="https://crates.io/crates/slint_orbclient">slint_orbclient</a></li>
<li><a href="https://crates.io/crates/ralloc_shim">ralloc_shim</a></li>
<li><a href="https://crates.io/crates/ransid">ransid</a></li>
<li><a href="https://crates.io/crates/gitrepoman">gitrepoman</a></li>
<li><a href="https://crates.io/crates/pkgar">pkgar</a></li>
<li><a href="https://crates.io/crates/pkgar-core">pkgar-core</a></li>
<li><a href="https://crates.io/crates/pkgar-repo">pkgar-repo</a></li>
<li><a href="https://crates.io/crates/termion">termion</a></li>
<li><a href="https://crates.io/crates/reagent">reagent</a></li>
<li><a href="https://crates.io/crates/gdb-protocol">gdb-protocol</a></li>
<li><a href="https://crates.io/crates/orbtk">orbtk</a></li>
<li><a href="https://crates.io/crates/orbtk_orbclient">orbtk_orbclient</a></li>
<li><a href="https://crates.io/crates/orbtk-render">orbtk-render</a></li>
<li><a href="https://crates.io/crates/orbtk-shell">orbtk-shell</a></li>
<li><a href="https://crates.io/crates/orbtk-tinyskia">orbtk-tinyskia</a></li>
</ul>
<h3 id="manual-patching"><a class="header" href="#manual-patching">Manual Patching</a></h3>
<p>If you don't want to wait a new release on <code>crates.io</code>, you can patch the crate temporarily by fetching the version you need from GitLab and changing the crate version in <code>Cargo.toml</code> to <code>crate-name = { path = "path/to/crate" }</code></p>
<h2 id="code-porting"><a class="header" href="#code-porting">Code Porting</a></h2>
<h3 id="rust-std-crate"><a class="header" href="#rust-std-crate">Rust std crate</a></h3>
<p>Most <strong>Rust</strong> programs include the <a href="https://doc.rust-lang.org/std/">std</a> (libstd) crate, In addition to implementing standard Rust abstractions, this crate provides a safe Rust interface to system functionality in libc, which it invokes via a <a href="https://doc.rust-lang.org/rust-by-example/std_misc/ffi.html">FFI</a> to libc.</p>
<p><code>std</code> has mechanisms to enable operating system variants of certain parts of the library, the file <a href="https://github.com/rust-lang/rust/blob/master/library/std/src/sys/mod.rs">sys/mod.rs</a> selects the appropriate variant to include, programs use the <code>std::</code> prefix to call this crate.</p>
<p>To ensure portability of programs, Redox supports the Rust <code>std</code> crate, for Redox, <code>std::sys</code> refers to <code>std::sys::unix</code></p>
<p>Redox-specific code can be found on the <a href="https://github.com/rust-lang/rust/tree/master/library/std/src/os/redox">std source tree</a>.</p>
<p>For most functionality, Redox uses <code>#[cfg(unix)]</code> and <a href="https://github.com/rust-lang/rust/tree/master/library/std/src/sys/pal/unix">sys/unix</a>.</p>
<p>Some Redox-specific functionality is enabled by <code>#[cfg(target_os = "redox")]</code></p>
<h2 id="compiling-for-redox"><a class="header" href="#compiling-for-redox">Compiling for Redox</a></h2>
<p>The Redox toolchain automatically links programs with relibc in place of the libc you would find on Linux.</p>
<h3 id="porting-method"><a class="header" href="#porting-method">Porting Method</a></h3>
<p>You can use <code>#[cfg(unix)]</code> and <code>#[cfg(target_os = "redox")]</code> to guard platform specific code.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="coding-and-building"><a class="header" href="#coding-and-building">Coding and Building</a></h1>
<p>(Before reading this page you must read the <a href="./build-system-reference.html">Build System</a> page)</p>
<p>This page explain common development tasks on the Redox build system.</p>
<ul>
<li><a href="coding-and-building.html#visual-studio-code-configuration">Visual Studio Code Configuration</a></li>
<li><a href="coding-and-building.html#vs-code-tips-and-tricks">VS Code Tips and Tricks</a></li>
<li><a href="coding-and-building.html#working-with-git">Working with Git</a>
<ul>
<li><a href="coding-and-building.html#anonymous-commits">Anonymous commits</a></li>
</ul>
</li>
<li><a href="coding-and-building.html#using-multiple-windows">Using Multiple Windows</a></li>
<li><a href="coding-and-building.html#setup-your-configuration">Setup your Configuration</a></li>
<li><a href="coding-and-building.html#the-recipe">The Recipe</a></li>
<li><a href="coding-and-building.html#git-clone">Git Clone</a></li>
<li><a href="coding-and-building.html#edit-your-code">Edit your Code</a></li>
<li><a href="coding-and-building.html#verify-your-code-on-linux">Verify Your Code on Linux</a></li>
<li><a href="coding-and-building.html#update-the-redox-image">Update The Redox Image</a></li>
<li><a href="coding-and-building.html#test-your-changes">Test Your Changes</a>
<ul>
<li><a href="coding-and-building.html#test-your-changes-out-of-the-redox-build-system">Test Your Changes (out of the Redox build system)</a></li>
<li><a href="coding-and-building.html#testing-on-real-hardware">Testing On Real Hardware</a>
<ul>
<li><a href="coding-and-building.html#full-bootable-image-creation">Full bootable image creation</a></li>
<li><a href="coding-and-building.html#partial-bootable-image-creation">Partial bootable image creation</a></li>
<li><a href="coding-and-building.html#flash-the-bootable-image-on-your-usb-device">Flash the bootable image on your USB device</a></li>
<li><a href="coding-and-building.html#burn-your-cddvd-with-the-bootable-image">Burn your CD/DVD with the bootable image</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="coding-and-building.html#update-crates">Update crates</a></li>
<li><a href="coding-and-building.html#search-text-on-files">Search Text On Files</a></li>
<li><a href="coding-and-building.html#redox-image">Redox Image</a>
<ul>
<li><a href="coding-and-building.html#build-your-recipe-for-redox">Build Your Recipe for Redox</a></li>
<li><a href="coding-and-building.html#make-a-new-redox-image">Make A New Redox Image</a></li>
<li><a href="coding-and-building.html#most-quick-way-to-test-your-changes">Most Quick Way To Test Your Changes</a></li>
<li><a href="coding-and-building.html#insert-text-files-on-qemu-quickest-method">Insert Text Files On QEMU (quickest method)</a></li>
<li><a href="coding-and-building.html#insert-files-in-the-redox-image-using-a-recipe">Insert Files In The Redox image Using a Recipe</a></li>
<li><a href="coding-and-building.html#insert-files-in-the-qemu-image">Insert Files In The QEMU Image</a></li>
</ul>
</li>
<li><a href="coding-and-building.html#working-with-an-unpublished-version-of-a-crate">Working with an unpublished version of a crate</a></li>
<li><a href="coding-and-building.html#how-to-update-initfs">How to update initfs</a></li>
</ul>
<h2 id="visual-studio-code-configuration"><a class="header" href="#visual-studio-code-configuration">Visual Studio Code Configuration</a></h2>
<p>Before you start the VS Code IDE to do Redox development you need to run the following command on your terminal:</p>
<pre><code class="language-sh">rustup target add x86_64-unknown-redox
</code></pre>
<p>(If you aren't building Redox to x86_64 change <code>x86_64</code> in <code>x86_64-unknown-redox</code> to the CPU code that you are using)</p>
<p>If the code that you are working on includes directives like <code>#[cfg(target_os = "redox)]</code>, that code will be disabled by default. To enable live syntax and compiler warnings for that code, add the following line to your VS Code config file (<code>.vscode/settings.json</code>):</p>
<pre><code class="language-json">"rust-analyzer.cargo.target": "x86_64-unknown-redox"
</code></pre>
<p>If you are browsing a codebase that contains native dependencies (e.g. the kernel repository), you might get analyzer errors because of lacking GCC toolchain. To fix it, install <a href="https://gitlab.redox-os.org/redox-os/redoxer">Redoxer</a> and its toolchain <code>redoxer toolchain</code>, then add the GCC toolchain to your <code>PATH</code> configuration (e.g. in <code>~/.bashrc</code>):</p>
<pre><code class="language-sh">export PATH="$PATH:$HOME/.redoxer/toolchain/bin"
</code></pre>
<p>The Redoxer toolchain is added as the last item of the <code>PATH</code> environment variable list to make sure it's not replacing the Rust toolchain that you're using.</p>
<h2 id="vs-code-tips-and-tricks"><a class="header" href="#vs-code-tips-and-tricks">VS Code Tips and Tricks</a></h2>
<p>Although not for every Rust developer, <strong>VS Code</strong> is helpful for those who are working with unfamiliar code. We don't get the benefit of all its features, but the Rust support in VS Code is very good.</p>
<p>If you have not used VS Code with Rust, here's an <a href="https://code.visualstudio.com/docs/languages/rust">overview</a>. VS Code installation instructions are <a href="https://code.visualstudio.com/docs/setup/linux">here</a>.</p>
<p>After installing the <code>rust-analyzer</code> extension as described in the overview, you get access to several useful features:</p>
<ul>
<li>Inferred types and parameter names as inline hints</li>
<li>Peeking at definitions and references</li>
<li>Refactoring support</li>
<li>Autoformat and Clippy on Save (optional)</li>
<li>Visual Debugger (if your code can run on Linux)</li>
<li>Compare/Revert against the repository with the Git extension</li>
</ul>
<p>Using VS Code on recipes works pretty well, although it sometimes take a couple of minutes to kick in. Here are some things to know:</p>
<h3 id="start-in-the-source-folder"><a class="header" href="#start-in-the-source-folder">Start in the "source" folder</a></h3>
<p>In your "Coding" shell, start VS Code specifying the <code>source</code> directory:</p>
<pre><code class="language-sh">code ~/tryredox/redox/recipes/games/source
</code></pre>
<p>Or if you are in the <code>source</code> directory, just write <code>code .</code> with the period meaning the <code>source</code> directory.</p>
<h3 id="add-it-to-your-favorites-bar"><a class="header" href="#add-it-to-your-favorites-bar">Add it to your "Favorites" bar</a></h3>
<p>VS Code remembers the last project you used it on, so typing <code>code</code> with no directory or starting it from your Applications window or Favorites bar will go back to that project.</p>
<p>After starting VS Code, right click on the icon and select "Add to Favorites"</p>
<h3 id="wait-a-couple-of-minutes"><a class="header" href="#wait-a-couple-of-minutes">Wait a Couple of Minutes</a></h3>
<p>You can start working right away, but after a minute or two, you will notice extra text appear in your Rust code with inferred types and parameter names filled in. This additional text is just <em>hints</em>, and is not permanently added to your code.</p>
<h3 id="save-often"><a class="header" href="#save-often">Save Often</a></h3>
<p>If you have made significant changes <code>rust-analyzer</code> can get confused, but this can usually be fixed by clicking on "Save All"</p>
<h3 id="dont-use-for-the-whole-redox-build-system"><a class="header" href="#dont-use-for-the-whole-redox-build-system">Don't Use For The Whole Redox Build System</a></h3>
<p>VS Code cannot grok the gestalt of Redox, so it doesn't work very well if you start it in your <code>redox</code> base directory. It can be handy for editing recipes, configuration and GNU Make files. And if you want to see what you have changed in the Redox project, click on the "Source Control" icon on the left side, then select the file you want to compare against the repository.</p>
<h3 id="dont-build-the-system-in-a-vs-code-terminal"><a class="header" href="#dont-build-the-system-in-a-vs-code-terminal">Don't Build the System in a VS Code Terminal</a></h3>
<p>In general, it's not recommended to do a system build from within VS Code. Use your "Build" window. This gives you the flexibility to exit Code without terminating the build.</p>
<h2 id="working-with-git"><a class="header" href="#working-with-git">Working with Git</a></h2>
<p>Before starting the development, read the <a href="./creating-proper-pull-requests.html">Creating Proper Pull Requests</a> page, which describes how Redox developers uses Git.</p>
<p>In this example, we will discuss how to create a <strong>fork</strong> of the <code>games</code> recipe, pretending you are going to create a <code>Merge Request</code> for your changes. <strong>Don't actually do this</strong>. Only create a fork when you have changes that you want to send to Redox upstream.</p>
<h3 id="anonymous-commits"><a class="header" href="#anonymous-commits">Anonymous commits</a></h3>
<p>If you are new to Git it request your username and email before the first commit on some offline repository, if you don't want to insert your personal information, run:</p>
<ul>
<li>One repository</li>
</ul>
<p>The following commands will make you anonymous only on this repository.</p>
<pre><code class="language-sh">cd your-repository-folder
</code></pre>
<pre><code class="language-sh">git config user.name 'Anonymous'
</code></pre>
<pre><code class="language-sh">git config user.email '&lt;&gt;'
</code></pre>
<ul>
<li>Global</li>
</ul>
<p>The following commands will make you anonymous in any repository.</p>
<pre><code class="language-sh">git config --global user.name 'Anonymous'
</code></pre>
<pre><code class="language-sh">git config --global user.email '&lt;&gt;'
</code></pre>
<h2 id="using-multiple-windows"><a class="header" href="#using-multiple-windows">Using Multiple Windows</a></h2>
<p>For clarity and easy usage, we will be using two terminal tabs on the example below, each running a different GNU Bash shell instance.</p>
<ol>
<li>The "Build" shell, normally at <code>~/tryredox/redox</code> or where your base <code>redox</code> directory is.</li>
<li>The "Coding" shell, at <code>recipes/games/redox-games/source</code></li>
</ol>
<h2 id="setup-your-configuration"><a class="header" href="#setup-your-configuration">Setup Your Configuration</a></h2>
<p>To get started, follow the steps in the <a href="./including-programs.html">Including Programs in Redox</a> page to include the <code>games</code> package on your <code>my-config</code> configuration file. In your terminal window, go to your <code>redox</code> base directory and run:</p>
<pre><code class="language-sh">make qemu
</code></pre>
<p>On Redox, run <code>minesweeper</code> as described in the link above. Type the letter <code>f</code> and you will see <code>F</code> appear on your screen. Use <code>Ctrl-Alt-G</code> to regain control of your cursor, and click the upper right corner to exit QEMU.</p>
<p>Keep the terminal window open. That will be your "Build" shell.</p>
<h2 id="the-recipe"><a class="header" href="#the-recipe">The Recipe</a></h2>
<p>Let's walk through contributing to the recipe <code>redox-games</code>, which is a collection of terminal games. We are going to modify <code>minesweeper</code> to display <strong>P</strong> instead of <strong>F</strong> on flagged spots.</p>
<p>The <code>redox-games</code> recipe is built at: <code>recipes/games/redox-games</code>. When you download the <code>redox</code> repository it includes a file <code>recipes/games/redox-games/recipe.toml</code>. The recipe tells the build system how to get the source and build it.</p>
<p>When you build the system and include the <code>redox-games</code> recipe, the toolchain does a <code>git clone</code> into the directory: <code>recipes/games/redox-games/source</code>. Then it builds the recipe in the directory: <code>recipes/games/redox-games/target</code></p>
<p>Edit the recipe so it does not try to automatically download the sources.</p>
<ul>
<li>Create a <code>Terminal</code> window running <code>bash</code> on your system, which we will call your "Coding" shell</li>
<li>Change to the <code>redox-games</code> directory</li>
<li>Open the <code>recipe.toml</code> file in a text editor:</li>
</ul>
<pre><code class="language-sh">cd ~/tryredox/redox/recipes/games/redox-games
</code></pre>
<pre><code class="language-sh">nano recipe.toml
</code></pre>
<ul>
<li>Comment out the <code>[source]</code> section at the top of the file:</li>
</ul>
<pre><code># [source]
# git = "https://gitlab.redox-os.org/redox-os/games.git"
</code></pre>
<ul>
<li>Save your changes</li>
</ul>
<h2 id="git-clone"><a class="header" href="#git-clone">Git Clone</a></h2>
<p>To setup this recipe for contributing, do the following in your "Coding" shell.</p>
<ul>
<li>Delete the <code>source</code> and <code>target</code> directories in <code>recipes/games/redox-games</code></li>
<li>Clone the package into the <code>source</code> directory, either specifying it in the <code>git clone</code> or by moving it after <code>clone</code></li>
</ul>
<pre><code class="language-sh">rm -rf source target
</code></pre>
<pre><code class="language-sh">git clone https://gitlab.redox-os.org/redox-os/games.git --origin upstream
</code></pre>
<pre><code class="language-sh">mv games source
</code></pre>
<ul>
<li>
<p>If you are making a change that you want to contribute (if not <strong>don't actually do this</strong>), at this point you should follow the instructions in <a href="./creating-proper-pull-requests.html">Creating Proper Pull Requests</a>, replacing <code>redox.git</code> with <code>games.git</code>. Make sure you fork the correct repository, in this case <a href="https:/gitlab.redox-os.org/redox-os/games">redox-os/games</a>. Remember to create a new branch before you make any changes.</p>
</li>
<li>
<p>If you want to Git Clone a remote repository (main repository/your fork), you can add these sections on your <code>recipe.toml</code>:</p>
</li>
</ul>
<pre><code class="language-toml">[source]
git = "your-git-link"
branch = "your-branch" # optional
</code></pre>
<h2 id="edit-your-code"><a class="header" href="#edit-your-code">Edit Your Code</a></h2>
<ul>
<li>Using your favorite code editor, make your changes. We used GNU Nano in this example from your "Coding" shell. You can also use <a href="coding-and-building.html#vs-code-tips-and-tricks">VS Code</a>.</li>
</ul>
<pre><code class="language-sh">cd source
</code></pre>
<pre><code class="language-sh">nano src/minesweeper/main.rs
</code></pre>
<ul>
<li>Search for the line containing the definition of the <code>FLAGGED</code> constant (around line 36), and change it to <code>P</code></li>
</ul>
<pre><code>const FLAGGED: &amp;'static str = "P";
</code></pre>
<h2 id="verify-your-code-on-linux"><a class="header" href="#verify-your-code-on-linux">Verify Your Code on Linux</a></h2>
<p>Most Redox programs are source-compatible with Linux without being modified. You can (and should) build and test your program on Linux.</p>
<ul>
<li>From within the "Coding" shell go to the <code>source</code> directory and use the Linux version of <code>cargo</code> to check for errors:</li>
</ul>
<pre><code class="language-sh">cargo check
</code></pre>
<p>(Since much of the code in <code>redox-games</code> is older (pre-2018 Rust), you will get several warnings. They can be ignored)</p>
<p>You could also use <code>cargo clippy</code>, but <code>minesweeper</code> is not clean enough to pass.</p>
<ul>
<li>The <code>redox-games</code> recipe creates more than one executable, so to test <code>minesweeper</code> on Linux, you need to specify it to <code>cargo</code>. In the <code>source</code> directory, run:</li>
</ul>
<pre><code class="language-sh">cargo run --bin minesweeper
</code></pre>
<h2 id="update-the-redox-image"><a class="header" href="#update-the-redox-image">Update The Redox Image</a></h2>
<p>After making changes to your recipe you can use the <code>make rp.redox-games</code> command, which will check for any changes in the recipe, rebuilt it and update the existing Redox image. The <code>make all</code> and <code>make qemu</code> commands do not check for recipes that need to be rebuilt, so if you use them, your changes may not be included in the system.</p>
<ul>
<li>Within your "Build" shell, in your <code>redox</code> directory, run:</li>
</ul>
<pre><code class="language-sh">make rebuild 2&gt;&amp;1 | tee build.log
</code></pre>
<ul>
<li>You can now scan through <code>build.log</code> to check for errors. The file is large and contains many ANSI Escape Sequences, so it can be hard to read. However, if you encountered a fatal build error, it will be at the end of the log, so skip to the bottom and scan upwards.</li>
</ul>
<h2 id="test-your-changes"><a class="header" href="#test-your-changes">Test Your Changes</a></h2>
<p>In the Redox instance started by the <code>make qemu</code> command, test your changes to <code>minesweeper</code></p>
<ul>
<li>Log in with user: <code>user</code> and no password</li>
<li>Open a <code>Terminal</code> window</li>
<li>Type <code>minesweeper</code></li>
<li>Use your arrow keys or <code>WSAD</code> to move to a square and type <code>f</code> to set a flag. The character <code>P</code> will appear</li>
</ul>
<p>Congratulations! You have modified a program and built the system! Next, create a bootable image with your change.</p>
<ul>
<li>If you are still running QEMU, type <code>Ctrl-Alt-G</code> and click the upper right corner of the Redox window to exit.</li>
<li>In your "Build" shell, in the <code>redox</code> directory, run:</li>
</ul>
<pre><code class="language-sh">make live
</code></pre>
<p>In the directory <code>build/x86_64/my-config</code>, you will find the file <code>redox-live.iso</code>. Follow the instructions on the <a href="coding-and-building.html#testing-on-real-hardware">Testing on Real Hardware</a> section and test out your change.</p>
<h3 id="test-your-changes-out-of-the-redox-build-system"><a class="header" href="#test-your-changes-out-of-the-redox-build-system">Test Your Changes (out of the Redox build system)</a></h3>
<p><a href="https://gitlab.redox-os.org/redox-os/redoxer">Redoxer</a> is the tool used to quickly build and run Rust, C and C++ programs for Redox, it downloads the Redox toolchain, build the program and ru inside of a Redox VM.</p>
<h4 id="commands"><a class="header" href="#commands">Commands</a></h4>
<ul>
<li>Install the tool</li>
</ul>
<pre><code class="language-sh">cargo install redoxer
</code></pre>
<ul>
<li>Install the Redox toolchain</li>
</ul>
<pre><code class="language-sh">redoxer toolchain
</code></pre>
<ul>
<li>Build the Rust, C or C++ program or library</li>
</ul>
<pre><code class="language-sh">redoxer build
</code></pre>
<ul>
<li>Run the Rust, C or C++ program on Redox</li>
</ul>
<pre><code class="language-sh">redoxer run
</code></pre>
<ul>
<li>Test the Rust, C or C++ program or library</li>
</ul>
<pre><code class="language-sh">redoxer test
</code></pre>
<ul>
<li>Run an arbitrary executable (<code>echo hello</code>)</li>
</ul>
<pre><code class="language-sh">redoxer exec echo hello
</code></pre>
<h3 id="testing-on-real-hardware"><a class="header" href="#testing-on-real-hardware">Testing On Real Hardware</a></h3>
<p>You can use the <code>make live</code> command to create bootable images, it will be used instead of <code>make image</code></p>
<p>This command will create the file <code>build/your-cpu-arch/your-config/redox-live.iso</code>, you will write this image on your USB, SSD or HDD drives and CD or DVD disks (if you have an USB device, <a href="https://github.com/pop-os/popsicle">Popsicle</a> is the recommended method to flash your device).</p>
<h4 id="full-bootable-image-creation"><a class="header" href="#full-bootable-image-creation">Full bootable image creation</a></h4>
<ul>
<li>Update your system/programs and create a bootable image:</li>
</ul>
<pre><code class="language-sh">make rebuild live
</code></pre>
<h4 id="partial-bootable-image-creation"><a class="header" href="#partial-bootable-image-creation">Partial bootable image creation</a></h4>
<ul>
<li>Build your source changes on some recipe and create a bootable image (no QEMU image creation):</li>
</ul>
<pre><code class="language-sh">make cr.recipe-name live
</code></pre>
<ul>
<li>Manually update multiple recipes and create a bootable image (more quick than <code>make rebuild</code>):</li>
</ul>
<pre><code class="language-sh">make r.recipe1,recipe2 live
</code></pre>
<h4 id="flash-the-bootable-image-on-your-usb-device"><a class="header" href="#flash-the-bootable-image-on-your-usb-device">Flash the bootable image on your USB device</a></h4>
<p>If you can't use Popsicle, you can use the <code>dd</code> tool, follow the steps below:</p>
<ul>
<li>Go to the files of your Cookbook configuration:</li>
</ul>
<pre><code class="language-sh">cd build/your-cpu-arch/your-config
</code></pre>
<ul>
<li>Flash your device with <code>dd</code></li>
</ul>
<p>First you need to find your USB, SSD or HDD drive device ID, use this command to show the IDs of all connected disks on your computer:</p>
<pre><code class="language-sh">ls /dev/disk/by-id
</code></pre>
<p>Search for the items beginning with <code>usb</code> and find your USB device model, you will copy and paste this ID on the <code>dd</code> command below (don't use the IDs with <code>part-x</code> in the end).</p>
<pre><code class="language-sh">sudo dd if=redox-live.iso of=/dev/disk/by-id/usb-your-device-model oflag=sync bs=4M status=progress
</code></pre>
<p>In the <code>/dev/disk/by-id/usb-your-device-model</code> path you will replace the <code>usb-your-device-model</code> part with your USB device ID obtained before.</p>
<p><strong>Double-check the "of=/dev/disk/by-id/usb-your-device-model" part to avoid data loss</strong></p>
<h4 id="burn-your-cddvd-with-the-bootable-image"><a class="header" href="#burn-your-cddvd-with-the-bootable-image">Burn your CD/DVD with the bootable image</a></h4>
<ul>
<li>Go to the files of your Cookbook configuration:</li>
</ul>
<pre><code class="language-sh">cd build/your-cpu-arch/your-config
</code></pre>
<ul>
<li>Verify if your optical disk device can write on CD/DVD</li>
</ul>
<pre><code class="language-sh">cat /proc/sys/dev/cdrom/info
</code></pre>
<p>Check if the items "Can write" has <code>1</code> (Yes) or <code>0</code> (No), it also show the optical disk devices on the computer: <code>/dev/srX</code></p>
<ul>
<li>Burn the disk with <a href="https://www.gnu.org/software/xorriso/">xorriso</a></li>
</ul>
<pre><code class="language-sh">xorriso -as cdrecord -v -sao dev=/dev/srX redox-live.iso
</code></pre>
<p>In the <code>/dev/srX</code> part, where <code>x</code> is your optical device number.</p>
<h2 id="update-crates-1"><a class="header" href="#update-crates-1">Update crates</a></h2>
<p>Read <a href="./porting-applications.html#update-crates">this</a> page to learn how to update crates.</p>
<h2 id="search-text-on-files"><a class="header" href="#search-text-on-files">Search Text On Files</a></h2>
<p>To find which file contains a particular command, crate or function call, you can use the <code>grep</code> command.</p>
<p>This will speed up your development workflow.</p>
<ul>
<li>Command examples</li>
</ul>
<pre><code class="language-sh">grep -rnw "redox-syscall" --include "Cargo.toml"
</code></pre>
<p>This command will show any "Cargo.toml" file that contains the text "redox-syscall". Helpful for finding which recipe contains a command or uses a crate.</p>
<pre><code class="language-sh">grep -rni "physmap" --include "*.rs"
</code></pre>
<p>This command will find any ".rs" file that contains the text "physmap". Helpful for finding where a function is used or defined.</p>
<p>Options context:</p>
<ul>
<li>
<p><code>-n</code> : display the line number of the specified text on each file.</p>
</li>
<li>
<p><code>-r</code> : Search directories recursively.</p>
</li>
<li>
<p><code>-w</code> : Match only whole words.</p>
</li>
<li>
<p><code>-i</code> : Ignore case distinctions in patterns and data.</p>
</li>
<li>
<p><a href="https://www.geeksforgeeks.org/grep-command-in-unixlinux/">GeeksforGeeks - grep command</a> : Great article explaining how to use the <code>grep</code> tool</p>
</li>
</ul>
<h2 id="redox-image"><a class="header" href="#redox-image">Redox Image</a></h2>
<p>This section explain how to update recipes, create and change the Redox image.</p>
<h3 id="build-your-recipe-for-redox"><a class="header" href="#build-your-recipe-for-redox">Build Your Recipe For Redox</a></h3>
<p>You can rebuild just the <code>redox-games</code> recipe, rather than having <code>make rebuild</code> verifying each enabled recipe for changes. This can help shorten the build time if you are trying to resolve issues such as compilation errors or linking to libraries.</p>
<ul>
<li>In your "Build" shell, in the <code>redox</code> directory, run:</li>
</ul>
<pre><code class="language-sh">make r.redox-games
</code></pre>
<p>The build system Makefiles have a rule for the <code>r.recipe</code> recipe target, where <code>recipe</code> is the name of a recipe. It will make that recipe ready to load into the Redox filesystem.</p>
<p>Once your Redox recipe has been successfully built, you can run the <code>make p.redox-games</code> command to install the recipe in the existing Redox image.</p>
<p>If you had a problem, use this command to log any possible errors on your terminal output:</p>
<pre><code class="language-sh">make cr.recipe-name 2&gt;&amp;1 | tee recipe-name.log
</code></pre>
<h3 id="make-a-new-redox-image"><a class="header" href="#make-a-new-redox-image">Make A New Redox Image</a></h3>
<p>If the <code>make p.redox-games</code> command didn't work you need to create a new Redox image.</p>
<ul>
<li>In your "Build" shell, in the <code>redox</code> directory, run:</li>
</ul>
<pre><code class="language-sh">make image
</code></pre>
<p>The <code>make image</code> command skips building any recipes (if the last full recipe rebuild was successful), but it ensures a new image is created, which should include the recipe changes that you built in the previous step.</p>
<h3 id="most-quick-way-to-test-your-changes"><a class="header" href="#most-quick-way-to-test-your-changes">Most Quick Way To Test Your Changes</a></h3>
<p>Run:</p>
<pre><code class="language-sh">make rp.recipe-name qemu
</code></pre>
<p>Or (if your change don't allow incremental compilation)</p>
<pre><code class="language-sh">make crp.recipe-name qemu
</code></pre>
<p>This command will <a href="coding-and-building.html#build-your-recipe-for-redox">build just your modified recipe</a>, then <a href="coding-and-building.html#make-a-new-redox-image">update your Redox image with your modified recipe</a> and run QEMU with Orbital.</p>
<h3 id="insert-text-files-on-qemu-quickest-method"><a class="header" href="#insert-text-files-on-qemu-quickest-method">Insert Text Files On QEMU (quickest method)</a></h3>
<p>If you need to move text files, such as command output, logs or scripts, from or to your Redox instance running on QEMU, use your Terminal window that you used to start QEMU. To capture the output of a Redox command, run <code>script</code> before starting QEMU.</p>
<pre><code class="language-sh">tee qemu.log
</code></pre>
<pre><code class="language-sh">make qemu gpu=no
</code></pre>
<pre><code>redox login: user
# execute your commands, with output to the terminal
# exit QEMU
# exit the shell started by script
</code></pre>
<pre><code class="language-sh">exit
</code></pre>
<p>The command output will now be in the file <code>qemu.log</code>. Note that if you did not exit the <code>script</code> shell the output may not be complete.</p>
<p>To transfer a text file (such as a log) onto Redox, use the Terminal window with clipboard copy/paste.</p>
<pre><code>redox login: user
</code></pre>
<pre><code class="language-sh">cat &gt; mylog.log &lt;&lt; EOF
# Copy the text to the clipboard and use the Terminal window clipboard paste
  EOF
</code></pre>
<p>If your file is large, or non-ASCII, or you have many files to copy, you can use the process described in the <a href="coding-and-building.html#insert-files-on-qemu-image">Insert Files On QEMU Image</a> section. However, there's a risk of data corruption.</p>
<p>Files that you create while running QEMU remain in the Redox image, while you don't rebuild the image (the same applies to files that you add in the Redox image).</p>
<p>Make sure you are <strong>not running QEMU</strong> and run the <code>make mount</code> command. You can now use your file manager to navigate to <code>build/x86_64/my-config/filesystem</code>. Copy your files into or out of the Redox filesystem as required. Make sure to exit your file browser window, and run <code>make unmount</code> before running <code>make qemu</code></p>
<p>Note that in some circumstances, <code>make qemu</code> may trigger a rebuild (e.g. <code>make</code> detects files with timestamp changes). If that happen the files you copied into the Redox image will be lost.</p>
<h3 id="insert-files-on-the-redox-image-using-a-recipe"><a class="header" href="#insert-files-on-the-redox-image-using-a-recipe">Insert files on the Redox image using a recipe</a></h3>
<p>You can use a Redox recipe to put your files inside the Redox image, in this example we will use the recipe <code>myfiles</code> for this:</p>
<ul>
<li>Create the <code>source</code> folder inside the <code>myfiles</code> recipe directory and copy or move your files to it:</li>
</ul>
<pre><code class="language-sh">mkdir recipes/other/myfiles/source
</code></pre>
<ul>
<li>Build the recipe and add on the Redox image:</li>
</ul>
<pre><code class="language-sh">make rp.myfiles
</code></pre>
<ul>
<li>Add the <code>myfiles</code> recipe below the <code>[packages]</code> section of your filesystem configuration at: <code>config/your-cpu-arch/your-config.toml</code> (if you want your files to be automatically added to new images):</li>
</ul>
<pre><code>[packages]
...
myfiles = {}
...
</code></pre>
<ul>
<li>Open QEMU to verify your files:</li>
</ul>
<pre><code class="language-sh">make qemu
</code></pre>
<p>This recipe will make Cookbook package all files in the <code>source</code> folder to be installed in the <code>/home/user</code> directory on your Redox filesystem.</p>
<h3 id="insert-files-in-the-qemu-image"><a class="header" href="#insert-files-in-the-qemu-image">Insert Files In The QEMU Image</a></h3>
<p>If you feel the need to skip creating a new image, and you want to directly add a file to the existing Redox image, it is possible to do so. However, this is not recommended. You should use a recipe to make the process repeatable. You can see below how to access the Redox image as if it were a Linux filesystem.</p>
<p><strong>Redox can't be running on QEMU while you do this</strong></p>
<ul>
<li>In your "Build" shell, in the <code>redox</code> directory, run:</li>
</ul>
<pre><code class="language-sh">make mount
</code></pre>
<p>The Redox image is now mounted as a directory at: <code>build/x86_64/your-config/filesystem</code></p>
<ul>
<li>Unmount the filesystem and test your image. <strong>You must unmount before you start QEMU</strong></li>
</ul>
<pre><code class="language-sh">cd ~/tryredox/redox
</code></pre>
<pre><code class="language-sh">make unmount
</code></pre>
<pre><code class="language-sh">make qemu
</code></pre>
<h2 id="working-with-an-unpublished-version-of-a-crate"><a class="header" href="#working-with-an-unpublished-version-of-a-crate">Working with an unpublished version of a crate</a></h2>
<p>Most Redox libraries use versioning and are downloaded from <a href="https://crates.io/">crates.io</a>, if you are making a change to one of these crates your merged changes could take a while to appear on crates.io as we publish to there instead of using a local crate.</p>
<p>To test your changes quickly, follow the following tutorials on Cargo documentation:</p>
<ul>
<li><a href="https://doc.rust-lang.org/cargo/reference/overriding-dependencies.html">Overriding Dependencies</a></li>
<li><a href="https://doc.rust-lang.org/cargo/reference/overriding-dependencies.html#working-with-an-unpublished-minor-version">Working with an unpublished minor version</a></li>
</ul>
<h2 id="how-to-update-initfs-1"><a class="header" href="#how-to-update-initfs-1">How to update initfs</a></h2>
<p>The <code>base</code> and <code>base-initfs</code> recipes share the <code>source</code> folder, thus your changes on the <code>base</code> recipe source code will be added on the <code>base-initfs</code> recipe automatically.</p>
<p>(The <code>recipe.toml</code> of the <code>base-initfs</code> recipe use the <code>same_as</code> data type to symlink the source, you can read the second line of the <a href="https://gitlab.redox-os.org/redox-os/redox/-/blob/master/recipes/core/base-initfs/recipe.toml#L2">base-initfs recipe</a>)</p>
<p>When you are about to test a change on the <code>base</code> recipe, double check if you're applying for daemons in <code>base-initfs</code> by checking its recipe file in the former link. If you do, you need to trigger build changes for <code>base-initfs</code> manually so it can save <code>initfs</code> daemons into <code>base-initfs</code>:</p>
<pre><code class="language-sh">make rp.base,base-initfs
</code></pre>
<p>RedoxFS is also included in the <code>base-initfs</code> recipe, to update them with your changes run the following command:</p>
<pre><code class="language-sh">make rp.redoxfs,base-initfs
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="including-programs-in-redox"><a class="header" href="#including-programs-in-redox">Including Programs in Redox</a></h1>
<p>(Before reading this page you must read the <a href="./build-system-reference.html">Build System</a> page)</p>
<p>This page will teach you how to add programs on the Redox image, it's a simplified version of the <a href="./porting-applications.html">Application Porting</a> page.</p>
<ul>
<li><a href="including-programs.html#existing-recipe">Existing Recipe</a>
<ul>
<li><a href="including-programs.html#setup-the-redox-build-environment">Setup the Redox Build Environment</a></li>
<li><a href="including-programs.html#setup-your-configuration">Setup Your Configuration</a></li>
<li><a href="including-programs.html#build-the-system">Build the System</a></li>
<li><a href="including-programs.html#dependencies">Dependencies</a></li>
<li><a href="including-programs.html#update-crates">Update crates</a></li>
</ul>
</li>
<li><a href="including-programs.html#modifying-an-existing-recipe">Modifying an Existing Recipe</a></li>
<li><a href="including-programs.html#create-your-own-hello-world">Create Your Own Hello World</a>
<ul>
<li><a href="including-programs.html#setting-up-the-recipe">Setting up the recipe</a></li>
<li><a href="including-programs.html#writing-the-program">Writing the program</a></li>
<li><a href="including-programs.html#adding-the-program-to-the-redox-image">Adding the program to the Redox image</a></li>
</ul>
</li>
<li><a href="including-programs.html#running-your-program">Running your program</a></li>
</ul>
<p>The Cookbook system makes the packaging process very simple. First, we will show how to add an existing program for inclusion. Then we will show how to create a new program to be included. In the <a href="./coding-and-building.html">Coding and Building</a> page, we discuss the development cycle in more detail.</p>
<h2 id="existing-recipe"><a class="header" href="#existing-recipe">Existing Recipe</a></h2>
<p>Redox has many programs that are available for inclusion. Each program has a recipe in the directory <code>recipes/recipe-name</code>. Adding an existing program to your build is as simple as adding it to <code>config/$ARCH/my-config.toml</code>, or whatever name you choose for your filesystem configuration. Here we will add the <code>games</code> package, which contains several terminal games.</p>
<h3 id="setup-the-redox-build-environment"><a class="header" href="#setup-the-redox-build-environment">Setup the Redox Build Environment</a></h3>
<ul>
<li>Follow the steps in the <a href="./podman-build.html">Building Redox</a> or <a href="./building-redox.html">Native Build</a> pages to create the Redox Build Environment on your system.</li>
<li>Build the system as described. This will take quite a while the first time.</li>
<li>Run the system in <strong>QEMU</strong>.</li>
</ul>
<pre><code class="language-sh">cd ~/tryredox/redox
</code></pre>
<pre><code class="language-sh">make qemu
</code></pre>
<p>Assuming you built the default configuration <code>desktop</code> for <code>x86_64</code>, none of the Redox games (e.g. <code>/usr/bin/minesweeper</code>) have been included yet.</p>
<ul>
<li>On your Redox emulation, log into the system as user <code>user</code> with an empty password.</li>
<li>Open a <code>Terminal</code> window by clicking on the icon in the toolbar at the bottom of the Redox screen, and type <code>ls /usr/bin</code>. You will see that <code>minesweeper</code> <strong>is not</strong> listed.</li>
<li>Type <code>Ctrl-Alt-G</code> to regain control of your cursor, and click the upper right corner of the Redox window to exit QEMU.</li>
</ul>
<h3 id="setup-your-configuration-1"><a class="header" href="#setup-your-configuration-1">Setup your Configuration</a></h3>
<p>Read the <a href="./configuration-settings.html">Configuration Settings</a> page and follow the commands below.</p>
<ul>
<li>From your <code>redox</code> base directory, copy an existing configuration and edit it.</li>
</ul>
<pre><code class="language-sh">cd ~/tryredox/redox
</code></pre>
<pre><code class="language-sh">cp config/x86_64/desktop.toml config/x86_64/my-config.toml
</code></pre>
<pre><code class="language-sh">nano config/x86_64/my-config.toml
</code></pre>
<ul>
<li>Look for the <code>[packages]</code> section and add the package to the configuration. You can add the package anywhere in the <code>[packages]</code> section, but by convention, we add them to the end or to an existing related area of the section.</li>
</ul>
<pre><code class="language-toml">...
[packages]
# Add the item below under the "[packages]" section
redox-games = {}
...
</code></pre>
<ul>
<li>Add the <code>CONFIG_NAME</code> environment variable on your <a href="./configuration-settings.html#config">.config</a> to use the <code>myfiles.toml</code> configuration.</li>
</ul>
<pre><code class="language-sh">nano .config
</code></pre>
<pre><code># Add the item below
CONFIG_NAME?=my-config
</code></pre>
<ul>
<li>Save your changes with Ctrl+X and confirm with <code>y</code></li>
</ul>
<h3 id="update-the-system-image"><a class="header" href="#update-the-system-image">Update The System Image</a></h3>
<ul>
<li>In your base <code>redox</code> folder, e.g. <code>~/tryredox/redox</code>, build the system and run it in <strong>QEMU</strong>.</li>
</ul>
<pre><code class="language-sh">cd ~/tryredox/redox
</code></pre>
<pre><code class="language-sh">make rp.redox-games qemu
</code></pre>
<ul>
<li>On your Redox emulation, log into the system as user <code>user</code> with an empty password.</li>
<li>Open a <code>Terminal</code> window by clicking it on the icon in the toolbar at the bottom of the Redox screen, and type <code>ls /usr/bin</code>. You will see that <code>minesweeper</code> <strong>is</strong> listed.</li>
<li>In the terminal window, type <code>minesweeper</code>. Play the game using the arrow keys or <code>WSAD</code>,<code>space</code> to reveal a spot, <code>f</code> to flag a spot when you suspect a mine is present. When you type <code>f</code>, an <code>F</code> character will appear.</li>
</ul>
<p>If you had a problem, use this command to log any possible errors on your terminal output:</p>
<pre><code class="language-sh">make r.recipe-name 2&gt;&amp;1 | tee recipe-name.log
</code></pre>
<p>And that's it! Sort of.</p>
<h3 id="dependencies"><a class="header" href="#dependencies">Dependencies</a></h3>
<p>Read the <a href="./porting-applications.html#dependencies">Dependencies</a> section to learn how to handle recipe dependencies.</p>
<h3 id="update-crates-2"><a class="header" href="#update-crates-2">Update crates</a></h3>
<p>Read the <a href="./porting-applications.html#update-crates">Update crates</a> section to learn how to update crates on Rust programs.</p>
<h2 id="modifying-an-existing-recipe"><a class="header" href="#modifying-an-existing-recipe">Modifying an Existing Recipe</a></h2>
<p>If you want to make changes to an existing recipe for your own purposes, you can do your work in the directory <code>recipes/recipe-name/source</code>. The Cookbook process will not download sources if they are already present in that folder. However, if you intend to do significant work or to contribute changes to Redox, please read the <a href="./coding-and-building.html">Coding and Building</a> page.</p>
<h2 id="create-your-own-hello-world"><a class="header" href="#create-your-own-hello-world">Create Your Own Hello World</a></h2>
<p>To create your own program to be included, you will need to create the recipe. This example walks through adding the "Hello World" program that the <code>cargo new</code> command automatically generates to the folder of a Rust project.</p>
<p>This process is largely the same for other Rust programs.</p>
<h3 id="setting-up-the-recipe"><a class="header" href="#setting-up-the-recipe">Setting Up The Recipe</a></h3>
<p>The Cookbook will only build programs that have a recipe defined in <code>recipes</code>. To create a recipe for the Hello World program, first create the directory <code>recipes/hello-world</code>. Inside this directory create the "recipe.toml" file and add these lines to it:</p>
<pre><code class="language-toml">[build]
template = "cargo"
</code></pre>
<p>The <code>[build]</code> section defines how Cookbook should build our project. There are several templates but <code>"cargo"</code> should be used for Rust projects.</p>
<p>The <code>[source]</code> section of the recipe tells Cookbook how to download the Git repository/tarball of the program.</p>
<p>This is done if <code>recipes/recipe-name/source</code> does not exist, during <code>make fetch</code> or during the fetch step of <code>make all</code>. For this example, we will simply develop in the <code>source</code> directory, so no <code>[source]</code> section is necessary.</p>
<h3 id="writing-the-program"><a class="header" href="#writing-the-program">Writing the program</a></h3>
<p>Since this is a Hello World example, we are going to have Cargo write the code for us. In <code>recipes/hello-world</code>, do the following:</p>
<pre><code class="language-sh">mkdir source
</code></pre>
<pre><code class="language-sh">cd source
</code></pre>
<pre><code class="language-sh">cargo init --name="hello-world"
</code></pre>
<p>This creates a <code>Cargo.toml</code> file and a <code>src</code> directory with the Hello World program.</p>
<h3 id="adding-the-program-to-the-redox-image"><a class="header" href="#adding-the-program-to-the-redox-image">Adding the program to the Redox image</a></h3>
<p>To be able to run a program inside of Redox, it must be added to the filesystem. As <a href="including-programs.html#existing-package">above</a>, create a filesystem config <code>config/x86_64/myfiles.toml</code> or similar by copying an existing configuration, and modify <code>CONFIG_NAME</code> in <a href="./configuration-settings.html#config">.config</a> to be <code>myfiles</code>. Open <code>config/x86_64/myfiles.toml</code> and add <code>hello-world = {}</code> below the <code>[packages]</code> section.</p>
<p>During the creation of the Redox image, the build system installs those packages on the image filesystem.</p>
<pre><code class="language-toml">[packages]
# Add the item below
hello-world = {}
</code></pre>
<p>To update the Redox image, including your program, run the following commands:</p>
<pre><code class="language-sh">cd ~/tryredox/redox
</code></pre>
<pre><code class="language-sh">make rp.hello-world
</code></pre>
<h2 id="running-your-program"><a class="header" href="#running-your-program">Running your program</a></h2>
<p>Once the rebuild is finished, run <code>make qemu</code>, and when the GUI starts, log in to Redox, open the terminal, and run <code>helloworld</code>. It should print</p>
<pre><code>Hello, world!
</code></pre>
<p>Note that the <code>hello-world</code> binary can be found in <code>/usr/bin</code> on Redox.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="application-porting"><a class="header" href="#application-porting">Application Porting</a></h1>
<p>The <a href="./including-programs.html">Including Programs in Redox</a> page gives an example to port/modify a pure Rust program, in this page we explain the advanced way to port pure Rust programs, mixed Rust programs (Rust and C/C++ libraries, for example), C/C++ programs and others.</p>
<p>(Before reading this page you must read the <a href="./build-system-reference.html">Build System</a> page)</p>
<ul>
<li><a href="porting-applications.html#recipe">Recipe</a>
<ul>
<li><a href="porting-applications.html#recipe-configuration-example">Recipe Configuration Example</a></li>
<li><a href="porting-applications.html#quick-recipe-template">Quick Recipe Template</a></li>
</ul>
</li>
<li><a href="porting-applications.html#cookbook">Cookbook</a>
<ul>
<li><a href="porting-applications.html#cross-compiler">Cross Compiler</a></li>
<li><a href="porting-applications.html#cross-compilation">Cross Compilation</a></li>
<li><a href="porting-applications.html#templates">Templates</a></li>
<li><a href="porting-applications.html#metapackages">Metapackages</a></li>
</ul>
</li>
<li><a href="porting-applications.html#cookbook-custom-template">Cookbook - Custom Template</a>
<ul>
<li><a href="porting-applications.html#functions">Functions</a></li>
<li><a href="porting-applications.html#environment-variables">ç’°å¢ƒè®Šæ•¸</a>
<ul>
<li><a href="porting-applications.html#quick-template">Quick Template</a></li>
</ul>
</li>
<li><a href="porting-applications.html#packaging-behavior">Packaging Behavior</a></li>
<li><a href="porting-applications.html#gnu-autotools-script">GNU Autotools script</a></li>
<li><a href="porting-applications.html#gnu-autotools-configuration-script">GNU Autotools configuration script</a></li>
<li><a href="porting-applications.html#cmake-script">CMake script</a></li>
<li><a href="porting-applications.html#meson-script">Meson script</a></li>
<li><a href="porting-applications.html#cargo-script">Cargo script</a></li>
<li><a href="porting-applications.html#analyze-the-source-code-of-a-rust-program">Analyze the source code of a Rust program</a></li>
<li><a href="porting-applications.html#cargo-packages-command-example">Cargo packages command example</a>
<ul>
<li><a href="porting-applications.html#cargo-package-with-flags">Cargo package with flags</a></li>
</ul>
</li>
<li><a href="porting-applications.html#cargo-bins-script-example">Cargo bins script example</a></li>
<li><a href="porting-applications.html#cargo-flags-command-example">Cargo flags command example</a></li>
<li><a href="porting-applications.html#disable-the-default-cargo-flags">Disable the default Cargo flags</a></li>
<li><a href="porting-applications.html#enable-all-cargo-flags">Enable all Cargo flags</a></li>
<li><a href="porting-applications.html#cargo-profiles-command-example">Cargo profiles command example</a></li>
<li><a href="porting-applications.html#cargo-examples-command-example">Cargo examples command example</a>
<ul>
<li><a href="porting-applications.html#cargo-examples-with-flags">Cargo examples with flags</a></li>
</ul>
</li>
<li><a href="porting-applications.html#rename-binaries">Rename binaries</a></li>
<li><a href="porting-applications.html#change-the-active-source-code-folder">Change the active source code folder</a></li>
<li><a href="porting-applications.html#configuration-files">Configuration files</a></li>
<li><a href="porting-applications.html#script-based-programs">Script-based programs</a>
<ul>
<li><a href="porting-applications.html#adapted-scripts">Adapted scripts</a></li>
<li><a href="porting-applications.html#non-adapted-scripts">Non-adapted scripts</a></li>
</ul>
</li>
<li><a href="porting-applications.html#dynamically-linked-programs">Dynamically Linked Programs</a>
<ul>
<li><a href="porting-applications.html#debugging">Debugging</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="porting-applications.html#sources">Sources</a>
<ul>
<li><a href="porting-applications.html#tarballs">Tarballs</a>
<ul>
<li><a href="porting-applications.html#build-system">Build System</a></li>
<li><a href="porting-applications.html#links">Links</a></li>
</ul>
</li>
<li><a href="porting-applications.html#git-repositories">Git Repositories</a>
<ul>
<li><a href="porting-applications.html#github-release-commit-hash">GitHub release commit hash</a></li>
<li><a href="porting-applications.html#gitlab-release-commit-hash">GitLab release commit hash</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="porting-applications.html#dependencies">Dependencies</a>
<ul>
<li><a href="porting-applications.html#bundled-libraries">Bundled Libraries</a></li>
<li><a href="porting-applications.html#submodules">Submodules</a></li>
<li><a href="porting-applications.html#environment-variables-1">Environment Variables</a></li>
<li><a href="porting-applications.html#configuration">çµ„æ…‹</a>
<ul>
<li><a href="porting-applications.html#arch-linux-and-aur">Arch Linux and AUR</a></li>
<li><a href="porting-applications.html#gentoo">Gentoo</a></li>
</ul>
</li>
<li><a href="porting-applications.html#build-tools">Build Tools</a></li>
</ul>
</li>
<li><a href="porting-applications.html#feature-flags">Feature Flags</a></li>
<li><a href="porting-applications.html#buildingtesting-the-program">Building/Testing The Program</a></li>
<li><a href="porting-applications.html#update-crates">Update crates</a>
<ul>
<li><a href="porting-applications.html#one-or-more-crates">One or more crates</a></li>
<li><a href="porting-applications.html#all-crates">All crates</a></li>
<li><a href="porting-applications.html#verify-the-dependency-tree">Verify the dependency tree</a></li>
</ul>
</li>
<li><a href="porting-applications.html#patch-crates">Patch crates</a>
<ul>
<li><a href="porting-applications.html#redox-forks">Redox forks</a></li>
<li><a href="porting-applications.html#local-patches">Local patches</a></li>
</ul>
</li>
<li><a href="porting-applications.html#cleanup">Cleanup</a></li>
<li><a href="porting-applications.html#search-text-on-recipes">Search Text On Recipes</a></li>
<li><a href="porting-applications.html#search-for-functions-on-relibc">Search for functions on relibc</a></li>
<li><a href="porting-applications.html#create-a-blake3-hash-for-your-recipe">Create a BLAKE3 hash for your recipe</a></li>
<li><a href="porting-applications.html#verify-the-size-of-your-package">Verify the size of your package</a></li>
<li><a href="porting-applications.html#submitting-mrs">Submitting MRs</a></li>
<li><a href="porting-applications.html#package-policy">Package Policy</a></li>
</ul>
<h2 id="recipe-1"><a class="header" href="#recipe-1">Recipe</a></h2>
<p>A recipe is how we call a software port on Redox, this section explain the recipe configuration and details to consider.</p>
<p>Create a folder at <code>recipes/program-category</code> with a file named as <code>recipe.toml</code> inside, we will modify this file to fit the program needs.</p>
<ul>
<li>Recipe creation from terminal with GNU Nano:</li>
</ul>
<pre><code class="language-sh">cd ~/tryredox/redox
</code></pre>
<pre><code class="language-sh">mkdir recipes/program-category/program-name
</code></pre>
<pre><code class="language-sh">nano recipes/program-category/program-name/recipe.toml
</code></pre>
<h3 id="recipe-configuration-example"><a class="header" href="#recipe-configuration-example">Recipe Configuration Example</a></h3>
<p>The recipe configuration (<code>recipe.toml</code>) example below contain all supported recipe options. Adapt for your script, program, library or data files.</p>
<p>TOML sections and data types can also be mentioned using the <code>section-name.data-type-name</code> format for easier explanation and better explanation writing.</p>
<pre><code class="language-toml">[source]
git = "repository-link" # source.git data type
upstream = "repository-link" # source.upstream data type
branch = "branch-name" # source.branch data type
rev = "version-tag" # source.rev data type
shallow_clone = true # source.shallow_clone data type
tar = "tarball-link.tar.gz" # source.tar data type
blake3 = "source-hash" # source.blake3 data type
patches = [ # source.patches data type
    "patch1.patch",
    "patch2.patch",
]
same_as = "../program-name" # source.same_as data type
script = """ # source.script data type
insert your script here
"""
[build]
template = "build-system" # build.template data type
cargoflags = "--option-name" # build.cargoflags data type
configureflags = [ # build.configureflags data type
    "OPTION1=value",
    "OPTION2=value",
]
cmakeflags = [ # build.cmakeflags data type
    "-DOPTION1=value",
    "-DOPTION2=value",
]
mesonflags = [ # build.mesonflags data type
    "-Doption1=value",
    "-Doption2=value",
]
dev-dependencies = [ # build.dev-dependencies data type
    "host:tool1",
    "host:tool2",
]
dependencies = [ # build.dependencies data type
    "library1",
    "library2",
]
script = """ # build.script data type
# Uncomment the following if the package can be dynamically linked
#DYNAMIC_INIT
insert your script here
"""
[package]
dependencies = [ # package.dependencies data type
    "runtime-dependency1",
    "runtime-dependency2",
]
</code></pre>
<ul>
<li><code>[source]</code> : Section for data types that manage the program source (only remove it if you have a <code>source</code> folder)</li>
<li><code>source.git</code> : Git repository of the program (can be removed if a Git repository is not used), you can comment out it to not allow Cookbook to force a <code>git pull</code> or change the active branch to <code>master</code> or <code>main</code>. Read the <a href="porting-applications.html#git-repositories">Git Repositories</a> section for more details.</li>
<li><code>source.upstream</code> : If you are using a fork of the program source with patches add the program upstream source here (can be removed if the upstream source is being used on the <code>git</code> data type)</li>
<li><code>source.branch</code> : Program version Git branch or patched Git branch (can be removed if using a tarball or the <code>master</code> or <code>main</code> Git branches are being used)</li>
<li><code>source.rev</code> : Git tag or commit hash of the latest stable version or last working commit of the program (can be removed if you are using a tarball or waiting Rust library version updates)</li>
<li><code>source.shallow_clone</code> : Boolean data type to only download the current commit of source files (Git <a href="https://github.blog/open-source/git/get-up-to-speed-with-partial-clone-and-shallow-clone/">shallow clone</a>), which can reduce the download/delta processing time a lot and save many storage space (insert <code>shallow_clone = true</code>). Read the note in the <a href="porting-applications.html#git-repositories">Git Repositories</a> section if you are doing heavy development in a fork</li>
<li><code>source.tar</code> : Program source tarball (can be removed if a tarball is not used), read the <a href="porting-applications.html#tarballs">Tarballs</a> section for more details.</li>
<li><code>source.blake3</code> : Program source tarball BLAKE3 hash, can be generated using the <code>b3sum</code> tool, install with the <code>cargo install b3sum</code> command (can be removed if using a Git repository or under porting)</li>
<li><code>source.patches</code> : Data type to load <code>.patch</code> files (can be removed if patch files aren't used)</li>
<li><code>"patch1.patch",</code> : The patch file name (can be removed if the <code>patches</code> data type above is not present)</li>
<li><code>source.same_as</code> : Insert the folder of other recipe to make a symbolic link to the <code>source</code> folder of other recipe, useful if you want modularity with synchronization</li>
<li><code>source.script</code> : Data type used when you need to change the build system configuration (to regenerate the GNU Autotools configuration, for example)</li>
<li><code>[build]</code> : Section for data types that manage the program compilation and packaging</li>
<li><code>build.template</code> : Insert the program build system, read the <a href="porting-applications.html#templates">Templates</a> section for more details.</li>
<li><code>build.cargoflags</code> : Data type for Cargo flags (string)</li>
<li><code>build.configureflags</code> : Data type for GNU Autotools flags (array)</li>
<li><code>build.cmakeflags</code> : Data type for CMake flags (array)</li>
<li><code>build.mesonflags</code> : Data type for Meson flags (array)</li>
<li><code>build.dev-dependencies</code> : Data type to add the build tools needed by the program or library</li>
<li><code>build.dev-dependencies = ["host:tool1",]</code> : Build tool recipe name (can be removed if the <code>build.dev-dependencies</code> data type is not present)</li>
<li><code>build.dependencies</code> : Data type to add dynamically or statically linked library dependencies, read the <a href="porting-applications.html#dependencies">Dependencies</a> section for more details.</li>
<li><code>build.dependencies = ["library1",]</code> : Library recipe name (can be removed if the <code>build.dependencies</code> data type is not present)</li>
<li><code>build.script</code> : Data type to load the custom commands for compilation and packaging</li>
<li><code>[package]</code> : Section for data types that manage the program package</li>
<li><code>package.dependencies</code> : Data type to add tools, interpreters or "data files" recipes to be installed by the package manager or build system installer</li>
<li><code>package.dependencies = ["runtime-dependency1",]</code> : Tool, interpreter or data recipe names (can be removed if the <code>package.dependencies</code> data type above is not present)</li>
</ul>
<h3 id="quick-recipe-template"><a class="header" href="#quick-recipe-template">Quick Recipe Template</a></h3>
<p>This is a recipe template for a quick porting workflow.</p>
<pre><code class="language-toml">#TODO not compiled or tested
[source]
git = "repository-link"
rev = "version-tag"
branch = "version-branch"
tar = "tarball-link"
shallow_clone = true
[build]
template = "build-system"
dependencies = [
    "library1",
]
</code></pre>
<p>You can quickly copy and paste this template on each <code>recipe.toml</code>, that way you spent less time writting and has less chances for typos.</p>
<ul>
<li>If your program use a tarball, you can quickly remove the <code>git</code> and <code>rev</code> data types.</li>
<li>If your program use a Git repository, you can quickly remove the <code>tar</code> data type.</li>
<li>If you don't need to pin a Git tag or commit hash for the latest stable release or last working commit, you can quickly remove the <code>rev</code> data type.</li>
<li>If the program don't need C, C++ or patched Rust dependencies, you can quickly remove the <code>dependencies = []</code> section.</li>
</ul>
<p>After the <code>#TODO</code> comment you will write your current porting status.</p>
<h2 id="cookbook-4"><a class="header" href="#cookbook-4">Cookbook</a></h2>
<p>The GCC and LLVM compiler frontends on Linux use the Linux target triplet by default, it will create Linux ELF binaries that don't work on Redox because it can't undertstand them.</p>
<p>Part of this process is to use <code>glibc</code> (GNU C Standard Library) which don't support Redox system calls, to make the compiler use <code>relibc</code> (Redox C Standard Library) Cookbook need to tell the build system of the program or library to use it, it's done with environment variables and target/platform flags for the Redox target.</p>
<p>Cookbook have build system templates to avoid custom commands for cross-compilation, but it's not always possible because some build systems or programs aren't standardized or adapted for cross-compilation.</p>
<p>(Build systems have different methods to enable cross-compilation and pass a different C standard library to the compiler, you will need to read their documentation, program/library specific configuration or hack them)</p>
<h3 id="cross-compiler"><a class="header" href="#cross-compiler">Cross Compiler</a></h3>
<p>Cookbook use Rust/GCC forks to do cross-compilation of recipes (programs) with <code>relibc</code> to any supported CPU architecture, you can check our cross-compilers on GitLab (<a href="https://gitlab.redox-os.org/redox-os/gcc">GCC</a>, <a href="https://gitlab.redox-os.org/redox-os/llvm-project">LLVM</a>, <a href="https://gitlab.redox-os.org/redox-os/rust">Rust</a> and their <a href="https://static.redox-os.org/toolchain/">pre-compiled binaries</a>).</p>
<h3 id="cross-compilation-1"><a class="header" href="#cross-compilation-1">Cross Compilation</a></h3>
<p>The Cookbook default compilation type is cross-compilation because it reduces the requirements to run programs on Redox and allow us to do Redox development from Linux and other Unix-like systems.</p>
<p>By default Cookbook use the CPU architecture of your host system but you can change it easily on your <code>.config</code> file (<code>ARCH?</code> environment variable).</p>
<ul>
<li>Don't use a hardcoded CPU architecture in the <code>script</code> data types of your <code>recipe.toml</code>, it breaks cross-compilation with a different CPU architecture is used by the build system.</li>
<li>All recipes must use our cross-compilers, a Cookbook template does this automatically but it's not always possible, read the build system configuration of your program/library to find these options or patch the configuration files.</li>
</ul>
<h3 id="templates"><a class="header" href="#templates">Templates</a></h3>
<p>A recipe template is the build system of the program or library supported by Cookbook.</p>
<ul>
<li><code>template = "cargo"</code> - Build with Cargo using cross-compilation and static linking (Rust programs with one package in the Cargo workspace).</li>
<li><code>template = "configure"</code> - Build with GNU Autotools/GNU Make using cross-compilation and dynamic linking.</li>
<li><code>template = "cmake"</code> - Build with CMake using cross-compilation and dynamic linking.</li>
<li><code>template = "meson"</code> - Build with Meson using cross-compilation and dynamic linking.</li>
<li><code>template = "remote"</code> - Download the remote Redox package of the recipe if available in the <a href="https://static.redox-os.org/pkg/">package server</a></li>
<li><code>template = "custom"</code> - Run your commands on the <code>script =</code> field and build (Any build system or installation process).</li>
</ul>
<p>Keep in mind that some recipes may need build tools that aren't provided by the build system templates or not installed in the Podman container or your system and will need to be added in the <code>dev.dependencies</code> data type of the recipe, don't add build tools or compilers already provided by the templates.</p>
<p>The <code>script =</code> field runs any terminal command supported by GNU Bash, it's important if the build system of the program don't support cross-compilation or need custom options to work on Redox (you can't use the <code>build.script</code> data type if the <code>custom</code> template is not used).</p>
<p>Each template (except <code>custom</code>) script supports build flags, you can add flags as an array of strings:</p>
<ul>
<li><code>cargoflags = "foo"</code></li>
<li><code>configureflags = [ "foo" ]</code></li>
<li><code>cmakeflags = [ "foo" ]</code></li>
<li><code>mesonflags = [ "foo" ]</code></li>
</ul>
<p>To find the supported Cookbook Bash functions, look the recipes using a <code>script =</code> field on their <code>recipe.toml</code> or read the <a href="https://gitlab.redox-os.org/redox-os/redox/-/tree/master/src">source code</a>.</p>
<ul>
<li><a href="https://gitlab.redox-os.org/redox-os/redox/-/tree/master/recipes">Recipes</a></li>
</ul>
<h4 id="cases"><a class="header" href="#cases">Cases</a></h4>
<ul>
<li>Programs using the Cargo build system have a <code>Cargo.toml</code> file</li>
<li>Programs using the GNU Autotools build system have a <code>configure</code> or <code>autogen.sh</code> file in the source tarball</li>
<li>Programs using the CMake build system have a <code>CMakeLists.txt</code> file</li>
<li>Programs using the Meson build system have a <code>meson.build</code> file</li>
</ul>
<h3 id="metapackages"><a class="header" href="#metapackages">Metapackages</a></h3>
<p>Metapackages are packages without any files, just dependencies. Use the following recipe example to create a metapackage:</p>
<pre><code class="language-toml">[package]
dependencies = [
    "package1",
    "package2",
]
</code></pre>
<h2 id="cookbook---custom-template"><a class="header" href="#cookbook---custom-template">Cookbook - Custom Template</a></h2>
<p>The <code>custom</code> template enable the <code>build.script =</code> data type to be used, this data type will run any command supported by the <a href="https://www.gnu.org/software/bash/">GNU Bash</a> shell. The shell script will be wrapped with Bash functions and variables to aid the build script. The wrapper can be found in <a href="https://gitlab.redox-os.org/redox-os/-/blob/master/src/bin/cook.rs">this Cookbook source file</a>.</p>
<ul>
<li>Script example</li>
</ul>
<pre><code class="language-toml">[build]
script = """
first-command
second-command
"""
</code></pre>
<p>The script section starts at the location of the <code>${COOKBOOK_BUILD}</code> environment variable (<code>recipe-name/target/$TARGET/build</code>). This <code>${COOKBOOK_BUILD}</code> will be an empty folder, while recipe sources are in <code>${COOKBOOK_SOURCE}</code>. It is expected that the build script will not modify anything in <code>${COOKBOOK_SOURCE}</code>, otherwise, please use the <code>source.script = </code> data type.</p>
<h3 id="functions"><a class="header" href="#functions">Functions</a></h3>
<p>Each template has a Bash function to be used in the <code>script</code> data type when you need to customize the template configuration to fix the program compilation or enable/disable features.</p>
<ul>
<li><code>cookbook_cargo</code> - Bash function of the <code>cargo</code> template</li>
<li><code>cookbook_configure</code> - Bash function of the <code>configure</code> template</li>
<li><code>cookbook_cmake</code> - Bash function of the <code>cmake</code> template</li>
<li><code>cookbook_meson</code> - Bash function of the <code>meson</code> template</li>
<li><code>DYNAMIC_INIT</code> - Bash function to configure the recipe to be dynamically linked</li>
<li><code>DYNAMIC_STATIC_INIT</code> - Bash function to configure the recipe to be both statically and dynamically linked (library recipe only)</li>
</ul>
<h3 id="environment-variables-2"><a class="header" href="#environment-variables-2">Environment Variables</a></h3>
<p>These variables available in the script:</p>
<ul>
<li>
<p><code>${TARGET}</code> - Redox compiler triple target (<code>$ARCH-unknown-redox</code>)</p>
</li>
<li>
<p><code>${GNU_TARGET}</code> - Redox compiler triple target (GNU variant)</p>
</li>
<li>
<p><code>${COOKBOOK_MAKE_JOBS}</code> - Total CPU threads available</p>
</li>
<li>
<p><code>${COOKBOOK_RECIPE}</code> - Recipe folder.</p>
</li>
<li>
<p><code>${COOKBOOK_ROOT}</code> - The Cookbook directory.</p>
</li>
<li>
<p><code>${COOKBOOK_SOURCE}</code> - The <code>source</code> folder at <code>recipe-name/source</code> (program source).</p>
</li>
<li>
<p><code>${COOKBOOK_SYSROOT}</code> - The <code>sysroot</code> folder at <code>recipe-name/target/$TARGET/sysroot</code> (library sources).</p>
</li>
<li>
<p><code>${COOKBOOK_BUILD}</code> - The <code>build</code> folder at <code>recipe-name/target/$TARGET/build</code> (recipe build system).</p>
</li>
<li>
<p><code>${COOKBOOK_STAGE}</code> - The <code>stage</code> folder at <code>recipe-name/target/$TARGET/stage</code> (recipe binaries).</p>
</li>
<li>
<p>For RISC-V, <code>${TARGET}</code> and <code>${GNU_TARGET}</code> is <code>riscv64gc-unknown-redox</code> and <code>riscv64-unknown-redox</code>, usually you want <code>${TARGET}</code> unless the script requires a GNU target triple.</p>
</li>
<li>
<p>To get <code>$ARCH</code>, you need to add <code>ARCH="${TARGET%%-*}"</code> to the beginning of the script.</p>
</li>
</ul>
<p>There are more variables depending on the build script that you are using.</p>
<p>We recommend that you use path environment variables with the <code>"</code> symbol to clean any invalid characters (like spaces) on the path, spaces are interpreted as command separators and will break the path.</p>
<p>Example:</p>
<pre><code class="language-sh">"${VARIABLE_NAME}"
</code></pre>
<p>If you have a folder inside the variable folder you can call it with:</p>
<pre><code class="language-sh">"${VARIABLE_NAME}"/folder-name
</code></pre>
<p>Or</p>
<pre><code class="language-sh">"${VARIABLE_NAME}/folder-name"
</code></pre>
<h4 id="quick-template"><a class="header" href="#quick-template">Quick Template</a></h4>
<p>You can quickly copy these environment variables from this section.</p>
<pre><code class="language-sh">"${COOKBOOK_SOURCE}/"
</code></pre>
<pre><code class="language-sh">"${COOKBOOK_BUILD}/"
</code></pre>
<pre><code class="language-sh">"${COOKBOOK_SYSROOT}/"
</code></pre>
<pre><code class="language-sh">"${COOKBOOK_STAGE}/"
</code></pre>
<h3 id="packaging-behavior"><a class="header" href="#packaging-behavior">Packaging Behavior</a></h3>
<p>Cookbook download the recipe sources on the <code>source</code> folder (<code>recipe-name/source</code>), copy the contents of this folder to the <code>build</code> folder (<code>recipe-name/target/$TARGET/build</code>), build the sources and move the binaries to the <code>stage</code> folder (<code>recipe-name/target/$TARGET/stage</code>).</p>
<p>If your recipe has library dependencies, it will copy the library source and linker objects to the <code>sysroot</code> folder to be used by the <code>build</code> folder.</p>
<ul>
<li>Moving the program files to the Redox filesystem</li>
</ul>
<p>The <code>"${COOKBOOK_STAGE}"/</code> path is used to specify where the recipe files will be stored in the Redox filesystem, in most cases <code>/usr/bin</code> and <code>/usr/lib</code>.</p>
<p>You can see path examples for most customized recipes below:</p>
<pre><code class="language-sh">"${COOKBOOK_STAGE}"/ # The root of the Redox build system
"${COOKBOOK_STAGE}"/usr/bin # System-wide executables directory
"${COOKBOOK_STAGE}"/usr/lib # System-wide shared and static library objects directory
"${COOKBOOK_STAGE}"/usr/share # System-wide application static data files
"${COOKBOOK_STAGE}"/etc # System-wide application static configuration files
</code></pre>
<h3 id="gnu-autotools-script"><a class="header" href="#gnu-autotools-script">GNU Autotools script</a></h3>
<p>Use this script if the program or library needs to be compiled with custom options</p>
<ul>
<li>Configure with dynamic linking</li>
</ul>
<pre><code class="language-toml">script = """
DYNAMIC_INIT
COOKBOOK_CONFIGURE_FLAGS+=(
    --option1
    --option2
)
cookbook_configure
"""
</code></pre>
<ul>
<li>GNU Make without Configure</li>
</ul>
<pre><code class="language-toml">script = """
DYNAMIC_INIT
COOKBOOK_CONFIGURE_FLAGS+=(
    --option1
    --option2
)
COOKBOOK_CONFIGURE="true"

rsync -av --delete "${COOKBOOK_SOURCE}/" ./
cookbook_configure
"""
</code></pre>
<p>Definition of <code>cookbook_configure</code> is roughly:</p>
<pre><code class="language-sh">function cookbook_configure {
    "${COOKBOOK_CONFIGURE}" "${COOKBOOK_CONFIGURE_FLAGS[@]}" "$@"
    "${COOKBOOK_MAKE}" -j "${COOKBOOK_MAKE_JOBS}"
    "${COOKBOOK_MAKE}" install DESTDIR="${COOKBOOK_STAGE}"
}
</code></pre>
<h3 id="gnu-autotools-configuration-script"><a class="header" href="#gnu-autotools-configuration-script">GNU Autotools configuration script</a></h3>
<p>Sometimes the program tarball or repository is lacking the <code>configure</code> script or it need to be recreated for dynamic linking, so you will need to generate this script.</p>
<ul>
<li>Add the following code below the <code>[source]</code> section</li>
</ul>
<pre><code class="language-toml">script = """
autotools_recursive_regenerate
"""
</code></pre>
<h3 id="cmake-script"><a class="header" href="#cmake-script">CMake script</a></h3>
<p>Use this script for programs using the CMake build system, more CMake options can be added with a <code>-D</code> before them, the customization of CMake compilation is very easy.</p>
<ul>
<li>CMake using dynamic linking</li>
</ul>
<pre><code class="language-toml">script = """
DYNAMIC_INIT
COOKBOOK_CMAKE_FLAGS+=(
    -DOPTION1=value
    -DOPTION2=value
)
cookbook_cmake
"""
</code></pre>
<ul>
<li>CMake inside a subfolder</li>
</ul>
<pre><code class="language-toml">script = """
DYNAMIC_INIT
COOKBOOK_CMAKE_FLAGS+=(
    -DOPTION1=value
    -DOPTION2=value
)
cookbook_cmake "${COOKBOOK_SOURCE}"/subfolder
"""
</code></pre>
<p>Definition of <code>cookbook_cmake</code> is roughly:</p>
<pre><code class="language-sh">function cookbook_cmake {
    "${COOKBOOK_CMAKE}" "${COOKBOOK_SOURCE}" \
        "${COOKBOOK_CMAKE_FLAGS[@]}" \
        "$@"

    "${COOKBOOK_NINJA}" -j"${COOKBOOK_MAKE_JOBS}"
    DESTDIR="${COOKBOOK_STAGE}" "${COOKBOOK_NINJA}" install -j"${COOKBOOK_MAKE_JOBS}"
}
</code></pre>
<h3 id="meson-script"><a class="header" href="#meson-script">Meson script</a></h3>
<p>Use this script for programs using the Meson build system, more Meson options can be added with a <code>-D</code> before them, the customization of Meson compilation is very easy.</p>
<p>Keep in mind that some programs and libraries need more configuration to work.</p>
<ul>
<li>Meson using dynamic linking</li>
</ul>
<pre><code class="language-toml">script = """
DYNAMIC_INIT
COOKBOOK_MESON_FLAGS+=(
    -Doption1=value
    -Doption2=value
)
cookbook_meson
"""
</code></pre>
<ul>
<li>Meson inside a subfolder</li>
</ul>
<pre><code class="language-toml">script = """
DYNAMIC_INIT
COOKBOOK_MESON_FLAGS+=(
    -Doption1=value
    -Doption2=value
)
cookbook_meson "${COOKBOOK_SOURCE}"/subfolder
"""
</code></pre>
<h3 id="cargo-script"><a class="header" href="#cargo-script">Cargo script</a></h3>
<p>Use this script if you need to customize the <code>cookbook_cargo</code> function.</p>
<pre><code class="language-toml">script = """
DYNAMIC_INIT
COOKBOOK_CARGO_FLAGS=(
    --bin foo
)
PACKAGE_PATH="subfolder" cookbook_cargo "${COOKBOOK_CARGO_FLAGS[@]}"
"""
</code></pre>
<p>If the project is roughly a simple Cargo project then <code>cookbook_cargo</code> is all that you need.</p>
<pre><code class="language-toml">script = """
DYNAMIC_INIT
cookbook_cargo
"""
</code></pre>
<h3 id="analyze-the-source-code-of-a-rust-program"><a class="header" href="#analyze-the-source-code-of-a-rust-program">Analyze the source code of a Rust program</a></h3>
<p>Rust programs and libraries use the <code>Cargo.toml</code> configuration file to configure the build system and source code.</p>
<p>While packaging Rust programs you need to know where the main executable is located in the Cargo project, to do this you need to verify the <code>Cargo.toml</code> files of the project.</p>
<p>A Rust program can have one or more Cargo packages to build, read the common assumptions below:</p>
<ul>
<li>Most Rust programs with a <code>src</code> folder use one Cargo package, thus you can use the <code>cargo</code> template.</li>
<li>Most Rust programs with multiple Cargo packages name the main package with the name of the program.</li>
</ul>
<p>Beyond these common source code organization, there are special cases.</p>
<ul>
<li>In some Rust programs the <code>Cargo.toml</code> file contains one of these data types:</li>
</ul>
<pre><code class="language-toml">[[bin]]
name = "executable-name"
[[lib]]
name = "library-object-name"
</code></pre>
<p>The <code>[[bin]]</code> is what you need, the program executable is built by this Cargo package.</p>
<p>But some programs don't have the <code>[[bin]]</code> and <code>[[lib]]</code> data types, for these cases you need to see the source code files, in most cases at the <code>src</code> folder.</p>
<ul>
<li>The file named <code>main.rs</code> contains the program executable code.</li>
<li>The file named <code>lib.rs</code> contains the library object code (ignore it).</li>
</ul>
<p>(Some Rust programs use packages instead of example files for examples, to discover that see if the "examples" folder has <code>.rs</code> files (examples files) or folders with <code>Cargo.toml</code> files inside (packages) )</p>
<h3 id="cargo-packages-command-example"><a class="header" href="#cargo-packages-command-example">Cargo packages command example</a></h3>
<p>This command is used for Rust programs that use package folders inside the repository for compilation, you need to use the name on the <code>name</code> field below the <code>[package]</code> section of the <code>Cargo.toml</code> file inside the package folder (generally using the same name of the program).</p>
<p>(This will fix the "found virtual manifest instead of package manifest" error)</p>
<pre><code class="language-toml">script = """
DYNAMIC_INIT
cookbook_cargo_packages program-name
"""
</code></pre>
<p>(You can use <code>cookbook_cargo_packages program1 program2</code> if it's more than one package)</p>
<h4 id="cargo-package-with-flags"><a class="header" href="#cargo-package-with-flags">Cargo package with flags</a></h4>
<p>If you need a script for a package with flags (customization), you can use this script:</p>
<pre><code class="language-toml">script = """
DYNAMIC_INIT
package=package-name
"${COOKBOOK_CARGO}" build \
            --manifest-path "${COOKBOOK_SOURCE}/Cargo.toml" \
            --package "${package}" \
            --release \
            --add-your-flag-here
        mkdir -pv "${COOKBOOK_STAGE}/usr/bin"
        cp -v \
            "target/${TARGET}/release/${package}" \
            "${COOKBOOK_STAGE}/usr/bin/${package}"
"""
</code></pre>
<ul>
<li>The <code>package-name</code> after <code>package=</code> is where you will insert the Cargo package name of your program.</li>
<li>The <code>--add-your-flag-here</code> will be replaced by the program flag.</li>
</ul>
<h3 id="cargo-bins-script-example"><a class="header" href="#cargo-bins-script-example">Cargo bins script example</a></h3>
<p>Some Rust programs use bins instead of packages to build, to build them you can use this script:</p>
<pre><code class="language-toml">script = """
DYNAMIC_INIT
binary=bin-name
"${COOKBOOK_CARGO}" build \
            --manifest-path "${COOKBOOK_SOURCE}/Cargo.toml" \
            --bin "${binary}" \
            --release \
            --add-your-flag-here
        mkdir -pv "${COOKBOOK_STAGE}/usr/bin"
        cp -v \
            "target/${TARGET}/release/${binary}" \
            "${COOKBOOK_STAGE}/usr/bin/${binary}"
"""
</code></pre>
<ul>
<li>The <code>bin-name</code> after <code>binary=</code> is where you will insert the Cargo package name of your program.</li>
<li>The <code>--add-your-flag-here</code> will be replaced by the program flags.</li>
</ul>
<h3 id="cargo-flags-command-example"><a class="header" href="#cargo-flags-command-example">Cargo flags command example</a></h3>
<p>Some Rust programs have flags for customization, you can find them below the <code>[features]</code> section in the <code>Cargo.toml</code> file.</p>
<pre><code class="language-toml">script = """
DYNAMIC_INIT
cookbook_cargo --features flag-name
"""
</code></pre>
<h3 id="disable-the-default-cargo-flags"><a class="header" href="#disable-the-default-cargo-flags">Disable the default Cargo flags</a></h3>
<p>It's common that some flag of the program doesn't work on Redox, if you don't want to spend much time testing flags that work and don't work, you can disable all of them to see if the most basic featureset of the program works with this script:</p>
<pre><code class="language-toml">script = """
DYNAMIC_INIT
cookbook_cargo --no-default-features
"""
</code></pre>
<h3 id="enable-all-cargo-flags"><a class="header" href="#enable-all-cargo-flags">Enable all Cargo flags</a></h3>
<p>If you want to enable all flags of the program, use:</p>
<pre><code class="language-toml">script = """
DYNAMIC_INIT
cookbook_cargo --all-features
"""
</code></pre>
<h3 id="cargo-profiles-command-example"><a class="header" href="#cargo-profiles-command-example">Cargo profiles command example</a></h3>
<p>This script is used for Rust programs using Cargo profiles.</p>
<pre><code class="language-toml">script = """
DYNAMIC_INIT
cookbook_cargo --profile profile-name
"""
</code></pre>
<h3 id="cargo-examples-command-example"><a class="header" href="#cargo-examples-command-example">Cargo examples command example</a></h3>
<p>This script is used for examples on Rust programs.</p>
<pre><code class="language-toml">script = """
DYNAMIC_INIT
cookbook_cargo_examples example-name
"""
</code></pre>
<p>(You can use <code>cookbook_cargo_examples example1 example2</code> if it's more than one example)</p>
<h4 id="cargo-examples-with-flags"><a class="header" href="#cargo-examples-with-flags">Cargo examples with flags</a></h4>
<p>This script is used for Cargo examples with flags.</p>
<pre><code class="language-toml">script = """
DYNAMIC_INIT
recipe="$(basename "${COOKBOOK_RECIPE}")"
    for example in example1 example2
    do
        "${COOKBOOK_CARGO}" build \
            --manifest-path "${COOKBOOK_SOURCE}/${PACKAGE_PATH}/Cargo.toml" \
            --example "${example}" \
            --release \
            --add-your-flag-here
        mkdir -pv "${COOKBOOK_STAGE}/usr/bin"
        cp -v \
            "target/${TARGET}/${build_type}/examples/${example}" \
            "${COOKBOOK_STAGE}/usr/bin/${recipe}_${example}"
    done
"""
</code></pre>
<p>(Replace the <code>example1</code> item and others with the example names, if the program has only one example you can remove the <code>example2</code> item)</p>
<h3 id="rename-binaries"><a class="header" href="#rename-binaries">Rename binaries</a></h3>
<p>Some programs or examples use generic names for their executable files which could cause conflicts in the package installation process, to avoid this use the following command after the compilation or installation commands:</p>
<pre><code class="language-sh">mv "${COOKBOOK_STAGE}/usr/bin/binary-name" "${COOKBOOK_STAGE}/usr/bin/new-binary-name"
</code></pre>
<ul>
<li>Duplicated names</li>
</ul>
<p>Some recipes for Rust programs can duplicate the program name in the executable (<code>name_name</code>), you can also use the command above to fix these cases.</p>
<h3 id="change-the-active-source-code-folder"><a class="header" href="#change-the-active-source-code-folder">Change the active source code folder</a></h3>
<p>Sometimes a program don't store the source code on the root of the Git repository, but in a subfolder.</p>
<p>For these cases you need to change the directory of the <code>${COOKBOOK_SOURCE}</code> environment variable in the beginning of the <code>build.script</code> data type, to do this add the following command on your recipe script:</p>
<pre><code class="language-sh">COOKBOOK_SOURCE="${COOKBOOK_SOURCE}/subfolder-name"
</code></pre>
<ul>
<li>An example for a Rust program:</li>
</ul>
<pre><code class="language-toml">script = """
DYNAMIC_INIT
COOKBOOK_SOURCE="${COOKBOOK_SOURCE}/subfolder-name"
cookbook_cargo
"""
</code></pre>
<h3 id="configuration-files"><a class="header" href="#configuration-files">Configuration Files</a></h3>
<p>Some programs require to setup configuration files from the source code or tarball, to setup them use the following script example:</p>
<pre><code class="language-toml">[build]
template = "custom"
script = """
DYNAMIC_INIT
cookbook build system function or custom build system commands
mkdir -pv "${COOKBOOK_STAGE}"/usr/share # create the /usr/share folder inside the package
cp -rv "${COOKBOOK_SOURCE}"/configuration-file "${COOKBOOK_STAGE}"/usr/share # copy the configuration file from the program source code to the package
"""
</code></pre>
<p>Modify the script above to your needs.</p>
<h3 id="script-based-programs"><a class="header" href="#script-based-programs">Script-based programs</a></h3>
<p>Read the following scripts to package interpreted programs.</p>
<h4 id="adapted-scripts"><a class="header" href="#adapted-scripts">Adapted scripts</a></h4>
<p>This script is for scripts adapted to be packaged, they contain shebangs and renamed the file to remove the script extension.</p>
<p>(Some programs and libraries need more configuration to work)</p>
<ul>
<li>One script</li>
</ul>
<pre><code class="language-toml">script = """
mkdir -pv "${COOKBOOK_STAGE}"/usr/bin
cp "${COOKBOOK_SOURCE}"/script-name "${COOKBOOK_STAGE}"/usr/bin/script-name
chmod a+x "${COOKBOOK_STAGE}"/usr/bin/script-name
"""
</code></pre>
<p>This script will move the script from the <code>source</code> folder to the <code>stage</code> folder and mark it as executable to be packaged.</p>
<p>(Probably you need to mark it as executable, we don't know if all scripts carry executable permission)</p>
<ul>
<li>Multiple scripts</li>
</ul>
<pre><code class="language-toml">script = """
mkdir -pv "${COOKBOOK_STAGE}"/usr/bin
cp "${COOKBOOK_SOURCE}"/* "${COOKBOOK_STAGE}"/usr/bin
chmod a+x "${COOKBOOK_STAGE}"/usr/bin/*
"""
</code></pre>
<p>This script will move the scripts from the <code>source</code> folder to the <code>stage</code> folder and mark them as executable to be packaged.</p>
<h4 id="non-adapted-scripts"><a class="header" href="#non-adapted-scripts">Non-adapted scripts</a></h4>
<p>You need to use the following script examples for scripts not adapted for packaging, you need to add shebangs, rename the file to remove the script extension (<code>.py</code>) and mark as executable (<code>chmod a+x</code>).</p>
<p>(Some programs and libraries need more configuration to work)</p>
<ul>
<li>Python script example</li>
</ul>
<pre><code class="language-toml">script = """
mkdir -pv "${COOKBOOK_STAGE}"/usr/bin
cp "${COOKBOOK_SOURCE}"/script-name.py "${COOKBOOK_STAGE}"/usr/bin/script-name
chmod a+x "${COOKBOOK_STAGE}"/usr/bin/script-name
"""
</code></pre>
<p>(Rename the "script-name" parts with your script name and the <code>.py</code> extension for your script programming language extension if needed)</p>
<p>This script will rename your script name, make it executable and package.</p>
<ul>
<li>Multiple scripts</li>
</ul>
<pre><code class="language-toml">script = """
mkdir -pv "${COOKBOOK_STAGE}"/usr/bin
for script in "${COOKBOOK_SOURCE}"/*
do
  shortname=`basename "$script" ".py"`
  cp -v "$script" "${COOKBOOK_STAGE}"/usr/bin/"$shortname"
  chmod a+x "${COOKBOOK_STAGE}"/usr/bin/"$shortname"
done
"""
</code></pre>
<p>This script will rename all scripts to remove the <code>.py</code> extension, mark all scripts as executable and package.</p>
<ul>
<li>Shebang</li>
</ul>
<p>It's the magic behind executable scripts as it make the system interpret the script as an common executable, if your script doesn't have a shebang on the beginning it can't be launched like an conventional compiled program executable.</p>
<p>To allow this use the following script:</p>
<pre><code class="language-toml">script = """
mkdir -pv "${COOKBOOK_STAGE}"/usr/bin
cp "${COOKBOOK_SOURCE}"/script-name.py "${COOKBOOK_STAGE}"/usr/bin/script-name
sed -i '1 i\#!/usr/bin/env python3' "${COOKBOOK_STAGE}"/usr/bin/script-name
chmod a+x "${COOKBOOK_STAGE}"/usr/bin/script-name
"""
</code></pre>
<p>The <code>sed -i '1 i\#!/usr/bin/env python3' "${COOKBOOK_STAGE}"/usr/bin/script-name</code> command will add the shebang on the beginning of your script.</p>
<p>The <code>python3</code> is the script interpreter in this case, use <code>bash</code> or <code>lua</code> or whatever interpreter is appropriate for your case.</p>
<p>There are many combinations for these script examples: you can download scripts without the <code>[source]</code> section, make customized installations, etc.</p>
<h3 id="dynamically-linked-programs"><a class="header" href="#dynamically-linked-programs">Dynamically Linked Programs</a></h3>
<p>The <code>DYNAMIC_INIT</code> acts as a marker that indicates the recipe can be dynamically linked. It automatically sets <code>LDFLAGS</code> and <code>RUSTFLAGS</code> based on the preferred linkage. See the environment variables section under configuration settings for more information.</p>
<p>In most cases if you want to use dynamic linking for a recipe just prepend <code>DYNAMIC_INIT</code> in the recipe script. Depending on the recipe, this <em>should</em> suffice. However, sometimes you <em>may</em> need to regenerate the GNU Autotools configuration, which you can do by invoking the <code>autotools_recursive_regenerate</code> helper function after <code>DYNAMIC_INIT</code> (See the examples below). This is to make sure the build system uses our <code>libtool</code> fork. In other cases, more recipe-specific modification may be required.</p>
<h4 id="ç¯„ä¾‹-1"><a class="header" href="#ç¯„ä¾‹-1">ç¯„ä¾‹</a></h4>
<pre><code class="language-diff"># &lt;...snip...&gt;

[build]
template = "custom"
script = """
+DYNAMIC_INIT
cookbook_configure
"""
</code></pre>
<pre><code class="language-diff"># &lt;...snip...&gt;
[source]
+script = """
+DYNAMIC_INIT
+autotools_recursive_regenerate
+"""

[build]
template = "custom"
script = """
+DYNAMIC_INIT
+cookbook_configure
"""
</code></pre>
<p>Dynamically linked programs depend on shared libraries at runtime. To include these libraries, you must add them in the <code>build.dependencies</code> data type.</p>
<h4 id="ç¯„ä¾‹-2"><a class="header" href="#ç¯„ä¾‹-2">ç¯„ä¾‹</a></h4>
<pre><code class="language-toml"># &lt;...snip...&gt;

[build]
dependencies = [
    "libmpc",
    "libgmp",
]
</code></pre>
<h3 id="ç–‘é›£æ’è§£-1"><a class="header" href="#ç–‘é›£æ’è§£-1">ç–‘é›£æ’è§£</a></h3>
<ul>
<li>Why the dynamic linker (<code>ld.so</code>) is not finding my library?</li>
</ul>
<p>Set <code>LD_DEBUG=all</code> and re-run the program. It will show you where library objects are being found and loaded, as well as the library search paths. You probably forgot to add a library in the <code>build.dependencies</code> list. You can also use <code>patchelf</code> on your host or on Redox to display all <code>DT_NEEDED</code> entries of an object (<code>patchelf --print-needed &lt;path&gt;</code>). It is available by default in the <code>desktop</code> variant.</p>
<h2 id="sources"><a class="header" href="#sources">Sources</a></h2>
<h3 id="tarballs"><a class="header" href="#tarballs">Tarballs</a></h3>
<p>Tarballs are the most easy way to build a C/C++ program or library because the build system is already configured (GNU Autotools is the most used), while being more fast to download and process than big Git repositories if shallow clone is not used (the system don't need to process many Git deltas).</p>
<p>Your <code>recipe.toml</code> will have the following content:</p>
<pre><code class="language-toml">[source]
tar = "tarball-link"
</code></pre>
<p>Copy the tarball link and paste in the <code>tarball-link</code> field.</p>
<p><strong>Only use official tarballs</strong>, GitHub auto-generate tarballs for each new release or tag of the program, but they <a href="https://github.blog/changelog/2023-01-30-git-archive-checksums-may-change/">aren't static</a> (break the checksum) and <a href="https://github.blog/2023-02-21-update-on-the-future-stability-of-source-code-archives-and-hashes/">don't verify the archive integrity</a>.</p>
<p>You can find the official tarballs in the release announcement assets with the program name and ending with <code>tar.gz</code> or <code>tar.xz</code> (their URLs contain "releases" instead of "archive"), while unstable tarballs can be found on the "Source code" buttons (their URLs contain "archive").</p>
<ul>
<li>In most cases they are created using the <a href="https://www.gnu.org/software/tar/">GNU Tar</a> tool.</li>
<li>Avoid files containing the names "linux" and "x86_64" on GitHub, they are pre-built binaries for some operating system and CPU architecture, not source code.</li>
<li>Some programs require Git submodules to work, you can't use tarballs if the official tarball don't bundle the submodules.</li>
<li>Archives with <code>tar.xz</code> and <code>tar.bz2</code> are preferred as they tend to have a higher compression level, thus smaller file size.</li>
</ul>
<h4 id="build-system-3"><a class="header" href="#build-system-3">Build System</a></h4>
<p>In most cases the tarballs use GNU Autotools to build, it's common that the tarball method of compilation is not well documented, causing confusion on new packagers.</p>
<p>To investigate, you can do the following things:</p>
<ul>
<li>Build with the <code>configure</code> template and see if it works (sometimes you need to use some flag or customize)</li>
<li>Search the Git repository of the program or library for <code>autogen.sh</code> and <code>configure.ac</code> files, it means that support for GNU Autotools is available, when some tarball is created, it comes with a <code>configure</code> file inside, this file doesn't exist on the Git repository and you need to create it by running the <code>autogen.sh</code> script.</li>
<li>Sometimes these files are available but GNU Autotools is deprecated (because it's old), we recommend that you use the supported build system (CMake or Meson in most cases).</li>
</ul>
<h4 id="links"><a class="header" href="#links">Links</a></h4>
<p>Sometimes it's hard to find the official tarball of some software, as each project website organization is different.</p>
<p>To help on this process, the <a href="https://archlinux.org/packages/">Arch Linux packages</a> and <a href="https://aur.archlinux.org/">AUR</a> are the most easy repositories to find tarball links in the configuration of packages.</p>
<ul>
<li>Arch Linux packages: Search for your program, open the program page, see the "Package Actions" category on the top right position and click on the "Source Files" button, a GitLab page will open, open the <code>.SRCINFO</code> and search for the tarball link on the "source" fields of the file.</li>
</ul>
<p>See the <a href="https://gitlab.archlinux.org/archlinux/packaging/packages/nano/-/blob/main/.SRCINFO?ref_type=heads#L12">nano package</a> example.</p>
<ul>
<li>AUR: Search for your program, open the program page, go to the "Sources" section on the end of the package details.</li>
</ul>
<h3 id="git-repositories"><a class="header" href="#git-repositories">Git Repositories</a></h3>
<p>Some programs don't offer official tarballs for releases, thus you need to use their Git repository and the branch of the latest stable version (if available) or pin the tag or commit hash of the latest stable version or last working commit.</p>
<p>Your <code>recipe.toml</code> will have the following content:</p>
<pre><code class="language-toml">[source]
git = "repository-link"
branch = "version-branch"
rev = "version-tag"
shallow_clone = true
</code></pre>
<ul>
<li>Shallow clone is not recommended if you forked the repository and is doing heavy development to port, if you don't want to change the recipe configuration after source fetch run the following command to disable shallow clone temporarily:</li>
</ul>
<pre><code>git fetch --unshallow
</code></pre>
<h4 id="github-release"><a class="header" href="#github-release">GitHub release</a></h4>
<p>Each GitHub release has a tag or commit hash, you will use it to pin the lastest stable version of the program to keep code stability.</p>
<p>Example:</p>
<ul>
<li>Open the <a href="https://github.com/rust-lang/rust/releases/tag/1.74.0">Rust 1.74 release announcement</a></li>
<li>The tag is <code>1.74.0</code> and the commit hash is <code>79e9716c980570bfd1f666e3b16ac583f0168962</code> and is shortened as <code>79e9716</code></li>
</ul>
<h4 id="gitlab-release-commit-hash"><a class="header" href="#gitlab-release-commit-hash">GitLab release commit hash</a></h4>
<p>Each GitLab release has a tag or commit hash, you will use it to pin the lastest stable version of the program to keep code stability.</p>
<p>Example:</p>
<ul>
<li>Open the <a href="https://gitlab.redox-os.org/redox-os/redox/-/releases/0.8.0">Redox 0.8.0 release announcement</a></li>
<li>The tag is <code>0.8.0</code> and the commit hash is <code>c8634bd9890afdac4438d1ff99631d600d469264</code> and is shortened as <code>c8634bd9</code></li>
</ul>
<h2 id="dependencies-1"><a class="header" href="#dependencies-1">Dependencies</a></h2>
<p>A program dependency can be a library (a program that offer functions to some program), a runtime (a program that satisfy some program dependency when it's executed) or a build tool (a program to configure/build some program).</p>
<p>Most C, C++ and Rust programs place build tools/runtime together with development libraries (packages with <code>-dev</code> suffix) in their build instructions documentation.</p>
<p>Example:</p>
<pre><code class="language-sh">sudo apt-get install cmake libssl-dev
</code></pre>
<p>The <code>cmake</code> package is the build system (build tool) while the <code>libssl-dev</code> package is the library (OpenSSL) linker objects (<code>.a</code> and <code>.so</code> files), the Debian package system bundle shared/static objects on their <code>-dev</code> packages (other Linux distributions just bundle shared objects).</p>
<p>You would need to create a recipe of the <code>libssl-dev</code> package and add in the <code>build.dependencies</code> data type of your <code>recipe.toml</code> file, while the <code>cmake</code> package would need the <code>cmake</code> Cookbook template.</p>
<p>Dependencies added in the <code>build.dependencies</code> data type can be dynamically linked (if the <code>DYNAMIC_INIT</code> function is used) or statically linked (if the <code>DYNAMIC_INIT</code> function is not used), while dependencies added in the <code>package.dependencies</code> data type will be installed by the build system installer or package manager.</p>
<p>Mixed Rust programs have crates ending with <code>-sys</code> to use bundled or system C/C++ libraries.</p>
<p>If you want an easy way to find dependencies, see the Debian stable <a href="https://packages.debian.org/stable/allpackages">packages list</a>.</p>
<p>You can search them with Ctrl+F, all package names are clickable and their websites is available on the right-side of the package description/details.</p>
<ul>
<li>We recommend to use the FreeBSD dependencies of the program if available because Linux dependencies tend to contain Linux-specific kernel features not available on Redox (unfortunately the FreeBSD package naming policy don't separate library objects/interpreters from build tools in all cases, thus you need to know or search each item to know if it's a library, interpreter or build tool)</li>
<li>Debian packages are the most easy way to find dependencies because they are the most used by software developers to describe "Build Instructions" dependencies.</li>
<li>Don't use the <code>.deb</code> packages to create recipes, they are adapted for the Debian environment.</li>
<li>The Debian naming policy use dashes as separators in packages with custom options (program or library variant) enabled (program-variant), check the source package to be sure</li>
<li>The recipe <code>PATH</code> environment variable only read build tool recipes declared in the <code>build.dev-dependencies</code> data type or the host system's <code>/usr/bin</code> directory, it can't read the <code>/usr/lib</code> and <code>/include</code> folders because the Linux library objects don't work on Redox.</li>
<li>The recipe support recursive dependencies, thus you don't need to specify a dependency two times if some dependency already provide it</li>
<li>Don't add build tools in the <code>build.dependencies</code> data type, check the <a href="https://packages.debian.org/stable/build-essential">Debian</a> and <a href="https://archlinux.org/packages/core/any/base-devel/">Arch Linux</a> meta-packages for a common reference of build tools.</li>
<li>The compiler will build the development libraries as <code>.a</code> files (objects for static linking) or <code>.so</code> files (objects for dynamic linking), the <code>.a</code> files will be mixed in the final binary while the <code>.so</code> files will be installed out of the binary (stored on the <code>/lib</code> directory of the system).</li>
<li>Linux distributions add a number after the <code>.so</code> files to avoid conflicts on the <code>/usr/lib</code> folder when packages use different API versions of the same library, for example: <code>library-name.so.6</code>.</li>
<li>You need to know this information because each software is different, the major reason is the "Build Instructions" organization of each program.</li>
</ul>
<p>If you have questions about program dependencies, feel free to ask us on the <a href="./chat.html">Chat</a>.</p>
<h3 id="bundled-libraries"><a class="header" href="#bundled-libraries">Bundled Libraries</a></h3>
<p>Some programs have bundled libraries, using CMake or a Python script, the most common case is using CMake (emulators do this in most cases).</p>
<p>The reason for this can be control over library versions to avoid compilation/runtime errors or a patched library with optimizations for specific tasks of the program.</p>
<p>In some cases some bundled library needs a Redox patch, if not it will give a compilation or runtime error.</p>
<p>Most programs using CMake will try to detect the system libraries on the build environment, if not they will use the bundled libraries.</p>
<p>The "system libraries" on this case is the recipes specified on the <code>build.dependencies = []</code> section of your <code>recipe.toml</code>.</p>
<p>To determine if you need to use a Redox recipe as dependency check if you find a <code>.patch</code> file on the recipe folder or if the <code>recipe.toml</code> has a <code>git =</code> field pointing to the Redox GitLab, if not you can probably use the bundled libraries without problems.</p>
<p>Generally programs with CMake use a <code>-DUSE_SYSTEM</code> flag to enable the "system libraries" behavior.</p>
<h3 id="environment-variables-3"><a class="header" href="#environment-variables-3">Environment Variables</a></h3>
<p>Sometimes specify the library recipe on the <code>dependencies = []</code> section is not enough, some build systems have environment variables to receive a custom path for external libraries.</p>
<p>When you add a library on your <code>recipe.toml</code> the Cookbook will copy the library source code to the <code>sysroot</code> folder at <code>recipes/your-category/recipe-name/target/your-target</code>, this folder has an environment variable that can be used inside the <code>script =</code> field on your <code>recipe.toml</code>.</p>
<p>Example:</p>
<pre><code class="language-toml">script = """
export OPENSSL_DIR="${COOKBOOK_SYSROOT}"
cookbook_cargo
"""
</code></pre>
<p>The <code>export</code> will active the <code>OPENSSL_DIR</code> variable on the environment, this variable is implemented by the program build system, it's a way to specify the custom OpenSSL path to the program's build system, as you can see, when the <code>Ã²penssl</code> recipe is added to the <code>dependencies = []</code> section its sources go to the <code>sysroot</code> folder.</p>
<p>Now the program build system is satisfied with the OpenSSL sources, the <code>cookbook_cargo</code> function calls Cargo to build it.</p>
<p>Programs using CMake don't use environment variables but an option, see this example:</p>
<pre><code class="language-toml">script = """
COOKBOOK_CMAKE_FLAGS+=(
    -DOPENSSL_ROOT_DIR="${COOKBOOK_SYSROOT}"
)
cookbook_cmake
"""
</code></pre>
<p>On this example the <code>-DOPENSSL_ROOT_DIR</code> option will have the custom OpenSSL path.</p>
<h3 id="submodules"><a class="header" href="#submodules">Submodules</a></h3>
<p>In some programs or libraries you can't use tarballs because they don't carry the necessary Git submodules of the program (most common in GitHub generated tarballs), on these cases you will need to use the Git repository or the commit of the last stable release (Cookbook download the submodules automatically).</p>
<p>To identify if the program use Git submodules, check if it have external folders to other repository (they appear with a commit hash on the right side) or the existence of a <code>.gitmodules</code> file.</p>
<p>Follow these steps to use the last stable version of the program when Git submodules are necessary:</p>
<ul>
<li>Open the program/library Git repository.</li>
<li>Check the "Releases" or "Tags" buttons, in most cases the program have a stable release at "Releases".</li>
<li>In both pages the commit hash of the stable release will be the first item of the announcement below the version number.</li>
<li>Copy the repository link/version branch or tag and paste on your <code>recipe.toml</code>, for example:</li>
</ul>
<pre><code class="language-toml">git = "repository-link"
branch = "version-branch"
rev = "version-tag"
</code></pre>
<p>If the last stable release is too old or lack important fixes due to low maintenance we recommend that you ignore it and use the Git repository to download/build bug fixes sent after this old version, if you are concerned about the program upstream breaking the recipe, you can use the commit of the last successful CI test.</p>
<h3 id="configuration-1"><a class="header" href="#configuration-1">Configuration</a></h3>
<p>The determine the program dependencies you can use Arch Linux and Gentoo as reference.</p>
<ul>
<li>The build instructions of C/C++ programs tend to mix necessary and optional dependencies together.</li>
<li>Most Rust programs have build instructions focused on Linux and force some dependencies, some crates could not need them to work, investigate which crates the program is using.</li>
<li>Some programs and libraries have bad documentation, lack build instructions or explain the dependencies, for these cases you will need to read third-party sources or examine the build system.</li>
</ul>
<p>Arch Linux and AUR are the most simple references because they separate the build tools from runtimes and build dependencies, thus you make less mistakes.</p>
<p>They also have less expanded packages, while on Debian is common to have highly expanded programs and libraries, sometimes causing confusion.</p>
<p>(An expanded package is when most or all optional dependencies are enabled)</p>
<p>But Arch Linux is not clear about the optional feature flags and minimum dependencies to build and execute a program.</p>
<p>Using Gentoo as reference you can learn how to make the most minimum Redox port and increase your chances to make it work on Redox.</p>
<p>But Gentoo modify the feature flags of their packages to be used by their package system, thus you should use the FreeBSD Ports.</p>
<h4 id="arch-linux-and-aur"><a class="header" href="#arch-linux-and-aur">Arch Linux and AUR</a></h4>
<p>Each package page of some program has a "Dependencies" section on the package details, see the items below:</p>
<ul>
<li><code>dependency-name</code> - Build or runtime dependencies, they lack the <code>()</code> symbol (required to make the program build and execute)</li>
<li><code>dependency-name (make)</code> - Build tools (required to build the program)</li>
<li><code>dependency-name (optional)</code> - Programs or libraries to expand the program functionality</li>
</ul>
<p>See the <a href="https://archlinux.org/packages/extra/x86_64/firefox/">firefox package</a>, for example.</p>
<ul>
<li><a href="https://archlinux.org/packages/">Arch Linux Packages</a></li>
<li><a href="https://aur.archlinux.org/">AUR</a></li>
</ul>
<h4 id="gentoo"><a class="header" href="#gentoo">Gentoo</a></h4>
<p>The <a href="https://gentoo.org">Gentoo</a> distribution does a wonderful job to document many programs and libraries, like source code location, dependencies, feature flags, cross-compilation and context.</p>
<p>It's the most complete reference for advanced packaging of programs, you can search the Gentoo packages on the <a href="https://packages.gentoo.org/">Gentoo Packages</a> website.</p>
<p>To start you need to read the <a href="https://devmanual.gentoo.org/general-concepts/dependencies/">Gentoo documentation</a> page to learn advanced packaging and some problems.</p>
<p>The "Dependencies" section of a Gentoo package will show a table with the following categories:</p>
<ul>
<li><code>BDEPEND</code> - Host build tools (don't add them on the <code>dependencies = []</code> section of your <code>recipe.toml</code>)</li>
<li><code>DEPEND</code> - These dependencies are necessary to build the program</li>
<li><code>RDEPEND</code> - These dependencies are necessary to execute the program, can be mandatory or optional</li>
<li><code>PDEPEND</code> - Optional dependencies (customization)</li>
</ul>
<p>The complex classification of Gentoo allow the packager to easily make a minimum build of a program on Redox, it's important because some optional dependencies can use APIs from the Linux kernel not present on Redox.</p>
<p>Thus the best approach is to know the minimum necessary to make the program work on Redox and expand from that.</p>
<h3 id="build-tools"><a class="header" href="#build-tools">Build Tools</a></h3>
<p>Add missing recipe build tools in the <a href="https://gitlab.redox-os.org/redox-os/redox/-/blob/master/podman/redox-base-containerfile">podman/redox-base-containerfile</a> file (for Podman builds) or install them on your system (for Native builds).</p>
<p>The <code>podman/redox-base-containerfile</code> file and <code>native_bootstrap.sh</code> script covers the build tools required by recipes on the <a href="https://gitlab.redox-os.org/redox-os/redox/-/blob/master/config/x86_64/demo.toml">demo.toml</a> filesystem configuration.</p>
<h2 id="feature-flags"><a class="header" href="#feature-flags">Feature Flags</a></h2>
<p>The program/library build systems offer flags to enable/disable features, it will increase the chance to make them work on Redox by disabling Linux-specific or unsupported features/libraries.</p>
<p>Sometimes you need to read the build system configuration to find important or all flags that weren't documented by the program.</p>
<h3 id="cargo"><a class="header" href="#cargo">Cargo</a></h3>
<p>You can find the feature flags below the <code>[features]</code> section in the <code>Cargo.toml</code> file.</p>
<h3 id="gnu-autotools"><a class="header" href="#gnu-autotools">GNU Autotools</a></h3>
<p>You can find the feature flags in the <code>INSTALL</code>, <code>README</code> or <code>configure</code> files.</p>
<h3 id="cmake"><a class="header" href="#cmake">CMake</a></h3>
<p>You can find the feature flags in the <code>CMakeLists.txt</code> file.</p>
<h3 id="meson"><a class="header" href="#meson">Meson</a></h3>
<p>You can find the feature flags in the <code>meson_options</code> file.</p>
<h3 id="freebsd-reference"><a class="header" href="#freebsd-reference">FreeBSD Reference</a></h3>
<p>If you can't find the program build system flags the FreeBSD port Makefiles are the best reference for feature flags to Redox as they tend to disable Linux-specific features and are adapted to cross-compilation, increasing the program/library compatiblity with non-Linux systems.</p>
<p>(You need to disable the program/library's build system tests to make cross-compilation work)</p>
<ul>
<li><a href="https://github.com/freebsd/freebsd-ports">FreeBSD Ports GitHub Mirror</a></li>
</ul>
<p>(Use the "Go to file" button to search for the software name)</p>
<h2 id="buildingtesting-the-program"><a class="header" href="#buildingtesting-the-program">Building/Testing The Program</a></h2>
<p>Tip: If you want to avoid problems not related to Redox install the program dependencies and build to your system first (if packages for your Unix-like distribution aren't available search for Debian/Ubuntu equivalents).</p>
<p>To build your recipe, run:</p>
<pre><code class="language-sh">make r.recipe-name
</code></pre>
<p>If you get an error read the log and determine if it is one of the following problems:</p>
<ul>
<li>Missing build tools</li>
<li>Cross-compilation configuration problem</li>
<li>Lack of Redox patches</li>
<li>Missing C, POSIX or Linux library functions in relibc</li>
</ul>
<p>Use this command to log any possible errors on your terminal output:</p>
<pre><code class="language-sh">make r.recipe-name 2&gt;&amp;1 | tee recipe-name.log
</code></pre>
<p>If the compilation was successful the recipe can be installed in the QEMU image and tested inside of Redox to find possible runtime errors or crashes.</p>
<ul>
<li>To temporarily install the recipe to your QEMU image run <code>make p.recipe-name</code></li>
<li>To permanently install the recipe to your QEMU image add your recipe name (<code>recipe-name = {}</code>) below the last item in the <code>[packages]</code> section of your TOML config at <code>config/your-cpu-arch/your-config.toml</code> and run <code>make image</code></li>
</ul>
<p>To test your recipe inside of Redox with Orbital, run:</p>
<pre><code class="language-sh">make qemu
</code></pre>
<p>If you only want to test in the Redox terminal interface, run:</p>
<pre><code class="language-sh">make qemu gpu=no
</code></pre>
<h2 id="update-crates-3"><a class="header" href="#update-crates-3">Update crates</a></h2>
<p>Sometimes the <code>Cargo.toml</code> and <code>Cargo.lock</code> of some Rust programs can hold a crate versions lacking Redox support or a broken Redox code path (changes on code that make the target OS fail), this will give you an error during the recipe compilation.</p>
<ul>
<li>The reason of fixed crate versions is explained on the <a href="https://doc.rust-lang.org/cargo/faq.html#why-do-binaries-have-cargolock-in-version-control-but-not-libraries">Cargo FAQ</a>.</li>
</ul>
<p>To fix this you will need to update the crates of your recipe after the first compilation and build it again, see the ways to do it below.</p>
<p>(Bump a crate version on <code>Cargo.toml</code> can break some part of the source code, on this case the program needs a source code patch to use the updated API of the crate)</p>
<h3 id="one-or-more-crates"><a class="header" href="#one-or-more-crates">One or more crates</a></h3>
<p>In maintained Rust programs you just need to update some crates to have Redox support (because they frequently update the crate versions), this will avoid random breaks on the dependency chain of the program (due to ABI changes) thus you can update one or more crates to reduce the chance of breaks.</p>
<p>We recommend that you do this based on the errors you get during the compilation, this method is recommended for maintained programs.</p>
<ul>
<li>Expose the Redox build system environment variables to the current shell, go to the <code>source</code> folder of your recipe and update the crates, example:</li>
</ul>
<pre><code class="language-sh">make env
</code></pre>
<pre><code class="language-sh">cd recipes/your-category/recipe-name/source
</code></pre>
<pre><code class="language-sh">cargo update -p crate1 crate2
</code></pre>
<pre><code class="language-sh">cd -
</code></pre>
<pre><code class="language-sh">make r.recipe-name
</code></pre>
<p>If you still get the error, run:</p>
<pre><code class="language-sh">make cr.recipe-name
</code></pre>
<h3 id="all-crates"><a class="header" href="#all-crates">All crates</a></h3>
<p>Most unmaintained Rust programs carry very old crate versions with lacking/broken Redox support, this method will update all crates of the dependency chain to the latest possible version based on the <code>Cargo.toml</code> configuration.</p>
<p>Be aware that some crates break the API stability frequently and make the programs stop to work, that's why you must try the "One crate" method first.</p>
<ul>
<li>This method can fix locked crate versions on the dependency tree, if these locked crate versions don't change you need to bump the version of the crates locking the crate version, you will edit them in the <code>Cargo.toml</code> and run <code>cargo update</code> again (API breaks are expected).</li>
</ul>
<p>(Also good to test the latest improvements of the libraries)</p>
<ul>
<li>Expose the Redox build system environment variables to the current shell, go to the <code>source</code> folder of your recipe and update the crates, example:</li>
</ul>
<pre><code class="language-sh">make env
</code></pre>
<pre><code class="language-sh">cd recipes/your-category/recipe-name/source
</code></pre>
<pre><code class="language-sh">cargo update
</code></pre>
<pre><code class="language-sh">cd -
</code></pre>
<pre><code class="language-sh">make r.recipe-name
</code></pre>
<p>If you still get the error, run:</p>
<pre><code class="language-sh">make cr.recipe-name
</code></pre>
<h3 id="verify-the-dependency-tree-1"><a class="header" href="#verify-the-dependency-tree-1">Verify the dependency tree</a></h3>
<p>If you use the above methods but the program is still using old crate versions, see this section:</p>
<ul>
<li><a href="./troubleshooting.html#verify-the-dependency-tree">Verify the dependency tree</a></li>
</ul>
<h2 id="patch-crates"><a class="header" href="#patch-crates">Patch crates</a></h2>
<h3 id="redox-forks"><a class="header" href="#redox-forks">Redox forks</a></h3>
<p>It's possible that some not ported crate have a Redox fork with patches, you can search the crate name on the <a href="https://gitlab.redox-os.org/">Redox GitLab</a>, generally the Redox patches stay in the <code>redox</code> branch or <code>redox-version</code> branch that follow the crate version.</p>
<p>To use this Redox fork on your Rust program, add this text on the end of the <code>Cargo.toml</code> in the program source code:</p>
<pre><code class="language-toml">[patch.crates-io]
crate-name = { git = "repository-link", branch = "redox" }
</code></pre>
<p>It will make Cargo replace the patched crate in the entire dependency chain, after that, run:</p>
<pre><code class="language-sh">make r.recipe-name
</code></pre>
<p>Or (if the above doesn't work)</p>
<pre><code class="language-sh">make cr.recipe-name
</code></pre>
<p>Or</p>
<pre><code class="language-sh">make env
</code></pre>
<pre><code class="language-sh">cd recipes/your-category/recipe-name/source
</code></pre>
<pre><code class="language-sh">cargo update -p crate-name
</code></pre>
<pre><code class="language-sh">cd -
</code></pre>
<pre><code class="language-sh">make r.recipe-name
</code></pre>
<p>If you still get the error, run:</p>
<pre><code class="language-sh">make cr.recipe-name
</code></pre>
<h3 id="local-patches"><a class="header" href="#local-patches">Local patches</a></h3>
<p>If you want to patch some crate offline with your patches, add this text on the <code>Cargo.toml</code> of the program:</p>
<pre><code class="language-toml">[patch.crates-io]
crate-name = { path = "patched-crate-folder" }
</code></pre>
<p>It will make Cargo replace the crate based on this folder in the program source code - <code>recipes/your-category/your-recipe/source/patched-crate-folder</code> (you don't need to manually create this folder if you <code>git clone</code> the crate source code on the program source directory)</p>
<p>Inside this folder you will apply the patches on the crate source and rebuild the recipe.</p>
<h2 id="cleanup"><a class="header" href="#cleanup">Cleanup</a></h2>
<p>If you have some problems (outdated recipe), try to run these commands:</p>
<ul>
<li>This command will delete your old recipe source/binary.</li>
</ul>
<pre><code class="language-sh">make u.recipe-name
</code></pre>
<ul>
<li>This command will delete your recipe binary/source and build (fresh build).</li>
</ul>
<pre><code class="language-sh">make ur.recipe-name
</code></pre>
<h2 id="search-text-on-recipes"><a class="header" href="#search-text-on-recipes">Search Text on Recipes</a></h2>
<p>To speed up your porting workflow you can use the <code>grep</code> tool to search the recipe configuration:</p>
<pre><code class="language-sh">cd recipes
</code></pre>
<pre><code class="language-sh">grep -rnwi "text" --include "recipe.toml"
</code></pre>
<p>This command will search all match texts in the <code>recipe.toml</code> files of each recipe folder.</p>
<h2 id="search-for-functions-on-relibc"><a class="header" href="#search-for-functions-on-relibc">Search for functions on relibc</a></h2>
<p>Sometimes your program is not building because relibc lack the necessary functions, to verify if they are implemented run the following commands:</p>
<pre><code class="language-sh">cd relibc
</code></pre>
<pre><code class="language-sh">grep -nrw "function-name" --include "*.rs"
</code></pre>
<p>You will insert the function name in <code>function-name</code></p>
<h2 id="create-a-blake3-hash-for-your-recipe"><a class="header" href="#create-a-blake3-hash-for-your-recipe">Create a BLAKE3 hash for your recipe</a></h2>
<p>You need to create a BLAKE3 hash of your recipe tarball if you want to merge it on upstream, to do this you can use the <code>b3sum</code> tool that can be installed from <code>crates.io</code> with the <code>cargo install b3sum</code> command.</p>
<p>After the first run of the <code>make r.recipe-name</code> command, run these commands:</p>
<pre><code class="language-sh">b3sum recipes/your-category/recipe-name/source.tar
</code></pre>
<p>It will print the generated BLAKE3 hash, copy and paste on the <code>blake3 =</code> field of your <code>recipe.toml</code></p>
<h2 id="verify-the-size-of-your-package"><a class="header" href="#verify-the-size-of-your-package">Verify the size of your package</a></h2>
<p>To verify the size of your package use this command:</p>
<pre><code class="language-sh">ls -1sh recipes/your-category/recipe-name/target/your-target
</code></pre>
<p>See the size of the <code>stage.pkgar</code> and <code>stage.tar.gz</code> files.</p>
<h2 id="submitting-mrs"><a class="header" href="#submitting-mrs">Submitting MRs</a></h2>
<p>If you want to add your recipe on the <a href="https://gitlab.redox-os.org/redox-os/redox">build system</a> to become a Redox package on the <a href="https://static.redox-os.org/pkg/">build server</a>, read the <a href="porting-applications.html#package-policy">package policy</a> below.</p>
<p>After this you can submit your merge request with proper category, dependencies and comments.</p>
<h3 id="package-policy"><a class="header" href="#package-policy">Package Policy</a></h3>
<p>Before sending your recipe to upstream (to become a public package), you must follow these rules:</p>
<h4 id="naming"><a class="header" href="#naming">Naming</a></h4>
<ul>
<li>The recipe name can't have dots, backslashes, and NULs</li>
</ul>
<h4 id="cross-compilation-2"><a class="header" href="#cross-compilation-2">Cross-Compilation</a></h4>
<ul>
<li>All recipes must use our cross-compilers, a Cookbook <a href="porting-applications.html#templates">template</a> does this automatically but it's not always possible, study the build system of your program or library to find these options or patch the configuration files.</li>
<li>Don't hardcode the CPU architecture on the recipe script (this would break the multi-arch support).</li>
</ul>
<h4 id="tarballs-1"><a class="header" href="#tarballs-1">Tarballs</a></h4>
<ul>
<li>Don't use the auto-generated tarballs from GitHub, they aren't static and don't verify the archive integrity.</li>
</ul>
<h4 id="api-compatibility"><a class="header" href="#api-compatibility">API Compatibility</a></h4>
<ul>
<li>Respect the API compatibility of C/C++ libraries, for example: if <code>openssl1</code> is available and some program need <code>openssl3</code>, you will create a recipe for <code>openssl3</code> and not rename the <code>openssl1</code>, as it will break the dependent packages.</li>
</ul>
<p>(Read <a href="./developer-faq.html#why-cc-programs-and-libraries-are-hard-and-time-consuming-to-port">this</a> section to know why it's needed)</p>
<h4 id="checksum"><a class="header" href="#checksum">Checksum</a></h4>
<ul>
<li>If your recipe download a tarball, you will need to create a BLAKE3 hash for it. You can learn how to do it <a href="porting-applications.html#create-a-blake3-hash-for-your-recipe">here</a>.</li>
</ul>
<h4 id="license"><a class="header" href="#license">License</a></h4>
<ul>
<li>Don't package programs or libraries lacking a license.</li>
<li>Verify if the program has some license violation, in case of doubt ask us on the <a href="https://doc.redox-os.org/book/chat.html">chat</a>.</li>
<li>Non-free programs and assets should go to a subcategory of the <code>nonfree</code> category and be approved per license.</li>
</ul>
<h3 id="testing-area"><a class="header" href="#testing-area">Testing Area</a></h3>
<p>Work-in-progress software ports goes to the <code>wip</code> category, be aware of these items during your packaging process:</p>
<ul>
<li>A recipe is considered ready if it's mostly working inside of Redox.</li>
<li>All WIP recipes must have a <code>#TODO</code> on the beginning of the <code>recipe.toml</code> and explain what is missing.</li>
<li>BLAKE3 hashes for tarballs are optional (quick testing workflow)</li>
<li>Try to keep the recipe with the latest stable version of the program (the porting process can take months).</li>
<li>Once the recipe is ready, add the BLAKE3 hash if needed and move the folder to the appropriate category.</li>
</ul>
<h4 id="suggestions-for-todos"><a class="header" href="#suggestions-for-todos">Suggestions for TODOs</a></h4>
<p>These TODOs improve the packagers cooperation and understanding.</p>
<ul>
<li><code>not compiled or tested</code> - It means that your recipe may be fully or partially configured and with necessary dependencies.</li>
<li><code>missing script for x: insert-the-link-for-build-instructions-here</code> - It means that your recipe is lacking the cross-compilation script for some build system, where <code>x</code> is the build system name. After <code>:</code> you will insert the link for the build instructions of the program or library, it will help other packagers to create the script for you.</li>
<li><code>missing dependencies: insert-the-link-for-required-dependencies-here</code> - It means that the <code>build.dependencies</code> or <code>package.dependencies</code> data types are incomplete.</li>
<li><code>probably wrong script: insert-the-link-for-build-instructions-here</code> - It means that you don't know yet if your script is working.</li>
<li><code>probably wrong template: insert-the-link-for-build-instructions-here</code> - It means that you don't know yet if the Cookbook template is working.</li>
<li><code>probably missing dependencies: insert-the-link-for-required-dependencies-here</code> - It means that you don't know yet if the required dependencies are satisfied.</li>
<li><code>promote</code> - It means that the recipe is working and should be moved to the equivalent category at <code>recipes/*</code></li>
</ul>
<p>Other TODOs are specific and won't be covered on this list.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="porting-case-study"><a class="header" href="#porting-case-study">Porting Case Study</a></h1>
<p>As a non-trivial example of porting a Rust app, let's look at what was done to port <a href="https://github.com/Byron/gitoxide">gitoxide</a>. This port was already done, so it is now much simpler, but perhaps some of these steps will apply to you.</p>
<p>The goal when porting is to capture all the necessary configuration in recipes and scripts, and to avoid requiring a fork of the program repository or upstreaming changes. This is not always feasible, but forking/upstreaming should be avoided when it can be.</p>
<h2 id="build-on-linux"><a class="header" href="#build-on-linux">Build on Linux</a></h2>
<p>Before we start, we need to build the software for our Linux system and make sure it works. This is not part of the porting, it's just to make sure our problems are not coming from the Linux version of the software. We follow the normal build instructions for the software we are porting:</p>
<pre><code class="language-sh">cd ~
</code></pre>
<pre><code class="language-sh">git clone https://github.com/Byron/gitoxide.git
</code></pre>
<pre><code class="language-sh">cd gitoxide
</code></pre>
<pre><code class="language-sh">cargo run --bin ein
</code></pre>
<h2 id="set-up-the-working-tree"><a class="header" href="#set-up-the-working-tree">Set up the working tree</a></h2>
<p>We start with a fresh clone of the Redox repository. In a Terminal/Console/Command window:</p>
<pre><code class="language-sh">mkdir -p ~/redox-gitoxide
</code></pre>
<pre><code class="language-sh">cd ~/redox-gitoxide
</code></pre>
<pre><code class="language-sh">git clone https://gitlab.redox-os.org/redox-os/redox --origin upstream
</code></pre>
<p>The new recipe will be part of the <code>redox</code> repository, so we need to fork then branch it. To fork the <code>redox</code> repository:</p>
<ul>
<li>In the browser, go to the <a href="https://gitlab.redox-os.org/redox-os/redox">build system</a></li>
<li>Click the <code>Fork</code> button in the upper right part of the page</li>
<li>Create a <code>public</code> fork under your GitLab user name (it's the only option that's enabled)</li>
</ul>
<p>Then we need to set up our local <code>redox</code> repository and create the branch:</p>
<pre><code class="language-sh">cd ~/redox-gitoxide/redox
</code></pre>
<pre><code class="language-sh">git remote rename origin upstream
</code></pre>
<pre><code class="language-sh">git rebase upstream master
</code></pre>
<pre><code class="language-sh">git remote add origin https://gitlab.redox-os.org/MY_USERNAME/redox
</code></pre>
<pre><code class="language-sh">git checkout -b gitoxide-port
</code></pre>
<h2 id="create-a-recipe"><a class="header" href="#create-a-recipe">Create a Recipe</a></h2>
<p>To create a recipe, we need to make a new directory in <code>recipes</code> with the name the package will have, in this case <code>gitoxide</code>, and create a <code>recipe.toml</code> file with a first-draft recipe.</p>
<pre><code class="language-sh">mkdir -p ~/redox-gitoxide/redox/recipes/gitoxide
</code></pre>
<pre><code class="language-sh">nano ~/redox-gitoxide/redox/recipes/gitoxide/recipe.toml
</code></pre>
<p>Start with the following content in the <code>recipe.toml</code> file.</p>
<pre><code class="language-toml">[source]
git = "https://github.com/Byron/gitoxide"
[build]
template = "cargo"
</code></pre>
<h2 id="first-attempt"><a class="header" href="#first-attempt">First Attempt</a></h2>
<p>Next we attempt to build the recipe. Note that the first attempt may require the Redox toolchain to be updated, so we run <code>make prefix</code>, which may take quite a while.</p>
<pre><code class="language-sh">cd ~/redox-gitoxide/redox
</code></pre>
<pre><code class="language-sh">make prefix
</code></pre>
<pre><code class="language-sh">make r.gitoxide |&amp; tee gitoxide.log
</code></pre>
<p>We get our first round of errors (among other messages):</p>
<pre><code>error[E0425]: cannot find value `POLLRDNORM` in crate `libc`
error[E0425]: cannot find value `POLLWRBAND` in crate `libc`
</code></pre>
<h2 id="make-a-local-copy-of-libc"><a class="header" href="#make-a-local-copy-of-libc">Make a Local Copy of libc</a></h2>
<p>We suspect the problem is that these items have not been defined in the Redox edition of <code>libc</code>. <code>libc</code> is not a Redox crate, it is a rust-lang crate, but it has parts that are Redox-specific. We need to work with a local copy of <code>libc</code>, and then later ask someone with authority to upstream the required changes.</p>
<p>First, clone <code>libc</code> into our <code>gitoxide</code> directory.</p>
<pre><code class="language-sh">cd ~/redox-gitoxide/redox/recipes/gitoxide
</code></pre>
<pre><code class="language-sh">git clone https://github.com/rust-lang/libc.git
</code></pre>
<p>Try to find the missing constants.</p>
<pre><code class="language-sh">cd ~/redox-gitoxide/redox/recipes/gitoxide/libc
</code></pre>
<pre><code class="language-sh">grep -nrw "POLLRDNORM" --include "*.rs"
</code></pre>
<pre><code class="language-sh">grep -nrw "POLLWRBAND" --include "*.rs"
</code></pre>
<p>Looks like the value is not defined for the Redox version of <code>libc</code>. Let's see if it's in <code>relibc</code>.</p>
<pre><code class="language-sh">cd ~/redox-gitoxide/redox/recipes/core/relibc
</code></pre>
<pre><code class="language-sh">grep -nrw "POLLRDNORM" --include "*.rs"
</code></pre>
<pre><code class="language-sh">grep -nrw "POLLWRBAND" --include "*.rs"
</code></pre>
<p>Yes, both are already defined in <code>relibc</code>, and after a bit of poking around, it looks like they have an implementation. They just need to get published in <code>libc</code>. Let's do that.</p>
<h2 id="make-changes-to-libc"><a class="header" href="#make-changes-to-libc">Make Changes to libc</a></h2>
<p>Let's add our constants to our local <code>libc</code>. We are not going to bother with <code>git</code> because these changes are just for debugging purposes. Copy the constant declarations from <code>relibc</code>, and paste them in the appropriate sections of <code>libc/src/unix/redox/mod.rs</code>. In addition to copying the constants, we have to change the type <code>c_short</code> to <code>::c_short</code> to conform to <code>libc</code> style.</p>
<pre><code class="language-sh">cd ~/redox-gitoxide/redox/recipes/gitoxide
</code></pre>
<pre><code class="language-sh">nano libc/src/unix/redox/mod.rs
</code></pre>
<p>We add the following lines to <code>mod.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub const POLLRDNORM: ::c_short = 0x040;
pub const POLLRDBAND: ::c_short = 0x080;
pub const POLLWRNORM: ::c_short = 0x100;
pub const POLLWRBAND: ::c_short = 0x200;
<span class="boring">}</span></code></pre></pre>
<p>In order to test our changes, we will have to modify our <code>gitoxide</code> clone for now. Once the changes to <code>libc</code> are upstreamed, we won't need a modified <code>gitoxide</code> clone. To avoid overwriting our work, we want to turn off future fetches of the <code>gitoxide</code> source during build, so change <code>recipe.toml</code> to comment out the source section: <code>nano recipe.toml</code>.</p>
<pre><code class="language-toml">#[source]
#git = "https://github.com/Byron/gitoxide"
[build]
template = "cargo"
</code></pre>
<p>We edit <code>gitoxide</code>'s <code>Cargo.toml</code> so we use our <code>libc</code>.</p>
<pre><code>nano ~/redox-gitoxide/recipes/gitoxide/source/Cargo.toml
</code></pre>
<p>After the <code>[dependencies]</code> section, but before the <code>[profile]</code> sections, add the following to <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[patch.crates-io]
libc = { path = "../libc" }
</code></pre>
<p>Bump the version number on our <code>libc</code>, so it will take priority.</p>
<pre><code>nano ~/redox-gitoxide/recipes/gitoxide/libc/Cargo.toml
</code></pre>
<pre><code class="language-toml">version = "0.2.143"
</code></pre>
<p>Update <code>gitoxide</code>'s <code>Cargo.lock</code>.</p>
<pre><code class="language-sh">cd ~/redox-gitoxide/redox/recipes/gitoxide/source
</code></pre>
<pre><code class="language-sh">cargo update
</code></pre>
<p>Make sure we have saved all the files we just edited, and let's try building.</p>
<pre><code class="language-sh">cd ~/redox-gitoxide/redox
</code></pre>
<pre><code class="language-sh">make r.gitoxide
</code></pre>
<p>Our <code>libc</code> errors are solved! Remember, these changes will need to upstreamed by someone with the authority to make changes to <code>libc</code>. Post a request on the chat's <a href="https://matrix.to/#/#redox-mrs:matrix.org">Redox OS/MRs</a> room to add the constants to <code>libc</code>.</p>
<h2 id="creating-a-custom-recipe"><a class="header" href="#creating-a-custom-recipe">Creating a Custom Recipe</a></h2>
<p>In looking at what is included in <code>gitoxide</code>, we see that it uses <a href="https://docs.rs/openssl/latest/openssl/">OpenSSL</a>, which has some custom build instructions described in the docs. There is already a Redox fork of <code>openssl</code> to add Redox as a target, so we will set up our environment to use that.</p>
<p>In order to do this, we are going to need a custom recipe. Let's start with a simple custom recipe, just to get us going. Edit our previously created recipe, <code>recipes/gitoxide/recipe.toml</code>, changing it to look like this.</p>
<pre><code class="language-toml">#[source]
#git = "https://github.com/Byron/gitoxide.git"
[build]
template = "custom"
script = """
printenv
"""
</code></pre>
<p>In this version of our recipe, we are just going to print the environment variables during <code>cook</code>, so we can see what we might make use of in our custom script. We are not actually attempting to build <code>gitoxide</code>. Now, when we run <code>make r.gitoxide</code> in <code>~/redox-gitoxide/redox</code>, we see some useful variables such as <code>TARGET</code> and <code>COOKBOOK_ROOT</code>.</p>
<p>Two key shell functions are provided by the custom script mechanism, <code>cookbook_cargo</code> and <code>cookbook_configure</code>. If you need a custom script for building a Rust program, your script should set up the environment, then call <code>cookbook_cargo</code>, which calls Redox's version of <code>cargo</code>. If you need a custom script for using a <code>Makefile</code>, your script should set up the environment, then call <code>cookbook_configure</code>. If you have a custom build process, or you have a patch-and-build script, you can just include that in the <code>script</code> section and not use either of the above functions. If you are interested in looking at the code that runs custom scripts, see the function <code>build()</code> in <code>cookbook</code>'s <a href="https://gitlab.redox-os.org/redox-os/-/blob/master/src/bin/cook.rs">cook.rs</a>.</p>
<p>Adding a dependency on <code>openssl</code> ensures that the build of <code>openssl</code> will happen before attempting to build <code>gitoxide</code>, so we can trust that the library contents are in the target directory of the ssl package. And we need to set the environment variables as described in the <a href="https://docs.rs/openssl/latest/openssl/">OpenSSL bindings</a> crate docs.</p>
<p>Our recipe now looks like this:</p>
<pre><code class="language-toml">#[source]
#git = "https://github.com/Byron/gitoxide.git"
[build]
dependencies = [
    "openssl",
]
template = "custom"
script = """
export OPENSSL_DIR="${COOKBOOK_SYSROOT}"
export OPENSSL_STATIC="true"
cookbook_cargo
"""
</code></pre>
<h2 id="linker-errors"><a class="header" href="#linker-errors">Linker Errors</a></h2>
<p>Now we get to the point where the linker is trying to statically link the program and libraries into the executable. This program, called <code>ld</code>, will report errors if there are any undefined functions or missing static variable definitions.</p>
<pre><code>undefined reference to `tzset'
undefined reference to `cfmakeraw'
</code></pre>
<p>In our case we find we are missing <code>tzset</code>, which is a timezone function. We are also missing <code>cfmakeraw</code> from <code>termios</code>. Both of these functions are normally part of <code>libc</code>. In our case, they are defined in the <code>libc</code> crate, but they are not implemented by Redox's version of <code>libc</code>, which is called <code>relibc</code>. We need to add these functions.</p>
<h2 id="add-missing-functions-to-relibc"><a class="header" href="#add-missing-functions-to-relibc">Add Missing Functions to relibc</a></h2>
<p>Let's set up to modify <code>relibc</code>. As with <code>cookbook</code>, we need a fork of <a href="https://gitlab.redox-os.org/redox-os/relibc">relibc</a>. Click on the <code>Fork</code> button and add a public fork. Then update our local <code>relibc</code> repo and branch.</p>
<pre><code class="language-sh">cd ~/redox-gitoxide/redox/recipes/core/relibc/source
</code></pre>
<pre><code class="language-sh">git remote rename origin upstream
</code></pre>
<pre><code class="language-sh">git rebase upstream master
</code></pre>
<pre><code class="language-sh">git remote add origin https://gitlab.redox-os.org/MY_USERNAME/relibc
</code></pre>
<pre><code class="language-sh">git checkout -b gitoxide-port
</code></pre>
<p>Now we need to make our changes to <code>relibc</code>...</p>
<p>After a fair bit of work, which we omit here, the functions <code>tzset</code> and <code>cfmakeraw</code> are implemented in <code>relibc</code>. An important note is that in order to publish the functions, they need to be preceded with:</p>
<pre><code>#[no_mangle]
extern "C" fn tzset() ...
</code></pre>
<p>Now let's update the relibc/gitoxide and update the Redox image:</p>
<pre><code class="language-sh">cd ~/redox-gitoxide/redox
</code></pre>
<pre><code class="language-sh">cd recipes/core/relibc/source
</code></pre>
<pre><code class="language-sh">cargo update
</code></pre>
<pre><code class="language-sh">cd -
</code></pre>
<pre><code class="language-sh">make crp.relibc,gitoxide
</code></pre>
<h2 id="testing-in-qemu"><a class="header" href="#testing-in-qemu">Testing in QEMU</a></h2>
<p>Now we need to build a full Redox image and run it in QEMU. Let's make a configuration file.</p>
<pre><code class="language-sh">cd ~/redox-gitoxide/redox/config/x86_64
</code></pre>
<pre><code class="language-sh">cp desktop.toml my_desktop.toml
</code></pre>
<pre><code class="language-sh">nano my_desktop.toml
</code></pre>
<p>Note that the prefix "my_" at the beginning of the config file name means that it is gitignore'd, so it is preferred that you prefix your config name with "my_".</p>
<p>In <code>my_desktop.toml</code>, at the end of the list of packages, after <code>uutils = {}</code>, add</p>
<pre><code class="language-toml">gitoxide = {}
</code></pre>
<p>Now let's tell <code>make</code> about our new config definition, build the system, and test our new command.</p>
<pre><code class="language-sh">cd ~/redox-gitoxide/redox
</code></pre>
<pre><code class="language-sh">echo "CONFIG_NAME?=my_desktop" &gt;&gt; .config
</code></pre>
<pre><code class="language-sh">make qemu
</code></pre>
<p>Log in to Redox as <code>user</code> with no password, and type:</p>
<pre><code class="language-sh">gix clone https://gitlab.redox-os.org/redox-os/website
</code></pre>
<p>We get some errors, but we are making progress.</p>
<h2 id="submitting-the-mrs"><a class="header" href="#submitting-the-mrs">Submitting the MRs</a></h2>
<ul>
<li>Before committing our new recipe, we need to uncomment the <code>[source]</code> section. Edit <code>~/redox-gitoxide/redox/recipes/gitoxide/recipe.toml</code> to remove the <code>#</code> from the start of the first two lines.</li>
<li>We commit our changes to <code>redox</code> to include the new <code>gitoxide</code> recipe and submitted an MR, following the instructions <a href="./creating-proper-pull-requests.html">Creating Proper Pull Requests</a>.</li>
<li>We committed our changes to <code>relibc</code>. We need to rebuild the system and test it thoroughly in QEMU, checking anything that might be affected by our changes. Once we are confident in our changes, we can submit the MR.</li>
<li>We post links to both MRs on the <a href="https://matrix.to/#/#redox-mrs:matrix.org">Redox OS/MRs</a> room to ensure they get reviewed.</li>
<li>After making our changes to <code>libc</code> and testing them, we need to request to have those changes upstreamed by posting a message on the <a href="https://matrix.to/#/#redox-mrs:matrix.org">Redox OS/MRs</a> room. If the changes are complex, please create an issue on the <a href="https://gitlab.redox-os.org/redox-os/redox">build system repository</a> and include a link to it in your post.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="continuous-integration"><a class="header" href="#continuous-integration">Continuous Integration</a></h1>
<p>The <a href="https://en.wikipedia.org/wiki/Continuous_integration">continuous integration</a> helps developers to automate the program testing as the code evolves, it detects broken things or regressions.</p>
<p>The developer add a configuration file on the Git repository root with the commands to test the things.</p>
<p>Most known as "CI", it's provided by a Git service (like GitHub and GitLab) in most cases.</p>
<p>In Redox we use the <a href="https://gitlab.redox-os.org/redox-os/redoxer">Redoxer</a> program to setup our GitLab CI configuration file, it downloads our toolchain, build the program to the Redox target using Cargo and run the program inside a Redox virtual machine.</p>
<h2 id="configure-your-repository"><a class="header" href="#configure-your-repository">Configure Your Repository</a></h2>
<p>To setup your CI runner with Redoxer you need to add these commands to your CI configuration file:</p>
<ul>
<li>Install Redoxer</li>
</ul>
<pre><code class="language-sh">cargo install redoxer
</code></pre>
<ul>
<li>Install the Redox toolchain on Redoxer</li>
</ul>
<pre><code class="language-sh">redoxer toolchain
</code></pre>
<ul>
<li>Build your program or library to Redox</li>
</ul>
<pre><code class="language-sh">redoxer build
</code></pre>
<p>You need to customize Redoxer for your needs (test types of your CI jobs)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="performance"><a class="header" href="#performance">Performance</a></h1>
<ul>
<li><a href="performance.html#kernel-profiling">Kernel Profiling</a></li>
<li><a href="performance.html#benchmarks">Benchmarks</a></li>
</ul>
<h2 id="kernel-profiling"><a class="header" href="#kernel-profiling">Kernel Profiling</a></h2>
<p>You can create a flamegraph showing the kernel's most frequent operations, using time-based sampling.</p>
<p>One CPU core is allocated for capturing the profiling data. The instruction pointers of the other cores are copied at regular intervals. If the sampled core is in supervisor mode, the instruction address is added to the profile data. If it is in user mode, it is ignored. The <code>profiled</code> daemon copies the captured profile data to a file.</p>
<p>This is an example flamegraph. If you open the image in a new tab, there is useful mouse-over behavior.</p>
<p><img src="./assets/kernel_flamegraph.svg" alt="Kernel Flamegraph" title="Kernel Flamegraph" /></p>
<p>The steps below are for profiling on <code>x86_64</code>, running in <code>QEMU</code>. It is possible to run the tests on real hardware, although retrieving the data may be challenging.</p>
<h3 id="setup-2"><a class="header" href="#setup-2">Setup</a></h3>
<ol>
<li>
<p>Open a terminal window in the <code>redox</code> directory.</p>
</li>
<li>
<p>Install tools:</p>
</li>
</ol>
<pre><code class="language-sh">cargo install redox-kprofiling
</code></pre>
<pre><code class="language-sh">cargo install inferno
</code></pre>
<ol start="3">
<li>
<p>Make sure you have the kernel source by running <code>make f.kernel</code>.</p>
</li>
<li>
<p>Open a second terminal window in the directory <code>recipes/core/kernel</code></p>
</li>
<li>
<p>Edit <code>recipe.toml</code> in the <code>kernel</code> directory. First, comment out the <code>[source]</code> section so the build process does not try to fetch the source again.</p>
</li>
</ol>
<pre><code class="language-toml"># [source]
# git = "https://gitlab.redox-os.org/redox-os/kernel.git"
</code></pre>
<ol start="6">
<li>You need to enable the <code>profiling</code> feature for the kernel. This can be done two ways, either in <code>recipe.toml</code> or in <code>source/Cargo.toml</code>. For <code>recipe.toml</code>, add the line <code>--features profiling \</code> to the <code>cargo</code> command. (The backslash is needed to continue the command.)</li>
</ol>
<pre><code class="language-sh">cargo rustc \
    --bin kernel \
    --features profiling \ &lt;- Add this line
    ...
</code></pre>
<p>If you prefer to modify <code>source/Cargo.toml</code>, then you can add <code>profiling</code> to the default features. (This also helps if you are using an IDE.)</p>
<pre><code class="language-toml">[features]
default = ["profiling", ...]
</code></pre>
<ol start="7">
<li>
<p>(Optional) In the <code>kernel</code> directory, edit <code>source/src/profiling.rs</code>: set <code>HARDCODED_CPU_COUNT</code> to the number of CPU cores on the machine that will be profiled, minus one (one core is dedicated to profiling). Also consider changing the size of the buffers used for recording profile data, <code>const N: usize</code>, depending on how much RAM is available. 64MiB is a reasonable minimum, but if you have the memory available, you can increase it to 256MiB.</p>
</li>
<li>
<p>The profiling code is written primarily for QEMU, but for real hardware, consider commenting out the <code>serio_command</code> code in <code>profiling.rs</code>, which is to enable or disable profiling.</p>
</li>
<li>
<p>In your first terminal window, from the <code>redox</code> directory, create the filesystem config <code>config/x86_64/my_profiler.toml</code> with the following content.</p>
</li>
</ol>
<pre><code class="language-toml">include = [ "minimal.toml" ]

# General settings
[general]
# Filesystem size in MiB
filesystem_size = 1024

# Package settings
[packages]
# This is the profiling daemon
profiled = {}
# Add any other packages you need for testing here

# Init script to start the profile daemon
# The sequence number "01" ensures it will be started right after the drivers
[[files]]
path = "/usr/lib/init.d/01_profile"
data = """
profiled
"""

[[files]]
path = "/usr/bin/perf_tests.sh"
data = """
dd bs=4k count=100000 &lt; /scheme/zero &gt; /scheme/null
"""

# Script to perform performance tests - add your tests here
# If you will be testing manually, you don't need this section
[[files]]
path = "/usr/lib/init.d/99_tests"
data = """
echo Waiting for startup to complete...
sleep 5
echo
echo Running tests...
ion -x /usr/bin/perf_tests.sh
echo Shutting down...
shutdown
"""
</code></pre>
<ol start="10">
<li>In the <code>redox</code> directory, create the file <code>.config</code> with the following content:</li>
</ol>
<pre><code class="language-make"># This needs to match the name of your filesystem config file
CONFIG_NAME=my_profiler
# Core count; this needs to be HARDCODED_CPU_COUNT+1
QEMU_SMP=5
# Memory size in MiB; 8GiB is the minimum, larger is better
QEMU_MEM=8192
# Don't use the display
gpu=no
</code></pre>
<ol start="11">
<li>In the <code>redox</code> terminal window, run the <code>make rp.kernel</code> (or <code>make rebuild</code> if needed) command.</li>
</ol>
<h3 id="profiling"><a class="header" href="#profiling">Profiling</a></h3>
<ol start="12">
<li>
<p>In your <code>redox</code> terminal window, run <code>make qemu</code> or your preferred VM command, and perform your testing. You will see console messages indicating that profile data is being logged. <strong>Exit QEMU or your VM</strong> before proceeding, if it did not exit automatically.</p>
</li>
<li>
<p>In the <code>redox</code> directory, run the following commands.</p>
</li>
</ol>
<pre><code class="language-sh"># Create a directory for your data
mkdir my_profiler_data
</code></pre>
<pre><code class="language-sh"># Make the Redox filesystem accessible at the path based on CONFIG_NAME
make mount
</code></pre>
<pre><code class="language-sh"># Copy the profiling data from the Redox image to your directory
cp build/x86_64/my_profiler/filesystem/root/profiling.txt my_profiler_data
</code></pre>
<pre><code class="language-sh"># Important - unmount the Redox filesystem
make unmount
</code></pre>
<ol start="15">
<li><code>cd</code> into the new directory and generate a symbol table for the kernel.</li>
</ol>
<pre><code class="language-sh">cd my_profiler_data
</code></pre>
<pre><code class="language-sh">nm -CS ../recipes/core/kernel/target/x86_64-unknown-redox/build/kernel &gt; kernel_syms.txt
</code></pre>
<ol start="16">
<li>
<p>The next step is to determine the TSC frequency. TL;DR - just use your CPU clock rate in GHz. The TSC is a counter that tracks the clock cycles since the system was powered on. The TSC frequency can vary based when power saving is enabled, but Redox does not implement this yet, so CPU GHz should work fine.</p>
</li>
<li>
<p>Determine what formatting options you want for your flamegraph - 'i' for relaxed checking of function length, 'o' for reporting function plus offset rather than just function, 'x' for both grouping by function and with offset.</p>
</li>
<li>
<p>In the directory <code>my_profiler_data</code>, generate the flamegraph.</p>
</li>
</ol>
<pre><code class="language-sh">redox-kprofiling profiling.txt kernel_syms.txt x y.z | inferno-collapse-perf | inferno-flamegraph &gt; kernel_flamegraph.svg
</code></pre>
<p>Replace the <code>x</code> with your preferred formatting options. Replace the <code>y.z</code> with your TSC/CPU Clock frequency in GHz (<code>2.2</code>, for example).</p>
<p>Then view your flamegraph in a browser.</p>
<pre><code class="language-sh">firefox kernel_flamegraph.svg
</code></pre>
<h3 id="real-hardware-untested"><a class="header" href="#real-hardware-untested">Real Hardware (untested)</a></h3>
<ul>
<li>
<p>You need to set <code>HARDCODED_CPU_COUNT</code> to the number of actual CPU cores - 1, and there must be at least 512 MiB reserved per core.</p>
</li>
<li>
<p>Boot the system, and when you're done profiling, kill <code>profiled</code> and extract <code>/root/profiling.txt</code> (Details TBD)</p>
</li>
</ul>
<h2 id="benchmarks"><a class="header" href="#benchmarks">Benchmarks</a></h2>
<p>This section give some commands to benchmark Redox.</p>
<!--
- CPU benchmark
TODO: port the sha256sum tool to redox
```sh
dd bs=1M count=1024 if=/scheme/zero | sha256sum
```
-->
<ul>
<li>RAM benchmark</li>
</ul>
<pre><code class="language-sh">dd bs=1M count=1024 if=/scheme/zero of=/scheme/null
</code></pre>
<ul>
<li>Filesystem read speed benchmark</li>
</ul>
<p>(Add the <code>neverball</code> recipe on your filesystem image, you can also install it with the <code>sudo pkg install neverball</code> command)</p>
<pre><code class="language-sh">dd bs=1M count=256 if=/usr/games/neverball/neverball of=/scheme/null conv=fdatasync
</code></pre>
<ul>
<li>Filesystem write speed benchmark</li>
</ul>
<p>(Add the <code>neverball</code> recipe on your filesystem image, you can also install it with the <code>sudo pkg install neverball</code> command)</p>
<pre><code class="language-sh">dd bs=1M count=256 if=/usr/games/neverball/neverball of=fs_write_speed_bench conv=fdatasync
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="system-call-tracing"><a class="header" href="#system-call-tracing">System Call Tracing</a></h1>
<p>If you want to monitor what system calls are being made by a program, to investigate behavior, bugs or performance, there is a mechanism set up to do this.</p>
<p>You will learn how to configure the kernel to print a trace of system calls.</p>
<h2 id="ä¿®æ”¹å…§æ ¸"><a class="header" href="#ä¿®æ”¹å…§æ ¸">ä¿®æ”¹å…§æ ¸</a></h2>
<p>You will be modifying the kernel, but you won't be making extensive changes, so you don't need to bother with GitLab stuff, unless you intend to do this frequently. This description assumes you will look after that yourself.</p>
<ul>
<li>The kernel source is in the directory <code>recipes/core/kernel/source</code></li>
<li>If the directory is missing, go to your <code>redox</code> directory and run <code>make f.kernel</code></li>
</ul>
<p>Once you have fetched the kernel source into its "source" directory, you should disable the <code>[source]</code> section of the kernel recipe, so the build system doesn't try to update the kernel code.</p>
<ul>
<li>In the file <code>recipes/core/kernel/recipe.toml</code>, comment out the lines in the source section:</li>
</ul>
<pre><code># [source]
# git = "https://gitlab.redox-os.org/redox-os/kernel.git"
</code></pre>
<h2 id="feature-syscall_debug"><a class="header" href="#feature-syscall_debug">feature "syscall_debug"</a></h2>
<p>In order to configure printing out of system calls, you will need to enable the feature "syscall_debug" for the kernel.</p>
<ul>
<li>In the file <code>recipes/core/kernel/source/Cargo.toml</code>, scroll down to the default features list (maybe around line 50), and add the feature "syscall_debug":</li>
</ul>
<pre><code>default = [
  "acpi",
  "multi_core",
  "graphical_debug",
  "serial_debug",
  "self_modifying",
  "x86_kvm_pv",
  "syscall_debug", &lt;---- Like this
]
</code></pre>
<h2 id="modify-the-debugrs-file"><a class="header" href="#modify-the-debugrs-file">Modify the "debug.rs" file</a></h2>
<p>The file <code>src/syscall/debug.rs</code> contains the code to print out the system calls that match a particular set of conditions.</p>
<p>In the function <code>debug_start</code> (maybe around line 228), the boolean <code>do_debug</code> determines if the system calls should be printed.</p>
<p>It looks like this right now:</p>
<pre><code>pub fn debug_start([a, b, c, d, e, f]: [usize; 6]) {
    let do_debug = if false &amp;&amp; crate::context::current().read().name.contains("acpid") {
        if a == SYS_CLOCK_GETTIME || a == SYS_YIELD || a == SYS_FUTEX {
            false
        } else if (a == SYS_WRITE || a == SYS_FSYNC) &amp;&amp; (b == 1 || b == 2) {
            false
        } else {
            true
        }
    } else {
        false
    };
</code></pre>
<p>Obviously, the condition <code>false &amp;&amp; whatever</code> will evaluate to false, so remove the first bit (it's to prevent accidentally turning tracing on)</p>
<p>The program name is read from the context, and compared with the string you specify. The name from the context normally has the full path, so we just use the <code>contains({name})</code> test.</p>
<p>But if your program is called "ls" for example, you will get a system call trace for any program that contains the letters "ls", so you could try something like <code>ends_with("/ls")</code>.</p>
<p>You can modify the boolean expression however you want, assuming you are not publishing the code. You will need something a little fancier if you want messages for more than one program, for example.</p>
<p>If you want to hold onto the lock for the context a little longer, you will have to rework the expression a bit.</p>
<p>Next, there are some system calls that we skip because they are very frequent and not usually interesting. But if you want to get that level of detail, feel free to modify which system calls are filtered, <code>gettime</code>, <code>yield</code> and <code>futex</code> are typically ignored.</p>
<p>Also, writes to file descriptors 1 and 2 (stdout and stderr) are typically not reported so it doesn't interfere with output and debug code from your program as much.</p>
<p>A message will be printed at the start of the system call, and a message will be printed when the system call completes.</p>
<p>(A flag is set so the kernel knows to print the result.)</p>
<h2 id="building-the-changes"><a class="header" href="#building-the-changes">Building The Changes</a></h2>
<p>To include these changes in your Redox image, run the following command:</p>
<pre><code>make rp.kernel
</code></pre>
<p>Or (if the above doesn't work)</p>
<pre><code>make r.kernel image
</code></pre>
<h2 id="where-do-the-messages-go"><a class="header" href="#where-do-the-messages-go">Where Do The Messages Go</a></h2>
<p>The kernel will print the messages on the console, if you are running <code>make qemu</code> the messages will appear in that terminal.</p>
<ul>
<li>Consider to run the following command to capture the output:</li>
</ul>
<pre><code>make qemu |&amp; tee my_log.txt
</code></pre>
<p>If you are doing the testing on real hardware you should probably use the <code>server</code> variant and run commands from the console.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quick-workflow"><a class="header" href="#quick-workflow">Quick Workflow</a></h1>
<p>This page contains the most quick testing/development workflow for people that want an direct list to do things.</p>
<p><strong>You need to fully understand the build system to use this workflow, as it don't give a detailed explanation of each command to save time and space</strong></p>
<ul>
<li><a href="quick-workflow.html#install-rust-nightly">Install Rust Nightly</a></li>
<li><a href="quick-workflow.html#update-rust">Update Rust</a></li>
<li><a href="quick-workflow.html#download-a-new-build-system-copy-without-the-bootstrap-script">Download a new build system copy without the bootstrap script</a></li>
<li><a href="quick-workflow.html#install-the-required-dependencies-for-the-build-system">Install the required dependencies for the build system</a></li>
<li><a href="quick-workflow.html#download-and-run-the-podman_bootstrapsh-script">Download and run the "podman_bootstrap.sh" script</a></li>
<li><a href="quick-workflow.html#build-the-system">Build the system</a></li>
<li><a href="quick-workflow.html#update-the-build-system-and-its-submodules">Update the build system and its submodules</a></li>
<li><a href="quick-workflow.html#update-the-toolchain-and-relibc">Update the toolchain and relibc</a></li>
<li><a href="quick-workflow.html#update-recipes-and-redox-image">Update recipes and Redox image</a></li>
<li><a href="quick-workflow.html#update-everything">Update everything</a></li>
<li><a href="quick-workflow.html#wipe-the-toolchain-and-download-again">Wipe the toolchain and download again</a></li>
<li><a href="quick-workflow.html#wipe-the-toolchainrecipe-binaries-and-downloadbuild-them-again">Wipe the toolchain/recipe binaries and download/build them again</a></li>
<li><a href="quick-workflow.html#wipe-toolchainrecipe-binaries-and-podman-container-update-build-system-source-and-rebuild-the-system">Wipe toolchain/recipe binaries and Podman container, update build system source and rebuild the system</a></li>
<li><a href="quick-workflow.html#wipe-all-recipe-sourcesbinaries-and-downloadbuild-them-again">Wipe all recipe sources/binaries and download/build them again</a></li>
<li><a href="quick-workflow.html#use-the-myfiles-recipe-to-insert-your-files-on-redox-image">Use the "myfiles" recipe to insert your files on Redox image</a></li>
<li><a href="quick-workflow.html#disable-a-recipe-on-the-filesystem-configuration">Disable a recipe on the filesystem configuration</a></li>
<li><a href="quick-workflow.html#create-logs">Create logs</a></li>
<li><a href="quick-workflow.html#temporarily-build-the-toolchain-from-source">Temporarily build the toolchain from source</a></li>
<li><a href="quick-workflow.html#build-some-filesystem-configuration-for-some-cpu-architecture">Build some filesystem configuration for some CPU architecture</a></li>
<li><a href="quick-workflow.html#build-some-filesystem-configuration-for-some-cpu-architecture-using-pre-built-packages-from-the-build-server">Build some filesystem configuration for some CPU architecture (using pre-built packages from the build server)</a></li>
<li><a href="quick-workflow.html#boot-redox-on-qemu-from-a-nvme-device">Boot Redox on QEMU from a NVMe device</a></li>
<li><a href="quick-workflow.html#boot-redox-on-qemu-from-a-nvme-device-with-a-custom-number-of-cpu-threads">Boot Redox on QEMU from a NVMe device with a custom number of CPU threads</a></li>
<li><a href="quick-workflow.html#boot-redox-on-qemu-from-a-nvme-device-a-custom-number-of-cpu-threads-and-memory">Boot Redox on QEMU from a NVMe device, a custom number of CPU threads and memory</a></li>
</ul>
<h4 id="install-rust-nightly"><a class="header" href="#install-rust-nightly">Install Rust Nightly</a></h4>
<pre><code class="language-sh">curl https://sh.rustup.rs -sSf | sh -s -- --default-toolchain nightly
</code></pre>
<p>Use Case: Configure the host system without the build system bootstrap scripts.</p>
<h4 id="update-rust"><a class="header" href="#update-rust">Update Rust</a></h4>
<pre><code class="language-sh">rustup update
</code></pre>
<p>Use Case: Try to fix Rust problems.</p>
<h4 id="download-a-new-build-system-copy-without-the-bootstrap-script"><a class="header" href="#download-a-new-build-system-copy-without-the-bootstrap-script">Download a new build system copy without the bootstrap script</a></h4>
<pre><code class="language-sh">git clone https://gitlab.redox-os.org/redox-os/redox.git --origin upstream
</code></pre>
<p>Use Case: Commonly used when a big build system breakage was not prevented before an update or wipe leftovers.</p>
<h3 id="install-the-required-dependencies-for-the-build-system"><a class="header" href="#install-the-required-dependencies-for-the-build-system">Install the required dependencies for the build system</a></h3>
<pre><code class="language-sh">curl -sf https://gitlab.redox-os.org/redox-os/redox/raw/master/podman_bootstrap.sh -o podman_bootstrap.sh
</code></pre>
<pre><code class="language-sh">bash -e podman_bootstrap.sh -d
</code></pre>
<p>Use Case: Install new build tools or update the existing ones.</p>
<h4 id="download-and-run-the-podman_bootstrapsh-script"><a class="header" href="#download-and-run-the-podman_bootstrapsh-script">Download and run the "podman_bootstrap.sh" script</a></h4>
<pre><code class="language-sh">curl -sf https://gitlab.redox-os.org/redox-os/redox/raw/master/podman_bootstrap.sh -o podman_bootstrap.sh
</code></pre>
<pre><code class="language-sh">bash -e podman_bootstrap.sh
</code></pre>
<p>Use Case: Commonly used when a big build system breakage was not prevented before an update and install new build tools or update the existing ones.</p>
<h4 id="build-the-system"><a class="header" href="#build-the-system">Build the system</a></h4>
<pre><code class="language-sh">cd redox
</code></pre>
<pre><code class="language-sh">make all
</code></pre>
<p>Use Case: Build the system from a clean build system copy.</p>
<h4 id="update-the-build-system-and-its-submodules"><a class="header" href="#update-the-build-system-and-its-submodules">Update the build system and its submodules</a></h4>
<pre><code class="language-sh">make pull
</code></pre>
<p>Use Case: Keep the build system up-to-date.</p>
<h4 id="update-the-toolchain-and-relibc"><a class="header" href="#update-the-toolchain-and-relibc">Update the toolchain and relibc</a></h4>
<pre><code class="language-sh">make prefix r.relibc
</code></pre>
<p>Use Case: Keep the toolchain up-to-date.</p>
<h4 id="update-recipes-and-redox-image"><a class="header" href="#update-recipes-and-redox-image">Update recipes and Redox image</a></h4>
<pre><code class="language-sh">make rebuild
</code></pre>
<p>Use Case: Keep the Redox image up-to-date.</p>
<h4 id="update-everything"><a class="header" href="#update-everything">Update everything</a></h4>
<p>Install the <code>topgrade</code> tool to update your system packages (you can install it with <code>cargo install topgrade</code>)</p>
<pre><code class="language-sh">topgrade
</code></pre>
<pre><code class="language-sh">make pull
</code></pre>
<pre><code class="language-sh">make prefix rebuild
</code></pre>
<p>Use Case: Try to fix most problems caused by outdated recipes, toolchain and build system configuration.</p>
<h4 id="wipe-the-toolchain-and-download-again"><a class="header" href="#wipe-the-toolchain-and-download-again">Wipe the toolchain and download again</a></h4>
<pre><code class="language-sh">rm -rf prefix
</code></pre>
<pre><code class="language-sh">make prefix
</code></pre>
<p>Use Case: Commonly used to fix problems.</p>
<h4 id="wipe-the-toolchainrecipe-binaries-and-downloadbuild-them-again"><a class="header" href="#wipe-the-toolchainrecipe-binaries-and-downloadbuild-them-again">Wipe the toolchain/recipe binaries and download/build them again</a></h4>
<pre><code class="language-sh">make clean all
</code></pre>
<p>Use Case: Commonly used to fix breaking changes on recipes.</p>
<h4 id="wipe-toolchainrecipe-binaries-and-podman-container-update-build-system-source-and-rebuild-the-system"><a class="header" href="#wipe-toolchainrecipe-binaries-and-podman-container-update-build-system-source-and-rebuild-the-system">Wipe toolchain/recipe binaries and Podman container, update build system source and rebuild the system</a></h4>
<pre><code class="language-sh">make clean container_clean pull all
</code></pre>
<p>Use Case: Full build system binary cleanup and update to avoid most configuration breaking changes</p>
<h4 id="wipe-all-recipe-sourcesbinaries-and-downloadbuild-them-again"><a class="header" href="#wipe-all-recipe-sourcesbinaries-and-downloadbuild-them-again">Wipe all recipe sources/binaries and download/build them again</a></h4>
<pre><code class="language-sh">make distclean all
</code></pre>
<p>Use Case: Fix source/binary breaking changes on recipes or save space.</p>
<h4 id="use-the-myfiles-recipe-to-insert-your-files-on-redox-image"><a class="header" href="#use-the-myfiles-recipe-to-insert-your-files-on-redox-image">Use the "myfiles" recipe to insert your files on Redox image</a></h4>
<pre><code class="language-sh">mkdir recipes/other/myfiles/source
</code></pre>
<pre><code class="language-sh">nano config/your-cpu-arch/your-config.toml
</code></pre>
<pre><code class="language-toml">[packages]
myfiles = {}
</code></pre>
<pre><code class="language-sh">make rp.myfiles
</code></pre>
<p>Use Case: Quickly insert files on the Redox image or keep files between rebuilds.</p>
<h4 id="disable-a-recipe-on-the-filesystem-configuration"><a class="header" href="#disable-a-recipe-on-the-filesystem-configuration">Disable a recipe on the filesystem configuration</a></h4>
<pre><code class="language-sh">nano config/your-cpu-arch/your-config.toml
</code></pre>
<pre><code>#recipe-name = {}
</code></pre>
<p>Use Case: Mostly used if some default recipe is broken.</p>
<h4 id="create-logs"><a class="header" href="#create-logs">Create logs</a></h4>
<pre><code class="language-sh">make some-command 2&gt;&amp;1 | tee file-name.log
</code></pre>
<p>Use Case: Report errors.</p>
<h4 id="temporarily-build-the-toolchain-from-source"><a class="header" href="#temporarily-build-the-toolchain-from-source">Temporarily build the toolchain from source</a></h4>
<pre><code class="language-sh">make prefix PREFIX_BINARY=0
</code></pre>
<p>Use Case: Test toolchain fixes.</p>
<h4 id="build-some-filesystem-configuration-for-some-cpu-architecture"><a class="header" href="#build-some-filesystem-configuration-for-some-cpu-architecture">Build some filesystem configuration for some CPU architecture</a></h4>
<pre><code class="language-sh">make all CONFIG_NAME=your-config ARCH=your-cpu-arch
</code></pre>
<p>Use Case: Quickly build Redox variants without manual intervention on configuration files.</p>
<h4 id="build-some-filesystem-configuration-for-some-cpu-architecture-using-pre-built-packages-from-the-build-server"><a class="header" href="#build-some-filesystem-configuration-for-some-cpu-architecture-using-pre-built-packages-from-the-build-server">Build some filesystem configuration for some CPU architecture (using pre-built packages from the build server)</a></h4>
<p>(Much faster than the option above)</p>
<pre><code class="language-sh">make all REPO_BINARY=1 CONFIG_NAME=your-config ARCH=your-cpu-arch
</code></pre>
<p>Use Case: Quickly build Redox variants without system compilation and manual intervention on configuration files.</p>
<h4 id="boot-redox-on-qemu-from-a-nvme-device"><a class="header" href="#boot-redox-on-qemu-from-a-nvme-device">Boot Redox on QEMU from a NVMe device</a></h4>
<pre><code class="language-sh">make qemu disk=nvme
</code></pre>
<h4 id="boot-redox-on-qemu-from-a-nvme-device-with-a-custom-number-of-cpu-threads"><a class="header" href="#boot-redox-on-qemu-from-a-nvme-device-with-a-custom-number-of-cpu-threads">Boot Redox on QEMU from a NVMe device with a custom number of CPU threads</a></h4>
<pre><code class="language-sh">make qemu disk=nvme QEMU_SMP=number
</code></pre>
<h4 id="boot-redox-on-qemu-from-a-nvme-device-a-custom-number-of-cpu-threads-and-memory"><a class="header" href="#boot-redox-on-qemu-from-a-nvme-device-a-custom-number-of-cpu-threads-and-memory">Boot Redox on QEMU from a NVMe device, a custom number of CPU threads and memory</a></h4>
<pre><code class="language-sh">make qemu disk=nvme QEMU_SMP=number QEMU_MEM=number-in-mb
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="questions-feedback-reporting-issues"><a class="header" href="#questions-feedback-reporting-issues">Questions, Feedback, Reporting Issues</a></h1>
<ul>
<li>Most common high-level questions are answered in the <a href="https://www.redox-os.org/faq/">General FAQ</a>.</li>
<li>More complex high-level or low-level questions are answered in the <a href="./developer-faq.html">Developer FAQ</a>.</li>
</ul>
<p>If your question is not answered by the General or Developer FAQs please join and ask in the <a href="./chat.html">Redox Chat</a>. It is the best method to <strong>chat with the Redox Team</strong>.</p>
<p>If you would like to report issues, send a message on the Support room of the chat or create an issue <a href="https://gitlab.redox-os.org/redox-os/redox/-/issues">here</a> and click in the "New Issue" button.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
