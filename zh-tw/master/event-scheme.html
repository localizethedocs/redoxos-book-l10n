<!DOCTYPE HTML>
<html lang="zh_TW" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Event 方案 - The Redox Operating System</title>


        <!-- Custom HTML head -->
        <style>
        .light .redox-logo {
            content: url("assets/redox_light_512.png");
        }
        .rust .redox-logo {
            content: url("assets/redox_light_512.png");
        }
        .coal .redox-logo {
            content: url("assets/redox_dark_512.png");
        }
        .navy .redox-logo {
            content: url("assets/redox_dark_512.png");
        }
        .ayu .redox-logo {
            content: url("assets/redox_dark_512.png");
        }
        </style>
        <script type="text/javascript" src="ltd-provenance.js"></script>
        <script type="text/javascript" src="ltd-current.js"></script>
        <script type="text/javascript" src="../../ltd-config.js"></script>
        <script type="text/javascript" src="../../ltd-flyout.js"></script>

        <meta name="description" content="This book carefully describes the design, implementation, direction, and structure of Redox, the operating system.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Redox Operating System</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="event-方案"><a class="header" href="#event-方案">Event 方案</a></h1>
<p>The <code>event</code> scheme is a special scheme that is central to the operation of device drivers, schemes and other programs that receive events from multiple sources. It's like a "clearing house" for activity on multiple file descriptors. The daemon or client program performs a <code>read</code> operation on the <code>event</code> scheme, blocking until an event happens. It then examines the event to determine what file descriptor is active, and performs a non-blocking read of the active file descriptor. In this way, a program can have many sources to read from, and rather than blocking on one of those sources while another might be active, the program blocks only on the <code>event</code> scheme, and is unblocked if any one of the other sources become active.</p>
<p>The <code>event</code> scheme is conceptually similar to Linux's <a href="https://manpages.ubuntu.com/manpages/focal/en/man7/epoll.7.html"><code>epoll</code></a> mechanism.</p>
<h2 id="what-is-a-blocking-read"><a class="header" href="#what-is-a-blocking-read">What is a Blocking Read</a></h2>
<p>For a regular program doing a regular read of a regular file, the program calls <code>read</code>, providing an input buffer, and when the <code>read</code> call returns, the data has been placed into the input buffer. Behind the scenes, the system receives the <code>read</code> request and suspends the program, meaning that the program is put aside while it waits for something to happen. This is very convenient if the program has nothing to do while it waits for the <code>read</code> to complete. However, if the thing the program is reading from might take a long time, such as a slow device, a network connection or input from the user, and there are other things for the program to do, such as updating the screen, performing a blocking read can prevent handling these other activities in a timely manner.</p>
<h2 id="non-blocking-read"><a class="header" href="#non-blocking-read">Non-blocking Read</a></h2>
<p>To allow reading from multiple sources without getting stuck waiting for any particular one, a program can open a path using the <code>O_NONBLOCK</code> flag. If data is ready to be read, the system immediately copies the data to the input buffer and returns normally. However, if data is not ready to be read, the <code>read</code> operation returns an error of type <code>EAGAIN</code>, which indicates that the program should try again later.</p>
<p>Now your program can scan many file descriptors, checking if any of them have data available to read. However, if none have any data, you want your program to block until there is something to do. This is where the <code>event</code> scheme comes in.</p>
<h2 id="using-the-event-scheme"><a class="header" href="#using-the-event-scheme">Using the Event Scheme</a></h2>
<p>The purpose of the <code>event</code> scheme is to allow the daemon or client program to receive a message on the <code>event_file</code>, to inform it that some other file descriptor is ready to be read. The daemon reads from the <code>event_file</code> to determine which other file descriptor is ready. If no other descriptor is ready, the <code>read</code> of the <code>event_file</code> will block, causing the daemon to be suspended until the event scheme indicates some other file descriptor is ready.</p>
<p>Before setting up the event scheme, you should <code>open</code> all the other resources you will be working with, but set them to be non-blocking. E.g. if you are a scheme provider, open your scheme in non-blocking mode,</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut scheme_file = OpenOptions::new()
            .create(true)
            .read(true)
            .write(true)
            .custom_flags(syscall::O_NONBLOCK as i32)
            .open(":myscheme")
            .expect("mydaemon: failed to create myscheme: scheme");
<span class="boring">}</span></code></pre></pre>
<p>The first step in using the event scheme is to open a connection to it. Each program will have a connection to the event scheme that is unique, so no path name is required, only the name of the scheme itself.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let event_file = File::open("/scheme/event");
// you actually need to open it read/write
<span class="boring">}</span></code></pre></pre>
<p>Next, write messages to the event scheme, one message per file descriptor that the <code>event</code> scheme should monitor. A message is in the form of a <code>syscall::data::Event</code> struct.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use syscall::data::Event;
let _ = event_file.write(&amp;Event{ id: scheme_file.as_raw_fd(), ... });
// write one message per file descriptor
<span class="boring">}</span></code></pre></pre>
<p>Note that timers in Redox are also handled via a scheme, so if you will be using a timer, you will need to open the <code>timer</code> scheme, and include that file descriptor among the ones your <code>event_file</code> should listen to.</p>
<p>Once your setup of the <code>event</code> scheme is complete, you begin your main loop:</p>
<ol>
<li>Perform a blocking read on the <code>event</code> file descriptor. <code>event_file.read(&amp;mut event_buf);</code></li>
<li>When an event, such as data becoming available on a file descriptor, occurs, the <code>read</code> operation on the <code>event_file</code> will complete.</li>
<li>Look at the <code>event_buf</code> to see which file descriptor is active.</li>
<li>Perform a non-blocking read on that file descriptor.</li>
<li>Perform the appropriate processing.</li>
<li>If you are using a timer, write to the timer file descriptor to tell it when you want an event.</li>
<li>Repeat.</li>
</ol>
<h2 id="non-blocking-write"><a class="header" href="#non-blocking-write">Non-blocking Write</a></h2>
<p>Sometimes write operations can take time, such as sending a message synchronously or writing to a device with a limited buffer. The <code>event</code> scheme allows you to listen for write file descriptors to become unblocked. If a single file descriptor is opened in read-write mode, your program will need to register with the <code>event</code> scheme twice, once for reading and once for writing.</p>
<h2 id="implementing-non-blocking-reads-in-a-scheme"><a class="header" href="#implementing-non-blocking-reads-in-a-scheme">Implementing Non-blocking Reads in a Scheme</a></h2>
<p>If your scheme supports non-blocking reads by clients, you will need to include some machinery to work with the <code>event</code> scheme on your client's behalf:</p>
<ol>
<li>
<p>Wait for an event that indicates activity on your scheme. <code>event_file.read(&amp;mut event_buf);</code></p>
</li>
<li>
<p>Read a packet from your scheme file descriptor containing the request from the client program. <code>scheme_file.read(&amp;mut packet)</code> The packet contains the details of which file descriptor is being read, and where the data should be copied to.</p>
</li>
<li>
<p>If the client is performing a <code>read</code> that would block, then queue the client request and return the <code>EAGAIN</code> error, writing the error response to your scheme file descriptor.</p>
</li>
<li>
<p>When data is available to read, send an event by writing a special packet to your scheme, indicating the handle id that is active:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>scheme_file.write(&amp;Packet { a: syscall::number::SYS_FEVENT, b: handle_id, ... });
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>When routing this response back to the client, the kernel will recognize it as an event message, and post the event on the client's <code>event_fd</code>, if one exists.</p>
</li>
<li>
<p>The scheme provider does not know whether the client has actually set up an <code>event_fd</code>. The scheme provider must send the event "just in case".</p>
</li>
<li>
<p>If an event has already been sent, but the client has not yet performed a <code>read</code>, the scheme should not send additional events. In correctly coded clients, extra events should not cause problems, but an effort should be made to not send unnecessary events. Be wary, however, as race conditions can occur where you think an extra event is not required but it actually is.</p>
</li>
</ol>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="scheme-operation.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="example.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="scheme-operation.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="example.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
