msgid ""
msgstr ""
"Project-Id-Version: The Redox Operating System\n"
"POT-Creation-Date: 2026-02-09T03:19:51Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/shell.md:1
msgid "Ion"
msgstr ""

#: src/shell.md:3
msgid ""
"Ion is a terminal shell and library for shells/command execution in Redox, "
"it's used by default. Ion has it's own manual, which you can find on the "
"[Ion Manual](https://doc.redox-os.org/ion-manual/)."
msgstr ""

#: src/shell.md:5
msgid "1. The default shell in Redox"
msgstr ""

#: src/shell.md:7
msgid "What is a terminal shell?"
msgstr ""

#: src/shell.md:9
msgid ""
"A terminal shell is a layer around the operating system kernel and "
"libraries, that allows users to interact with the operating system. That "
"means a shell can be used on any operating system (Ion runs on both Linux "
"and Redox) or implementation of a standard library as long as the provided "
"API is the same. Shells can either be graphical (GUI) or command-line (CLI)."
msgstr ""

#: src/shell.md:11
msgid "Text shells"
msgstr ""

#: src/shell.md:13
msgid ""
"Text shells are programs that provide interactive user interface with an "
"operating system. A shell reads from users as they type and performs "
"operations according to the input. This is similar to read-eval-print loop "
"(REPL) found in many programming languages (e.g. Python)."
msgstr ""

#: src/shell.md:15
msgid "Typical Unix shells"
msgstr ""

#: src/shell.md:17
msgid ""
"Probably the most famous shell is [GNU Bash](https://www.gnu.org/software/"
"bash/), which can be found in the majority of Linux distributions, and also "
"in MacOSX. On the other hand, FreeBSD uses **tcsh** by default."
msgstr ""

#: src/shell.md:19
msgid ""
"There are many more shell implementations, but these two form the base of "
"two fundamentally different sets:"
msgstr ""

#: src/shell.md:21
msgid "Bourne shell syntax (bash, sh, zsh)"
msgstr ""

#: src/shell.md:22
msgid "C shell syntax (csh, tcsh)"
msgstr ""

#: src/shell.md:24
msgid ""
"Of course these two groups are not exhaustive; it is worth mentioning at "
"least the **fish** shell and **xonsh**. These shells are trying to abandon "
"some features of old-school shell to make the language safer and more sane."
msgstr ""

#: src/shell.md:26
msgid "Fancy features"
msgstr ""

#: src/shell.md:28
msgid ""
"Writing commands without any help from the shell would be very exhausting "
"and impossible to use for everyday work. Therefore, most shells (including "
"Ion of course!) include features such as command history, autocompletion "
"based on history or man pages, shortcuts to speed-up typing, etc."
msgstr ""

#: src/shell.md:30
msgid "2. A scripting language"
msgstr ""

#: src/shell.md:32
msgid ""
"Ion can also be used to write simple scripts for common tasks or system "
"configuration after startup. It is not meant as a fully-featured programming "
"language, but more like a glue to connect other programs together."
msgstr ""

#: src/shell.md:34
msgid "Relation to terminals"
msgstr ""

#: src/shell.md:36
msgid ""
"Early [terminals](https://en.wikipedia.org/wiki/Computer_terminal) were "
"devices used to communicate with large computer systems like [IBM mainframes]"
"(https://en.wikipedia.org/wiki/IBM_mainframe). Nowadays Unix-like operating "
"systems usually implement so called virtual terminals (tty stands for "
"teletypewriter ... whoa!) and terminal emulators (e.g. xterm, gnome-"
"terminal)."
msgstr ""

#: src/shell.md:38
msgid ""
"Terminals are used to read input from a keyboard and display textual output "
"of the shell and other programs running inside it. This means that a "
"terminal converts key strokes into control codes that are further used by "
"the shell. The shell provides the user with a command line prompt (for "
"instance: user name and working directory), line editing capabilities (Ctrl "
"+ a,e,u,k...), history, and the ability to run other programs (ls, uname, "
"vim, etc.) according to user's input."
msgstr ""

#: src/shell.md:40
msgid ""
"TODO: In Linux we have device files like `/dev/tty`, how is this concept "
"handled in Redox?"
msgstr ""

#: src/shell.md:42
msgid "Shell"
msgstr ""

#: src/shell.md:44
msgid ""
"When Ion is called without \"-c\", it starts a main loop, which can be found "
"inside `Shell.execute()`."
msgstr ""

#: src/shell.md:58
msgid "`self.print_prompt();` is used to print the shell prompt."
msgstr ""

#: src/shell.md:60
msgid ""
"The `readln()` function is the input reader. The code can be found in "
"`crates/ion/src/input_editor`."
msgstr ""

#: src/shell.md:62
msgid ""
"The documentation about `trim()` can be found on the [libstd documentation]"
"(https://doc.rust-lang.org/std/primitive.str.html#method.trim). If the "
"command is not empty, the `on_command` method will be called. Then, the "
"shell will update variables, and reprint the prompt."
msgstr ""

#: src/shell.md:72
msgid "// Execute commands\n"
msgstr ""

#: src/shell.md:75
msgid "// TODO move this logic into \"end\" command\n"
msgstr ""

#: src/shell.md:76
msgid "\"end\""
msgstr ""

#: src/shell.md:113
msgid ""
"First, `on_command` adds the commands to the shell history with  `self."
"history.add(command_string.to_string(), &self.variables);`."
msgstr ""

#: src/shell.md:115
msgid ""
"Then the script will be parsed. The parser code is in `crates/ion/src/peg."
"rs`. The parse will return a set of pipelines, with each pipeline containing "
"a set of jobs. Each job represents a single command with its arguments. You "
"can take a look in `crates/ion/src/peg.rs`."
msgstr ""

#: src/shell.md:133
msgid "What Happens Next:"
msgstr ""

#: src/shell.md:134
msgid ""
"If the current block is a collecting block (a for loop or a function "
"declaration) and the current command is ended, we close the block:"
msgstr ""

#: src/shell.md:135
msgid "If the block is a for loop we run the loop."
msgstr ""

#: src/shell.md:136
msgid ""
"If the block is a function declaration we push the function to the functions "
"list."
msgstr ""

#: src/shell.md:137
msgid ""
"If the current block is a collecting block but the current command is not "
"ended, we add the current command to the block."
msgstr ""

#: src/shell.md:138
msgid ""
"If the current block is not a collecting block, we simply execute the "
"current command."
msgstr ""

#: src/shell.md:140
msgid "The code blocks are defined in `crates/ion/src/flow_control.rs`."
msgstr ""

#: src/shell.md:147
msgid "The function code can be found in `crates/ion/src/functions.rs`."
msgstr ""

#: src/shell.md:149
msgid "The execution of pipeline content will be executed in `run_pipeline()`."
msgstr ""

#: src/shell.md:151
msgid ""
"The Command class inside `crates/ion/src/main.rs` maps each command with a "
"description and a method to be executed. For example:"
msgstr ""

#: src/shell.md:156 src/shell.md:158
msgid "\"cd\""
msgstr ""

#: src/shell.md:159
msgid "\"Change the current directory\\n    cd <path>\""
msgstr ""

#: src/shell.md:166
msgid ""
"`cd` is described by  `\"Change the current directory\\n    cd <path>\"`, "
"and when called the method `shell.directory_stack.cd(args, &shell."
"variables)` will be used. You can see its code in `crates/ion/src/"
"directory_stack.rs`."
msgstr ""
